type Dao @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  "block timestamp when the dao contract was deployed"
  createdAt: String!
  "transaction hash of the dao contract deployment"
  transactionHashSummon: Bytes!
  "contract address of the loot erc20 token"
  lootAddress: Bytes!
  "contract address of the shares erc20 token"
  sharesAddress: Bytes!
  "contract address of the gnosis safe treasury"
  safeAddress: Bytes!
  "indicates if loot transferability is on/off"
  lootPaused: Boolean!
  "indicates if shares transferability is on/off"
  sharesPaused: Boolean!
  "length in seconds of the current grace period"
  gracePeriod: BigInt!
  "length in seconds of the current voting period"
  votingPeriod: BigInt!
  "length in seconds of the current voting period and grace period"
  votingPlusGraceDuration: BigInt!
  "amount of network token required as tribute to submit a proposal"
  proposalOffering: BigInt!
  "minimum % of shares that must vote yes for it to pass"
  quorumPercent: BigInt!
  "amount of shares needed to automatically sponsor a proposal"
  sponsorThreshold: BigInt!
  "auto-fails a proposal if more than (1- minRetentionPercent) * total shares exit before processing"
  minRetentionPercent: BigInt!
  "name of the erc20 shares token"
  shareTokenName: String
  "symbol of the erc20 shares token"
  shareTokenSymbol: String
  "name of the erc20 loot token"
  lootTokenName: String
  "symbol of the erc20 loot token"
  lootTokenSymbol: String
  "total circulating shares tokens"
  totalShares: BigInt!
  "total circulating loot tokens"
  totalLoot: BigInt!
  "ID of the last sponsored proposal"
  latestSponsoredProposalId: BigInt!
  "count of proposal submitted"
  proposalCount: BigInt!
  "count of share or loot holding members"
  activeMemberCount: BigInt!
  "name of the DAO"
  name: String
  "proposals scoped to this dao"
  proposals: [Proposal!] @derivedFrom(field: "dao")
  "members scoped to this dao"
  members: [Member!] @derivedFrom(field: "dao")
  "rage quits scoped to this dao"
  rageQuits: [RageQuit!] @derivedFrom(field: "dao")
  "shaman scoped to this dao"
  shaman: [Shaman!] @derivedFrom(field: "dao")
  "metadata scoped to this dao"
  metaData: MetaData @derivedFrom(field: "dao")
  "transactions scoped to this dao"
  eventTransactions: EventTransaction @derivedFrom(field: "dao")
}

type Proposal @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  "block timestamp when the proposal was submitted"
  createdAt: String!
  "address that submitted the proposal"
  createdBy: Bytes!
  "related DAO entity"
  dao: Dao!
  "id of the proposal"
  proposalId: BigInt!
  "id of the previous proposal, set at sponsorship"
  prevProposalId: BigInt!
  "hash of raw transaction data that will be executed if the proposal passes"
  proposalDataHash: Bytes!
  "raw transaction data that will be executed if the proposal passes"
  proposalData: Bytes!
  "duration of the voting period for this proposal in seconds"
  votingPeriod: BigInt!
  "unix timestamp of when the voting period starts"
  votingStarts: BigInt!
  "unix timestamp of when the voting period ends"
  votingEnds: BigInt!
  "duration in seconds of the grace period for this proposal in seconds"
  gracePeriod: BigInt!
  "duration in seconds of the grace and voting periods for this proposal in seconds"
  votingPlusGraceDuration: BigInt!
  "unix timestamp of when the grace period ends"
  graceEnds: BigInt!
  "unix timestamp after which proposal should be considered invalid and skipped"
  expiration: BigInt!
  "estimated gas needed to execute the proposal actions"
  actionGasEstimate: BigInt!
  "string with human readable description of the proposal"
  details: String!
  "indicates if the proposal was automatically sponsored"
  selfSponsor: Boolean!
  "indicates if the proposal is sponsored"
  sponsored: Boolean!
  "address that sponsored the proposal"
  sponsor: Bytes!
  "indicates if the proposal is cancelled"
  cancelled: Boolean!
  "indicates if the proposal is processed"
  processed: Boolean!
  "indicates if the proposal is processed"
  actionFailed: Boolean!
  "indicates if the proposal passed"
  passed: Boolean!
  "amount of native token that was provided as tribute when the proposal was submitted"
  proposalOffering: BigInt!
  "number of current yes votes"
  yesVotes: BigInt!
  "number of current no votes"
  noVotes: BigInt!
  "amount of current shares that have voted yes"
  yesBalance: BigInt!
  "amount of current shares that have voted no"
  noBalance: BigInt!
  "indicates if the proposal is currently passing"
  currentlyPassing: Boolean!
  "highest share+loot count during any individual yes vote"
  maxTotalSharesAndLootAtYesVote: BigInt!
  "The following tribute fields will only have values if the proposal was submitted through the trbute minion contract. \n token address in tribute proposals."
  tributeToken: Bytes
  "amount of tribute token offered"
  tributeOffered: BigInt
  "symbol of the tribute token"
  tributeTokenSymbol: String
  "decimal places of the tribute token"
  tributeTokenDecimals: BigInt
  "applicant submitting the tribute proposal"
  tributeEscrowRecipient: Bytes
  "proposal type derived from the details field"
  proposalType: String!
  "proposal title derived from the details field"
  title: String
  "proposal description derived from the details field"
  description: String
  "proposal content URI derived from the details field"
  contentURI: String
  "proposal Content URI type (ipfs hash, url) derived from the details field"
  contentURIType: String
  "votes scoped to this proposal"
  votes: [Vote!] @derivedFrom(field: "proposal")
}

type Vote @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  "block timestamp when the vote was submitted"
  createdAt: String!
  "contract address of the DAO related to this vote"
  daoAddress: Bytes!
  "indicates yes vote/no vote"
  approved: Boolean!
  "shares balance of the voting member at the time of the vote"
  balance: BigInt!
  "related proposal"
  proposal: Proposal!
  "related/voting member"
  member: Member!
}

type Member @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  "block timestamp when the member entity was created (when the address first recieved shares or loot)"
  createdAt: String!
  "related dao"
  dao: Dao!
  "address of the member"
  memberAddress: Bytes!
  "current shares held by the member"
  shares: BigInt!
  "current loot held by the member"
  loot: BigInt!
  "address the member is delegating to"
  delegatingTo: Bytes!
  "amount of shares this address has delegated to it"
  delegateShares: BigInt!
  "related votes"
  votes: [Vote!] @derivedFrom(field: "member")
}

type RageQuit @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  "block timestamp when the member rage quit"
  createdAt: String!
  "related DAO"
  dao: Dao!
  "related member"
  member: Member!
  "address the tokens where rage quit to"
  to: Bytes!
  "number of shares rage quit"
  shares: BigInt!
  "number of loot rage quit"
  loot: BigInt!
  "list of treasury token addresses requested in the rage quit"
  tokens: [Bytes!]!
}

type Shaman @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  "block timestamp when the shaman was added"
  createdAt: String!
  "related DAO"
  dao: Dao!
  "address of the shaman"
  shamanAddress: Bytes!
  "permission level of the shaman (0-7)"
  permissions: BigInt!
}

type EventTransaction @entity {
  "unique identifier and primary key of the entity"
  id: ID!
  "block timestamp of the transaction"
  createdAt: String!
  "related DAO"
  dao: Dao!
}

type TokenLookup @entity {
  "unique identifier and primary key of the entity (share or loot token address)"
  id: ID!
  "related DAO"
  dao: Bytes!
}

type MetaData @entity {
  id: ID!
  createdAt: String!
  createdBy: Bytes!
  dao: Dao
  name: String
  rawContent: String!
}
