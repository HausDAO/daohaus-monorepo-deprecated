import * as React from 'react';
import React__default, { createContext, useMemo, createElement, useContext, useRef, useEffect as useEffect$1, useLayoutEffect as useLayoutEffect$1, useCallback, forwardRef, Children, isValidElement, cloneElement, Fragment as Fragment$1, useState as useState$1, useReducer } from 'react';
import * as ReactDOM from 'react-dom';
import ReactDOM__default, { flushSync, createPortal } from 'react-dom';
import styled, { createGlobalStyle, useTheme, keyframes, css, ThemeProvider } from 'styled-components';

const amber$1 = {
    amber1: 'hsl(36, 100%, 6.1%)',
    amber2: 'hsl(35, 100%, 7.6%)',
    amber3: 'hsl(32, 100%, 10.2%)',
    amber4: 'hsl(32, 100%, 12.4%)',
    amber5: 'hsl(33, 100%, 14.6%)',
    amber6: 'hsl(35, 100%, 17.1%)',
    amber7: 'hsl(35, 91.0%, 21.6%)',
    amber8: 'hsl(36, 100%, 25.5%)',
    amber9: 'hsl(39, 100%, 57.0%)',
    amber10: 'hsl(43, 100%, 64.0%)',
    amber11: 'hsl(39, 90.0%, 49.8%)',
    amber12: 'hsl(39, 97.0%, 93.2%)',
};

const blue$1 = {
    blue1: 'hsl(212, 35.0%, 9.2%)',
    blue2: 'hsl(216, 50.0%, 11.8%)',
    blue3: 'hsl(214, 59.4%, 15.3%)',
    blue4: 'hsl(214, 65.8%, 17.9%)',
    blue5: 'hsl(213, 71.2%, 20.2%)',
    blue6: 'hsl(212, 77.4%, 23.1%)',
    blue7: 'hsl(211, 85.1%, 27.4%)',
    blue8: 'hsl(211, 89.7%, 34.1%)',
    blue9: 'hsl(206, 100%, 50.0%)',
    blue10: 'hsl(209, 100%, 60.6%)',
    blue11: 'hsl(210, 100%, 66.1%)',
    blue12: 'hsl(206, 98.0%, 95.8%)',
};

const green$1 = {
    green1: 'hsl(146, 30.0%, 7.4%)',
    green2: 'hsl(155, 44.2%, 8.4%)',
    green3: 'hsl(155, 46.7%, 10.9%)',
    green4: 'hsl(154, 48.4%, 12.9%)',
    green5: 'hsl(154, 49.7%, 14.9%)',
    green6: 'hsl(154, 50.9%, 17.6%)',
    green7: 'hsl(153, 51.8%, 21.8%)',
    green8: 'hsl(151, 51.7%, 28.4%)',
    green9: 'hsl(151, 55.0%, 41.5%)',
    green10: 'hsl(151, 49.3%, 46.5%)',
    green11: 'hsl(151, 50.0%, 53.2%)',
    green12: 'hsl(137, 72.0%, 94.0%)',
};

const indigo$1 = {
    indigo1: 'hsl(229, 24.0%, 10.0%)',
    indigo2: 'hsl(230, 36.4%, 12.9%)',
    indigo3: 'hsl(228, 43.3%, 17.5%)',
    indigo4: 'hsl(227, 47.2%, 21.0%)',
    indigo5: 'hsl(227, 50.0%, 24.1%)',
    indigo6: 'hsl(226, 52.9%, 28.2%)',
    indigo7: 'hsl(226, 56.0%, 34.5%)',
    indigo8: 'hsl(226, 58.2%, 44.1%)',
    indigo9: 'hsl(226, 70.0%, 55.5%)',
    indigo10: 'hsl(227, 75.2%, 61.6%)',
    indigo11: 'hsl(228, 100%, 75.9%)',
    indigo12: 'hsl(226, 83.0%, 96.3%)',
};

const orange$1 = {
    orange1: 'hsl(30, 70.0%, 7.2%)',
    orange2: 'hsl(28, 100%, 8.4%)',
    orange3: 'hsl(26, 91.1%, 11.6%)',
    orange4: 'hsl(25, 88.3%, 14.1%)',
    orange5: 'hsl(24, 87.6%, 16.6%)',
    orange6: 'hsl(24, 88.6%, 19.8%)',
    orange7: 'hsl(24, 92.4%, 24.0%)',
    orange8: 'hsl(25, 100%, 29.0%)',
    orange9: 'hsl(24, 94.0%, 50.0%)',
    orange10: 'hsl(24, 100%, 58.5%)',
    orange11: 'hsl(24, 100%, 62.2%)',
    orange12: 'hsl(24, 97.0%, 93.2%)',
};

const pink$1 = {
    pink1: 'hsl(318, 25.0%, 9.6%)',
    pink2: 'hsl(319, 32.2%, 11.6%)',
    pink3: 'hsl(319, 41.0%, 16.0%)',
    pink4: 'hsl(320, 45.4%, 18.7%)',
    pink5: 'hsl(320, 49.0%, 21.1%)',
    pink6: 'hsl(321, 53.6%, 24.4%)',
    pink7: 'hsl(321, 61.1%, 29.7%)',
    pink8: 'hsl(322, 74.9%, 37.5%)',
    pink9: 'hsl(322, 65.0%, 54.5%)',
    pink10: 'hsl(323, 72.8%, 59.2%)',
    pink11: 'hsl(325, 90.0%, 66.4%)',
    pink12: 'hsl(322, 90.0%, 95.8%)',
};

const red$1 = {
    red1: 'hsl(353, 23.0%, 9.8%)',
    red2: 'hsl(357, 34.4%, 12.0%)',
    red3: 'hsl(356, 43.4%, 16.4%)',
    red4: 'hsl(356, 47.6%, 19.2%)',
    red5: 'hsl(356, 51.1%, 21.9%)',
    red6: 'hsl(356, 55.2%, 25.9%)',
    red7: 'hsl(357, 60.2%, 31.8%)',
    red8: 'hsl(358, 65.0%, 40.4%)',
    red9: 'hsl(358, 75.0%, 59.0%)',
    red10: 'hsl(358, 85.3%, 64.0%)',
    red11: 'hsl(358, 100%, 69.5%)',
    red12: 'hsl(351, 89.0%, 96.0%)',
};

const slate$1 = {
    slate1: 'hsl(200, 7.0%, 8.8%)',
    slate2: 'hsl(195, 7.1%, 11.0%)',
    slate3: 'hsl(197, 6.8%, 13.6%)',
    slate4: 'hsl(198, 6.6%, 15.8%)',
    slate5: 'hsl(199, 6.4%, 17.9%)',
    slate6: 'hsl(201, 6.2%, 20.5%)',
    slate7: 'hsl(203, 6.0%, 24.3%)',
    slate8: 'hsl(207, 5.6%, 31.6%)',
    slate9: 'hsl(206, 6.0%, 43.9%)',
    slate10: 'hsl(206, 5.2%, 49.5%)',
    slate11: 'hsl(206, 6.0%, 63.0%)',
    slate12: 'hsl(210, 6.0%, 93.0%)',
};

const violet$1 = {
    violet1: 'hsl(250, 20.0%, 10.2%)',
    violet2: 'hsl(255, 30.3%, 12.9%)',
    violet3: 'hsl(253, 37.0%, 18.4%)',
    violet4: 'hsl(252, 40.1%, 22.5%)',
    violet5: 'hsl(252, 42.2%, 26.2%)',
    violet6: 'hsl(251, 44.3%, 31.1%)',
    violet7: 'hsl(250, 46.8%, 38.9%)',
    violet8: 'hsl(250, 51.8%, 51.2%)',
    violet9: 'hsl(252, 56.0%, 57.5%)',
    violet10: 'hsl(251, 63.2%, 63.2%)',
    violet11: 'hsl(250, 95.0%, 76.8%)',
    violet12: 'hsl(252, 87.0%, 96.4%)',
};

const yellow$1 = {
    yellow1: 'hsl(45, 100%, 5.5%)',
    yellow2: 'hsl(46, 100%, 6.7%)',
    yellow3: 'hsl(45, 100%, 8.7%)',
    yellow4: 'hsl(45, 100%, 10.4%)',
    yellow5: 'hsl(47, 100%, 12.1%)',
    yellow6: 'hsl(49, 100%, 14.3%)',
    yellow7: 'hsl(49, 90.3%, 18.4%)',
    yellow8: 'hsl(50, 100%, 22.0%)',
    yellow9: 'hsl(53, 92.0%, 50.0%)',
    yellow10: 'hsl(54, 100%, 68.0%)',
    yellow11: 'hsl(48, 100%, 47.0%)',
    yellow12: 'hsl(53, 100%, 91.0%)',
};

const indigoA$1 = {
    indigoA1: 'hsla(0, 0%, 0%, 0)',
    indigoA2: 'hsla(234, 97.4%, 59.9%, 0.059)',
    indigoA3: 'hsla(228, 99.2%, 61.7%, 0.144)',
    indigoA4: 'hsla(227, 99.7%, 62.0%, 0.211)',
    indigoA5: 'hsla(227, 99.2%, 62.3%, 0.270)',
    indigoA6: 'hsla(226, 99.9%, 62.1%, 0.350)',
    indigoA7: 'hsla(226, 99.9%, 62.0%, 0.471)',
    indigoA8: 'hsla(226, 99.9%, 62.1%, 0.655)',
    indigoA9: 'hsla(226, 99.9%, 63.6%, 0.848)',
    indigoA10: 'hsla(227, 99.8%, 67.7%, 0.893)',
    indigoA11: 'hsla(227, 100%, 76.3%, 0.980)',
    indigoA12: 'hsla(226, 100%, 97.5%, 0.980)',
};

const amber = {
    amber1: 'hsl(39, 70.0%, 99.0%)',
    amber2: 'hsl(40, 100%, 96.5%)',
    amber3: 'hsl(44, 100%, 91.7%)',
    amber4: 'hsl(43, 100%, 86.8%)',
    amber5: 'hsl(42, 100%, 81.8%)',
    amber6: 'hsl(38, 99.7%, 76.3%)',
    amber7: 'hsl(36, 86.1%, 67.1%)',
    amber8: 'hsl(35, 85.2%, 55.1%)',
    amber9: 'hsl(39, 100%, 57.0%)',
    amber10: 'hsl(35, 100%, 55.5%)',
    amber11: 'hsl(30, 100%, 34.0%)',
    amber12: 'hsl(20, 80.0%, 17.0%)',
};

const blue = {
    blue1: 'hsl(206, 100%, 99.2%)',
    blue2: 'hsl(210, 100%, 98.0%)',
    blue3: 'hsl(209, 100%, 96.5%)',
    blue4: 'hsl(210, 98.8%, 94.0%)',
    blue5: 'hsl(209, 95.0%, 90.1%)',
    blue6: 'hsl(209, 81.2%, 84.5%)',
    blue7: 'hsl(208, 77.5%, 76.9%)',
    blue8: 'hsl(206, 81.9%, 65.3%)',
    blue9: 'hsl(206, 100%, 50.0%)',
    blue10: 'hsl(208, 100%, 47.3%)',
    blue11: 'hsl(211, 100%, 43.2%)',
    blue12: 'hsl(211, 100%, 15.0%)',
};

const green = {
    green1: 'hsl(136, 50.0%, 98.9%)',
    green2: 'hsl(138, 62.5%, 96.9%)',
    green3: 'hsl(139, 55.2%, 94.5%)',
    green4: 'hsl(140, 48.7%, 91.0%)',
    green5: 'hsl(141, 43.7%, 86.0%)',
    green6: 'hsl(143, 40.3%, 79.0%)',
    green7: 'hsl(146, 38.5%, 69.0%)',
    green8: 'hsl(151, 40.2%, 54.1%)',
    green9: 'hsl(151, 55.0%, 41.5%)',
    green10: 'hsl(152, 57.5%, 37.6%)',
    green11: 'hsl(153, 67.0%, 28.5%)',
    green12: 'hsl(155, 40.0%, 14.0%)',
};

const indigo = {
    indigo1: 'hsl(225, 60.0%, 99.4%)',
    indigo2: 'hsl(223, 100%, 98.6%)',
    indigo3: 'hsl(223, 98.4%, 97.1%)',
    indigo4: 'hsl(223, 92.9%, 95.0%)',
    indigo5: 'hsl(224, 87.1%, 92.0%)',
    indigo6: 'hsl(224, 81.9%, 87.8%)',
    indigo7: 'hsl(225, 77.4%, 82.1%)',
    indigo8: 'hsl(226, 75.4%, 74.5%)',
    indigo9: 'hsl(226, 70.0%, 55.5%)',
    indigo10: 'hsl(226, 58.6%, 51.3%)',
    indigo11: 'hsl(226, 55.0%, 45.0%)',
    indigo12: 'hsl(226, 62.0%, 17.0%)',
};

const orange = {
    orange1: 'hsl(24, 70.0%, 99.0%)',
    orange2: 'hsl(24, 83.3%, 97.6%)',
    orange3: 'hsl(24, 100%, 95.3%)',
    orange4: 'hsl(25, 100%, 92.2%)',
    orange5: 'hsl(25, 100%, 88.2%)',
    orange6: 'hsl(25, 100%, 82.8%)',
    orange7: 'hsl(24, 100%, 75.3%)',
    orange8: 'hsl(24, 94.5%, 64.3%)',
    orange9: 'hsl(24, 94.0%, 50.0%)',
    orange10: 'hsl(24, 100%, 46.5%)',
    orange11: 'hsl(24, 100%, 37.0%)',
    orange12: 'hsl(15, 60.0%, 17.0%)',
};

const red = {
    red1: 'hsl(359, 100%, 99.4%)',
    red2: 'hsl(359, 100%, 98.6%)',
    red3: 'hsl(360, 100%, 96.8%)',
    red4: 'hsl(360, 97.9%, 94.8%)',
    red5: 'hsl(360, 90.2%, 91.9%)',
    red6: 'hsl(360, 81.7%, 87.8%)',
    red7: 'hsl(359, 74.2%, 81.7%)',
    red8: 'hsl(359, 69.5%, 74.3%)',
    red9: 'hsl(358, 75.0%, 59.0%)',
    red10: 'hsl(358, 69.4%, 55.2%)',
    red11: 'hsl(358, 65.0%, 48.7%)',
    red12: 'hsl(354, 50.0%, 14.6%)',
};

const slate = {
    slate1: 'hsl(206, 30.0%, 98.8%)',
    slate2: 'hsl(210, 16.7%, 97.6%)',
    slate3: 'hsl(209, 13.3%, 95.3%)',
    slate4: 'hsl(209, 12.2%, 93.2%)',
    slate5: 'hsl(208, 11.7%, 91.1%)',
    slate6: 'hsl(208, 11.3%, 88.9%)',
    slate7: 'hsl(207, 11.1%, 85.9%)',
    slate8: 'hsl(205, 10.7%, 78.0%)',
    slate9: 'hsl(206, 6.0%, 56.1%)',
    slate10: 'hsl(206, 5.8%, 52.3%)',
    slate11: 'hsl(206, 6.0%, 43.5%)',
    slate12: 'hsl(206, 24.0%, 9.0%)',
};

function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}

function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const Context = /*#__PURE__*/ createContext(defaultContext);
    function Provider(props) {
        const { children: children , ...context } = props; // Only re-memoize when prop values change
        // eslint-disable-next-line react-hooks/exhaustive-deps
        const value = useMemo(()=>context
        , Object.values(context));
        return /*#__PURE__*/ createElement(Context.Provider, {
            value: value
        }, children);
    }
    function useContext$1(consumerName) {
        const context = useContext(Context);
        if (context) return context;
        if (defaultContext !== undefined) return defaultContext; // if a defaultContext wasn't specified, it's a required context.
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + 'Provider';
    return [
        Provider,
        useContext$1
    ];
}
/* -------------------------------------------------------------------------------------------------
 * createContextScope
 * -----------------------------------------------------------------------------------------------*/ function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    /* -----------------------------------------------------------------------------------------------
   * createContext
   * ---------------------------------------------------------------------------------------------*/ function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
        const BaseContext = /*#__PURE__*/ createContext(defaultContext);
        const index = defaultContexts.length;
        defaultContexts = [
            ...defaultContexts,
            defaultContext
        ];
        function Provider(props) {
            const { scope: scope , children: children , ...context } = props;
            const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index]) || BaseContext; // Only re-memoize when prop values change
            // eslint-disable-next-line react-hooks/exhaustive-deps
            const value = useMemo(()=>context
            , Object.values(context));
            return /*#__PURE__*/ createElement(Context.Provider, {
                value: value
            }, children);
        }
        function useContext$1(consumerName, scope) {
            const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index]) || BaseContext;
            const context = useContext(Context);
            if (context) return context;
            if (defaultContext !== undefined) return defaultContext; // if a defaultContext wasn't specified, it's a required context.
            throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
        }
        Provider.displayName = rootComponentName + 'Provider';
        return [
            Provider,
            useContext$1
        ];
    }
    /* -----------------------------------------------------------------------------------------------
   * createScope
   * ---------------------------------------------------------------------------------------------*/ const createScope = ()=>{
        const scopeContexts = defaultContexts.map((defaultContext)=>{
            return /*#__PURE__*/ createContext(defaultContext);
        });
        return function useScope(scope) {
            const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
            return useMemo(()=>({
                    [`__scope${scopeName}`]: {
                        ...scope,
                        [scopeName]: contexts
                    }
                })
            , [
                scope,
                contexts
            ]);
        };
    };
    createScope.scopeName = scopeName;
    return [
        $c512c27ab02ef895$export$fd42f52fd3ae1109,
        $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
    ];
}
/* -------------------------------------------------------------------------------------------------
 * composeContextScopes
 * -----------------------------------------------------------------------------------------------*/ function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope1 = ()=>{
        const scopeHooks = scopes.map((createScope)=>({
                useScope: createScope(),
                scopeName: createScope.scopeName
            })
        );
        return function useComposedScopes(overrideScopes) {
            const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope: useScope , scopeName: scopeName  })=>{
                // We are calling a hook inside a callback which React warns against to avoid inconsistent
                // renders, however, scoping doesn't have render side effects so we ignore the rule.
                // eslint-disable-next-line react-hooks/rules-of-hooks
                const scopeProps = useScope(overrideScopes);
                const currentScope = scopeProps[`__scope${scopeName}`];
                return {
                    ...nextScopes,
                    ...currentScope
                };
            }, {});
            return useMemo(()=>({
                    [`__scope${baseScope.scopeName}`]: nextScopes1
                })
            , [
                nextScopes1
            ]);
        };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
}

/**
 * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a
 * prop or avoid re-executing effects when passed as a dependency
 */ function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
    const callbackRef = useRef(callback);
    useEffect$1(()=>{
        callbackRef.current = callback;
    }); // https://github.com/facebook/react/issues/19240
    return useMemo(()=>(...args)=>{
            var _callbackRef$current;
            return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
        }
    , []);
}

/**
 * On the server, React emits a warning when calling `useLayoutEffect`.
 * This is because neither `useLayoutEffect` nor `useEffect` run on the server.
 * We use this safe version which suppresses the warning by replacing it with a noop on the server.
 *
 * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect
 */ const $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? useLayoutEffect$1 : ()=>{};

/**
 * Set a given ref to a given value
 * This utility takes care of different types of refs: callback refs and RefObject(s)
 */ function $6ed0406888f73fc4$var$setRef(ref, value) {
    if (typeof ref === 'function') ref(value);
    else if (ref !== null && ref !== undefined) ref.current = value;
}
/**
 * A utility to compose multiple refs together
 * Accepts callback refs and RefObject(s)
 */ function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
    return (node)=>refs.forEach((ref)=>$6ed0406888f73fc4$var$setRef(ref, node)
        )
    ;
}
/**
 * A custom hook that composes multiple refs
 * Accepts callback refs and RefObject(s)
 */ function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    return useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}

/* -------------------------------------------------------------------------------------------------
 * Slot
 * -----------------------------------------------------------------------------------------------*/ const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { children: children , ...slotProps } = props;
    const childrenArray = Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
    if (slottable) {
        // the new element to render is the one passed as a child of `Slottable`
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map((child)=>{
            if (child === slottable) {
                // because the new element will be the one rendered, we are only interested
                // in grabbing its children (`newElement.props.children`)
                if (Children.count(newElement) > 1) return Children.only(null);
                return /*#__PURE__*/ isValidElement(newElement) ? newElement.props.children : null;
            } else return child;
        });
        return /*#__PURE__*/ createElement($5e63c961fc1ce211$var$SlotClone, _extends$2({}, slotProps, {
            ref: forwardedRef
        }), /*#__PURE__*/ isValidElement(newElement) ? /*#__PURE__*/ cloneElement(newElement, undefined, newChildren) : null);
    }
    return /*#__PURE__*/ createElement($5e63c961fc1ce211$var$SlotClone, _extends$2({}, slotProps, {
        ref: forwardedRef
    }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = 'Slot';
/* -------------------------------------------------------------------------------------------------
 * SlotClone
 * -----------------------------------------------------------------------------------------------*/ const $5e63c961fc1ce211$var$SlotClone = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { children: children , ...slotProps } = props;
    if (/*#__PURE__*/ isValidElement(children)) return /*#__PURE__*/ cloneElement(children, {
        ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
        ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)
    });
    return Children.count(children) > 1 ? Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = 'SlotClone';
/* -------------------------------------------------------------------------------------------------
 * Slottable
 * -----------------------------------------------------------------------------------------------*/ const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children: children  })=>{
    return /*#__PURE__*/ createElement(Fragment$1, null, children);
};
/* ---------------------------------------------------------------------------------------------- */ function $5e63c961fc1ce211$var$isSlottable(child) {
    return /*#__PURE__*/ isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
    // all child props should override
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName); // if it's a handler, modify the override by composing the base handler
        if (isHandler) overrideProps[propName] = (...args)=>{
            childPropValue === null || childPropValue === void 0 || childPropValue(...args);
            slotPropValue === null || slotPropValue === void 0 || slotPropValue(...args);
        };
        else if (propName === 'style') overrideProps[propName] = {
            ...slotPropValue,
            ...childPropValue
        };
        else if (propName === 'className') overrideProps[propName] = [
            slotPropValue,
            childPropValue
        ].filter(Boolean).join(' ');
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}

const $8927f6f2acc4f386$var$NODES = [
    'a',
    'button',
    'div',
    'h2',
    'h3',
    'img',
    'li',
    'nav',
    'ol',
    'p',
    'span',
    'svg',
    'ul'
]; // Temporary while we await merge of this fix:
// https://github.com/DefinitelyTyped/DefinitelyTyped/pull/55396
// prettier-ignore
/* -------------------------------------------------------------------------------------------------
 * Primitive
 * -----------------------------------------------------------------------------------------------*/ const $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node)=>{
    const Node = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
        const { asChild: asChild , ...primitiveProps } = props;
        const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
        useEffect$1(()=>{
            window[Symbol.for('radix-ui')] = true;
        }, []);
        return /*#__PURE__*/ createElement(Comp, _extends$2({}, primitiveProps, {
            ref: forwardedRef
        }));
    });
    Node.displayName = `Primitive.${node}`;
    return {
        ...primitive,
        [node]: Node
    };
}, {});
/* -------------------------------------------------------------------------------------------------
 * Utils
 * -----------------------------------------------------------------------------------------------*/ /**
 * Flush custom event dispatch
 * https://github.com/radix-ui/primitives/pull/1378
 *
 * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.
 *
 * Internally, React prioritises events in the following order:
 *  - discrete
 *  - continuous
 *  - default
 *
 * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350
 *
 * `discrete` is an  important distinction as updates within these events are applied immediately.
 * React however, is not able to infer the priority of custom event types due to how they are detected internally.
 * Because of this, it's possible for updates from custom events to be unexpectedly batched when
 * dispatched by another `discrete` event.
 *
 * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.
 * This utility should be used when dispatching a custom event from within another `discrete` event, this utility
 * is not nessesary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.
 * For example:
 *
 * dispatching a known click ðŸ‘Ž
 * target.dispatchEvent(new Event(â€˜clickâ€™))
 *
 * dispatching a custom type within a non-discrete event ðŸ‘Ž
 * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(â€˜customTypeâ€™))}
 *
 * dispatching a custom type within a `discrete` event ðŸ‘
 * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(â€˜customTypeâ€™))}
 *
 * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use
 * this utility with them. This is because it's possible for those handlers to be called implicitly during render
 * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.
 */ function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
    if (target) flushSync(()=>target.dispatchEvent(event)
    );
}

/* -------------------------------------------------------------------------------------------------
 * Avatar
 * -----------------------------------------------------------------------------------------------*/ const $cddcb0b647441e34$var$AVATAR_NAME = 'Avatar';
const [$cddcb0b647441e34$var$createAvatarContext, $cddcb0b647441e34$export$90370d16b488820f] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cddcb0b647441e34$var$AVATAR_NAME);
const [$cddcb0b647441e34$var$AvatarProvider, $cddcb0b647441e34$var$useAvatarContext] = $cddcb0b647441e34$var$createAvatarContext($cddcb0b647441e34$var$AVATAR_NAME);
const $cddcb0b647441e34$export$e2255cf6045e8d47 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeAvatar: __scopeAvatar , ...avatarProps } = props;
    const [imageLoadingStatus, setImageLoadingStatus] = useState$1('idle');
    return /*#__PURE__*/ createElement($cddcb0b647441e34$var$AvatarProvider, {
        scope: __scopeAvatar,
        imageLoadingStatus: imageLoadingStatus,
        onImageLoadingStatusChange: setImageLoadingStatus
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({}, avatarProps, {
        ref: forwardedRef
    })));
});
/* -------------------------------------------------------------------------------------------------
 * AvatarImage
 * -----------------------------------------------------------------------------------------------*/ const $cddcb0b647441e34$var$IMAGE_NAME = 'AvatarImage';
const $cddcb0b647441e34$export$2cd8ae1985206fe8 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeAvatar: __scopeAvatar , src: src , onLoadingStatusChange: onLoadingStatusChange = ()=>{} , ...imageProps } = props;
    const context = $cddcb0b647441e34$var$useAvatarContext($cddcb0b647441e34$var$IMAGE_NAME, __scopeAvatar);
    const imageLoadingStatus = $cddcb0b647441e34$var$useImageLoadingStatus(src);
    const handleLoadingStatusChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a((status)=>{
        onLoadingStatusChange(status);
        context.onImageLoadingStatusChange(status);
    });
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        if (imageLoadingStatus !== 'idle') handleLoadingStatusChange(imageLoadingStatus);
    }, [
        imageLoadingStatus,
        handleLoadingStatusChange
    ]);
    return imageLoadingStatus === 'loaded' ? /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.img, _extends$2({}, imageProps, {
        ref: forwardedRef,
        src: src
    })) : null;
});
/* -------------------------------------------------------------------------------------------------
 * AvatarFallback
 * -----------------------------------------------------------------------------------------------*/ const $cddcb0b647441e34$var$FALLBACK_NAME = 'AvatarFallback';
const $cddcb0b647441e34$export$69fffb6a9571fbfe = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeAvatar: __scopeAvatar , delayMs: delayMs , ...fallbackProps } = props;
    const context = $cddcb0b647441e34$var$useAvatarContext($cddcb0b647441e34$var$FALLBACK_NAME, __scopeAvatar);
    const [canRender, setCanRender] = useState$1(delayMs === undefined);
    useEffect$1(()=>{
        if (delayMs !== undefined) {
            const timerId = window.setTimeout(()=>setCanRender(true)
            , delayMs);
            return ()=>window.clearTimeout(timerId)
            ;
        }
    }, [
        delayMs
    ]);
    return canRender && context.imageLoadingStatus !== 'loaded' ? /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({}, fallbackProps, {
        ref: forwardedRef
    })) : null;
});
/* -----------------------------------------------------------------------------------------------*/ function $cddcb0b647441e34$var$useImageLoadingStatus(src) {
    const [loadingStatus, setLoadingStatus] = useState$1('idle');
    useEffect$1(()=>{
        if (!src) {
            setLoadingStatus('error');
            return;
        }
        let isMounted = true;
        const image = new window.Image();
        const updateStatus = (status)=>()=>{
                if (!isMounted) return;
                setLoadingStatus(status);
            }
        ;
        setLoadingStatus('loading');
        image.onload = updateStatus('loaded');
        image.onerror = updateStatus('error');
        image.src = src;
        return ()=>{
            isMounted = false;
        };
    }, [
        src
    ]);
    return loadingStatus;
}
const $cddcb0b647441e34$export$be92b6f5f03c0fe9 = $cddcb0b647441e34$export$e2255cf6045e8d47;
const $cddcb0b647441e34$export$3e431a229df88919 = $cddcb0b647441e34$export$2cd8ae1985206fe8;
const $cddcb0b647441e34$export$fb8d7f40caaeea67 = $cddcb0b647441e34$export$69fffb6a9571fbfe;

const sizes = {
  sm: "3rem",
  md: "4rem",
  lg: "5rem",
  xl: "6rem"
};
const handleSizing = (size) => sizes[size] ? sizes[size] : size;
const AvatarBase = styled($cddcb0b647441e34$export$be92b6f5f03c0fe9)`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle;
  overflow: hidden;
  user-select: none;
  border-radius: 100%;
  width: ${({ size }) => handleSizing(size)};
  height: ${({ size }) => handleSizing(size)};
`;
const AvatarFallback = styled($cddcb0b647441e34$export$fb8d7f40caaeea67)`
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: ${slate$1.slate9};
`;
const AvatarImage = styled($cddcb0b647441e34$export$3e431a229df88919)`
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: inherit;
`;

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production_min = {};

/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f=React__default,k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};
function q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;

{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}

const jsx = jsxRuntime.exports.jsx;
const jsxs = jsxRuntime.exports.jsxs;
const Fragment = jsxRuntime.exports.Fragment;

const Avatar = ({
  src,
  size = "sm",
  alt = "Picture of an Avatar",
  delayMs = 500,
  fallback = "X",
  className
}) => {
  return /* @__PURE__ */ jsxs(AvatarBase, {
    size,
    className,
    children: [/* @__PURE__ */ jsx(AvatarImage, {
      src,
      alt
    }), /* @__PURE__ */ jsx(AvatarFallback, {
      delayMs: src ? delayMs : 0,
      children: fallback
    })]
  });
};

var classnames = {exports: {}};

/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/

(function (module) {
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
					classes.push(arg.toString());
					continue;
				}

				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
}(classnames));

var classNames = classnames.exports;

const font = {
  family: {
    body: `'Mulish', sans-serif`,
    data: `'Space Mono', monospace`
  },
  size: {
    xs: "1.2rem",
    sm: "1.4rem",
    md: "1.6rem",
    lg: "2rem",
    xl: "2.4rem",
    xxl: "3.2rem",
    xxxl: "4rem",
    xxxxl: "4.8rem"
  },
  weight: {
    extraLight: 200,
    light: 300,
    reg: 400,
    med: 500,
    bold: 700,
    black: 900
  },
  lineHeight: "150%",
  letterSpacing: "1.5px"
};

const ButtonBase = styled.button`
  align-items: center;
  background-color: ${({ theme }) => theme.button.primary.bg};
  border: 0.1rem solid
    ${({ theme }) => theme.button.primary.border};
  border-radius: 0.4rem;
  color: ${({ theme }) => theme.button.primary.text};
  cursor: pointer;
  display: flex;
  font-size: ${font.size.md};
  font-weight: ${font.weight.bold};
  height: 4.8rem;
  justify-content: left;
  letter-spacing: 1.8px;
  padding: 1.2rem;
  transition: 0.2s all;
  width: ${(props) => props.width};

  svg {
    width: 2.2rem;
    height: 2.2rem;
  }

  svg.icon-left {
    margin-right: 1rem;
  }

  svg.icon-right {
    margin-left: 0.5rem;
  }

  :hover {
    background-color: ${({ theme }) => theme.button.primary.hoverBg};
    border: 0.1rem solid
      ${({ theme }) => theme.button.primary.hoverBorder};
  }

  :focus {
    background-color: ${({ theme }) => theme.button.primary.focusBg};
    border: 0.1rem solid
      ${({ theme }) => theme.button.primary.focusBorder};
  }

  :disabled {
    background-color: ${({ theme }) => theme.button.primary.disabledBg};
    border: 0.1rem solid
      ${({ theme }) => theme.button.primary.disabledBorder};
    cursor: not-allowed;
  }

  &.secondary {
    background-color: ${({ theme }) => theme.button.secondary.bg};
    border: 0.1rem solid
      ${({ theme }) => theme.button.secondary.bg};
    color: ${({ theme }) => theme.button.secondary.text};

    :hover {
      background-color: ${({ theme }) => theme.button.secondary.hoverBg};
      border: 0.1rem solid
        ${({ theme }) => theme.button.secondary.hoverBorder};
    }

    :focus {
      background-color: ${({ theme }) => theme.button.secondary.focusBg};
      border: 0.1rem solid
        ${({ theme }) => theme.button.secondary.focusBorder};
    }

    :disabled {
      background-color: ${({ theme }) => theme.button.secondary.disabledBg};
      border: 0.1rem solid
        ${({ theme }) => theme.button.secondary.disabledBorder};
      cursor: not-allowed;
    }
  }

  &.tertiary {
    background-color: ${({ theme }) => theme.button.tertiary.bg};
    border: 0.1rem solid
      ${({ theme }) => theme.button.tertiary.border};
    color: ${({ theme }) => theme.button.tertiary.text};

    :hover {
      border: 0.1rem solid
        ${({ theme }) => theme.button.tertiary.hoverBorder};
      color: ${({ theme }) => theme.button.tertiary.hoverText};
    }

    :focus {
      border: 0.1rem solid
        ${({ theme }) => theme.button.tertiary.focusBorder};
      color: ${({ theme }) => theme.button.tertiary.focusText};
    }

    :disabled {
      border: 0.1rem solid
        ${({ theme }) => theme.button.tertiary.disabledBorder};
      color: ${({ theme }) => theme.button.tertiary.disabledText};
      cursor: not-allowed;
    }
  }

  &.sm {
    font-size: ${font.size.xs};
    height: 3.6rem;
    padding: 0.9rem;
  }

  &.lg {
    font-size: ${font.size.lg};
    height: 6rem;
    padding: 1.5rem;
  }

  &.full-width {
    min-width: 100%;
  }

  &.left-align {
    justify-content: flex-start;
  }
  &.center-align {
    justify-content: center;
  }

  &.avatar {
    padding: 0 0.6rem;
  }
`;

const Button = React__default.forwardRef((props, ref) => {
  const {
    primary,
    secondary,
    sm,
    lg,
    tertiary,
    children,
    fullWidth,
    centerAlign,
    leftAlign,
    avatar,
    className,
    IconLeft,
    IconRight,
    type,
    value
  } = props;
  const classes = classNames({
    secondary,
    sm,
    lg,
    tertiary,
    avatar,
    "left-align": leftAlign,
    "full-width": fullWidth,
    "center-align": centerAlign
  });
  const iconClasses = classNames({
    secondary,
    primary,
    tertiary,
    sm,
    lg
  });
  return /* @__PURE__ */ jsxs(ButtonBase, {
    ...props,
    className: `${classes} ${className}`,
    ref,
    type,
    value,
    children: [IconLeft && /* @__PURE__ */ jsx(IconLeft, {
      className: `${iconClasses} icon-left`
    }), children, IconRight && /* @__PURE__ */ jsx(IconRight, {
      className: `${iconClasses} icon-right`
    })]
  });
});

var DefaultContext = {
  color: undefined,
  size: undefined,
  className: undefined,
  style: undefined,
  attr: undefined
};
var IconContext = React__default.createContext && React__default.createContext(DefaultContext);

var __assign$1 = globalThis && globalThis.__assign || function () {
  __assign$1 = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$1.apply(this, arguments);
};

var __rest$1 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

function Tree2Element(tree) {
  return tree && tree.map(function (node, i) {
    return React__default.createElement(node.tag, __assign$1({
      key: i
    }, node.attr), Tree2Element(node.child));
  });
}

function GenIcon(data) {
  return function (props) {
    return React__default.createElement(IconBase, __assign$1({
      attr: __assign$1({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function (conf) {
    var attr = props.attr,
        size = props.size,
        title = props.title,
        svgProps = __rest$1(props, ["attr", "size", "title"]);

    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + ' ' : '') + props.className;
    return React__default.createElement("svg", __assign$1({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className: className,
      style: __assign$1(__assign$1({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && React__default.createElement("title", null, title), props.children);
  };

  return IconContext !== undefined ? React__default.createElement(IconContext.Consumer, null, function (conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}

// THIS FILE IS AUTO GENERATED
function RiToolsLine (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M5.33 3.271a3.5 3.5 0 0 1 4.254 4.963l10.709 10.71-1.414 1.414-10.71-10.71a3.502 3.502 0 0 1-4.962-4.255L5.444 7.63a1.5 1.5 0 1 0 2.121-2.121L5.329 3.27zm10.367 1.884l3.182-1.768 1.414 1.414-1.768 3.182-1.768.354-2.12 2.121-1.415-1.414 2.121-2.121.354-1.768zm-6.718 8.132l1.414 1.414-5.303 5.303a1 1 0 0 1-1.492-1.327l.078-.087 5.303-5.303z"}}]}]})(props);
}function RiFileCopyLine (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M7 6V3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1h-3v3c0 .552-.45 1-1.007 1H4.007A1.001 1.001 0 0 1 3 21l.003-14c0-.552.45-1 1.007-1H7zM5.003 8L5 20h10V8H5.003zM9 6h8v10h2V4H9v2z"}}]}]})(props);
}function RiAsterisk (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M13 3v7.267l6.294-3.633 1 1.732-6.293 3.633 6.293 3.635-1 1.732L13 13.732V21h-2v-7.268l-6.294 3.634-1-1.732L9.999 12 3.706 8.366l1-1.732L11 10.267V3z"}}]}]})(props);
}function RiDiscordFill (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"fillRule":"nonzero","d":"M10.076 11c.6 0 1.086.45 1.075 1 0 .55-.474 1-1.075 1C9.486 13 9 12.55 9 12s.475-1 1.076-1zm3.848 0c.601 0 1.076.45 1.076 1s-.475 1-1.076 1c-.59 0-1.075-.45-1.075-1s.474-1 1.075-1zm4.967-9C20.054 2 21 2.966 21 4.163V23l-2.211-1.995-1.245-1.176-1.317-1.25.546 1.943H5.109C3.946 20.522 3 19.556 3 18.359V4.163C3 2.966 3.946 2 5.109 2H18.89zm-3.97 13.713c2.273-.073 3.148-1.596 3.148-1.596 0-3.381-1.482-6.122-1.482-6.122-1.48-1.133-2.89-1.102-2.89-1.102l-.144.168c1.749.546 2.561 1.334 2.561 1.334a8.263 8.263 0 0 0-3.096-1.008 8.527 8.527 0 0 0-2.077.02c-.062 0-.114.011-.175.021-.36.032-1.235.168-2.335.662-.38.178-.607.305-.607.305s.854-.83 2.705-1.376l-.103-.126s-1.409-.031-2.89 1.103c0 0-1.481 2.74-1.481 6.121 0 0 .864 1.522 3.137 1.596 0 0 .38-.472.69-.871-1.307-.4-1.8-1.24-1.8-1.24s.102.074.287.179c.01.01.02.021.041.031.031.022.062.032.093.053.257.147.514.262.75.357.422.168.926.336 1.513.452a7.06 7.06 0 0 0 2.664.01 6.666 6.666 0 0 0 1.491-.451c.36-.137.761-.337 1.183-.62 0 0-.514.861-1.862 1.25.309.399.68.85.68.85z"}}]}]})(props);
}function RiArrowDropDownLine (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M12 15l-4.243-4.243 1.415-1.414L12 12.172l2.828-2.829 1.415 1.414z"}}]}]})(props);
}function RiCheckLine (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M10 15.172l9.192-9.193 1.415 1.414L10 18l-6.364-6.364 1.414-1.414z"}}]}]})(props);
}function RiCheckboxCircleFill (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm-.997-6l7.07-7.071-1.414-1.414-5.656 5.657-2.829-2.829-1.414 1.414L11.003 16z"}}]}]})(props);
}function RiCheckboxCircleLine (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm-.997-4L6.76 11.757l1.414-1.414 2.829 2.829 5.656-5.657 1.415 1.414L11.003 16z"}}]}]})(props);
}function RiCloseCircleFill (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-11.414L9.172 7.757 7.757 9.172 10.586 12l-2.829 2.828 1.415 1.415L12 13.414l2.828 2.829 1.415-1.415L13.414 12l2.829-2.828-1.415-1.415L12 10.586z"}}]}]})(props);
}function RiCloseFill (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"}}]}]})(props);
}function RiErrorWarningFill (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm-1-7v2h2v-2h-2zm0-8v6h2V7h-2z"}}]}]})(props);
}function RiErrorWarningLine (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm-1-5h2v2h-2v-2zm0-8h2v6h-2V7z"}}]}]})(props);
}function RiExternalLinkLine (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M10 6v2H5v11h11v-5h2v6a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm11-3v8h-2V6.413l-7.793 7.794-1.414-1.414L17.585 5H13V3h8z"}}]}]})(props);
}function RiMenuLine (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24"},"child":[{"tag":"g","attr":{},"child":[{"tag":"path","attr":{"fill":"none","d":"M0 0h24v24H0z"}},{"tag":"path","attr":{"d":"M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"}}]}]})(props);
}

const StyledLabel$1 = styled.label`
  font-family: ${font.family.body};
  font-weight: ${font.weight.reg};
  font-size: ${font.size.md};
  color: ${(props) => props.color};
`;

const Label$1 = ({
  children = "label",
  id
}) => {
  return /* @__PURE__ */ jsx(StyledLabel$1, {
    htmlFor: id,
    children
  });
};

const $ea1ef594cf570d83$export$439d29a4e110a164 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({}, props, {
        ref: forwardedRef,
        style: {
            // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
            position: 'absolute',
            border: 0,
            width: 1,
            height: 1,
            padding: 0,
            margin: -1,
            overflow: 'hidden',
            clip: 'rect(0, 0, 0, 0)',
            whiteSpace: 'nowrap',
            wordWrap: 'normal',
            ...props.style
        }
    }));
});
/* -----------------------------------------------------------------------------------------------*/ const $ea1ef594cf570d83$export$be92b6f5f03c0fe9 = $ea1ef594cf570d83$export$439d29a4e110a164;

const $08b6689415b2f49a$export$5aec92af04ace2d2 = ({ children: children , label: label  })=>{
    const child = Children.only(children);
    return /*#__PURE__*/ createElement(Fragment$1, null, /*#__PURE__*/ cloneElement(child, {
        // accessibility
        'aria-hidden': 'true',
        focusable: 'false' // See: https://allyjs.io/tutorials/focusing-in-svg.html#making-svg-elements-focusable
    }), /*#__PURE__*/ createElement($ea1ef594cf570d83$export$be92b6f5f03c0fe9, null, label));
};
const $08b6689415b2f49a$export$be92b6f5f03c0fe9 = $08b6689415b2f49a$export$5aec92af04ace2d2;

const Icon = ({
  label = "",
  children
}) => {
  return /* @__PURE__ */ jsx($08b6689415b2f49a$export$be92b6f5f03c0fe9, {
    label,
    children
  });
};

function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented: checkForDefaultPrevented = true  } = {}) {
    return function handleEvent(event) {
        originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
        if (checkForDefaultPrevented === false || !event.defaultPrevented) return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
}

function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop: prop , defaultProp: defaultProp , onChange: onChange = ()=>{}  }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
        defaultProp: defaultProp,
        onChange: onChange
    });
    const isControlled = prop !== undefined;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
    const setValue = useCallback((nextValue)=>{
        if (isControlled) {
            const setter = nextValue;
            const value = typeof nextValue === 'function' ? setter(prop) : nextValue;
            if (value !== prop) handleChange(value);
        } else setUncontrolledProp(nextValue);
    }, [
        isControlled,
        prop,
        setUncontrolledProp,
        handleChange
    ]);
    return [
        value1,
        setValue
    ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp: defaultProp , onChange: onChange  }) {
    const uncontrolledState = useState$1(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = useRef(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
    useEffect$1(()=>{
        if (prevValueRef.current !== value) {
            handleChange(value);
            prevValueRef.current = value;
        }
    }, [
        value,
        prevValueRef,
        handleChange
    ]);
    return uncontrolledState;
}

function $010c2913dbd2fe3d$export$5cae361ad82dce8b(value) {
    const ref = useRef({
        value: value,
        previous: value
    }); // We compare values before making an update to ensure that
    // a change has been made. This ensures the previous value is
    // persisted correctly between renders.
    return useMemo(()=>{
        if (ref.current.value !== value) {
            ref.current.previous = ref.current.value;
            ref.current.value = value;
        }
        return ref.current.previous;
    }, [
        value
    ]);
}

function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
    const [size, setSize] = useState$1(undefined);
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        if (element) {
            // provide size as early as possible
            setSize({
                width: element.offsetWidth,
                height: element.offsetHeight
            });
            const resizeObserver = new ResizeObserver((entries)=>{
                if (!Array.isArray(entries)) return;
                 // Since we only observe the one element, we don't need to loop over the
                // array
                if (!entries.length) return;
                const entry = entries[0];
                let width;
                let height;
                if ('borderBoxSize' in entry) {
                    const borderSizeEntry = entry['borderBoxSize']; // iron out differences between browsers
                    const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
                    width = borderSize['inlineSize'];
                    height = borderSize['blockSize'];
                } else {
                    // for browsers that don't support `borderBoxSize`
                    // we calculate it ourselves to get the correct border box.
                    width = element.offsetWidth;
                    height = element.offsetHeight;
                }
                setSize({
                    width: width,
                    height: height
                });
            });
            resizeObserver.observe(element, {
                box: 'border-box'
            });
            return ()=>resizeObserver.unobserve(element)
            ;
        } else // We only want to reset to `undefined` when the element becomes `null`,
        // not if it changes to another element.
        setSize(undefined);
    }, [
        element
    ]);
    return size;
}

const $1746a345f3d73bb7$var$useReactId = React['useId'.toString()] || (()=>undefined
);
let $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
    const [id, setId] = React.useState($1746a345f3d73bb7$var$useReactId()); // React versions older than 18 will have client-side ids only.
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        if (!deterministicId) setId((reactId)=>reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
        );
    }, [
        deterministicId
    ]);
    return deterministicId || (id ? `radix-${id}` : '');
}

/* -------------------------------------------------------------------------------------------------
 * Label
 * -----------------------------------------------------------------------------------------------*/ const $b73a6c6685e72184$var$NAME = 'Label';
const [$b73a6c6685e72184$var$LabelProvider, $b73a6c6685e72184$var$useLabelContextImpl] = $c512c27ab02ef895$export$fd42f52fd3ae1109($b73a6c6685e72184$var$NAME, {
    id: undefined,
    controlRef: {
        current: null
    }
});
/* -----------------------------------------------------------------------------------------------*/ const $b73a6c6685e72184$export$feddbbf47baabdb9 = (element)=>{
    const context = $b73a6c6685e72184$var$useLabelContextImpl('LabelConsumer');
    const { controlRef: controlRef  } = context;
    useEffect$1(()=>{
        if (element) controlRef.current = element;
    }, [
        element,
        controlRef
    ]);
    return context.id;
};

function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
    return useReducer((state, event)=>{
        const nextState = machine[state][event];
        return nextState !== null && nextState !== void 0 ? nextState : state;
    }, initialState);
}


const $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props)=>{
    const { present: present , children: children  } = props;
    const presence = $921a889cee6df7e8$var$usePresence(present);
    const child = typeof children === 'function' ? children({
        present: presence.isPresent
    }) : Children.only(children);
    const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
    const forceMount = typeof children === 'function';
    return forceMount || presence.isPresent ? /*#__PURE__*/ cloneElement(child, {
        ref: ref
    }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = 'Presence';
/* -------------------------------------------------------------------------------------------------
 * usePresence
 * -----------------------------------------------------------------------------------------------*/ function $921a889cee6df7e8$var$usePresence(present) {
    const [node1, setNode] = useState$1();
    const stylesRef = useRef({});
    const prevPresentRef = useRef(present);
    const prevAnimationNameRef = useRef('none');
    const initialState = present ? 'mounted' : 'unmounted';
    const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
        mounted: {
            UNMOUNT: 'unmounted',
            ANIMATION_OUT: 'unmountSuspended'
        },
        unmountSuspended: {
            MOUNT: 'mounted',
            ANIMATION_END: 'unmounted'
        },
        unmounted: {
            MOUNT: 'mounted'
        }
    });
    useEffect$1(()=>{
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';
    }, [
        state
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        const styles = stylesRef.current;
        const wasPresent = prevPresentRef.current;
        const hasPresentChanged = wasPresent !== present;
        if (hasPresentChanged) {
            const prevAnimationName = prevAnimationNameRef.current;
            const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
            if (present) send('MOUNT');
            else if (currentAnimationName === 'none' || (styles === null || styles === void 0 ? void 0 : styles.display) === 'none') // If there is no exit animation or the element is hidden, animations won't run
            // so we unmount instantly
            send('UNMOUNT');
            else {
                /**
         * When `present` changes to `false`, we check changes to animation-name to
         * determine whether an animation has started. We chose this approach (reading
         * computed styles) because there is no `animationrun` event and `animationstart`
         * fires after `animation-delay` has expired which would be too late.
         */ const isAnimating = prevAnimationName !== currentAnimationName;
                if (wasPresent && isAnimating) send('ANIMATION_OUT');
                else send('UNMOUNT');
            }
            prevPresentRef.current = present;
        }
    }, [
        present,
        send
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        if (node1) {
            /**
       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`
       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we
       * make sure we only trigger ANIMATION_END for the currently active animation.
       */ const handleAnimationEnd = (event)=>{
                const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
                const isCurrentAnimation = currentAnimationName.includes(event.animationName);
                if (event.target === node1 && isCurrentAnimation) // With React 18 concurrency this update is applied
                // a frame after the animation ends, creating a flash of visible content.
                // By manually flushing we ensure they sync within a frame, removing the flash.
                flushSync(()=>send('ANIMATION_END')
                );
            };
            const handleAnimationStart = (event)=>{
                if (event.target === node1) // if animation occurred, store its name as the previous animation.
                prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
            };
            node1.addEventListener('animationstart', handleAnimationStart);
            node1.addEventListener('animationcancel', handleAnimationEnd);
            node1.addEventListener('animationend', handleAnimationEnd);
            return ()=>{
                node1.removeEventListener('animationstart', handleAnimationStart);
                node1.removeEventListener('animationcancel', handleAnimationEnd);
                node1.removeEventListener('animationend', handleAnimationEnd);
            };
        } else // Transition to the unmounted state if the node is removed prematurely.
        // We avoid doing so during cleanup as the node may change but still exist.
        send('ANIMATION_END');
    }, [
        node1,
        send
    ]);
    return {
        isPresent: [
            'mounted',
            'unmountSuspended'
        ].includes(state),
        ref: useCallback((node)=>{
            if (node) stylesRef.current = getComputedStyle(node);
            setNode(node);
        }, [])
    };
}
/* -----------------------------------------------------------------------------------------------*/ function $921a889cee6df7e8$var$getAnimationName(styles) {
    return (styles === null || styles === void 0 ? void 0 : styles.animationName) || 'none';
}

/* -------------------------------------------------------------------------------------------------
 * Checkbox
 * -----------------------------------------------------------------------------------------------*/ const $e698a72e93240346$var$CHECKBOX_NAME = 'Checkbox';
const [$e698a72e93240346$var$createCheckboxContext, $e698a72e93240346$export$b566c4ff5488ea01] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($e698a72e93240346$var$CHECKBOX_NAME);
const [$e698a72e93240346$var$CheckboxProvider, $e698a72e93240346$var$useCheckboxContext] = $e698a72e93240346$var$createCheckboxContext($e698a72e93240346$var$CHECKBOX_NAME);
const $e698a72e93240346$export$48513f6b9f8ce62d = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeCheckbox: __scopeCheckbox , 'aria-labelledby': ariaLabelledby , name: name , checked: checkedProp , defaultChecked: defaultChecked , required: required , disabled: disabled , value: value = 'on' , onCheckedChange: onCheckedChange , ...checkboxProps } = props;
    const [button, setButton] = useState$1(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node)=>setButton(node)
    );
    const labelId = $b73a6c6685e72184$export$feddbbf47baabdb9(button);
    const labelledBy = ariaLabelledby || labelId;
    const hasConsumerStoppedPropagationRef = useRef(false); // We set this to true by default so that events bubble to forms without JS (SSR)
    const isFormControl = button ? Boolean(button.closest('form')) : true;
    const [checked = false, setChecked] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: checkedProp,
        defaultProp: defaultChecked,
        onChange: onCheckedChange
    });
    return /*#__PURE__*/ createElement($e698a72e93240346$var$CheckboxProvider, {
        scope: __scopeCheckbox,
        state: checked,
        disabled: disabled
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
        type: "button",
        role: "checkbox",
        "aria-checked": $e698a72e93240346$var$isIndeterminate(checked) ? 'mixed' : checked,
        "aria-labelledby": labelledBy,
        "aria-required": required,
        "data-state": $e698a72e93240346$var$getState(checked),
        "data-disabled": disabled ? '' : undefined,
        disabled: disabled,
        value: value
    }, checkboxProps, {
        ref: composedRefs,
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event)=>{
            // According to WAI ARIA, Checkboxes don't activate on enter keypress
            if (event.key === 'Enter') event.preventDefault();
        }),
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, (event)=>{
            setChecked((prevChecked)=>$e698a72e93240346$var$isIndeterminate(prevChecked) ? true : !prevChecked
            );
            if (isFormControl) {
                hasConsumerStoppedPropagationRef.current = event.isPropagationStopped(); // if checkbox is in a form, stop propagation from the button so that we only propagate
                // one click event (from the input). We propagate changes from an input so that native
                // form validation works and form events reflect checkbox updates.
                if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
        })
    })), isFormControl && /*#__PURE__*/ createElement($e698a72e93240346$var$BubbleInput, {
        control: button,
        bubbles: !hasConsumerStoppedPropagationRef.current,
        name: name,
        value: value,
        checked: checked,
        required: required,
        disabled: disabled // We transform because the input is absolutely positioned but we have
        ,
        style: {
            transform: 'translateX(-100%)'
        }
    }));
});
/* -------------------------------------------------------------------------------------------------
 * CheckboxIndicator
 * -----------------------------------------------------------------------------------------------*/ const $e698a72e93240346$var$INDICATOR_NAME = 'CheckboxIndicator';
const $e698a72e93240346$export$59aad738f51d1c05 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeCheckbox: __scopeCheckbox , forceMount: forceMount , ...indicatorProps } = props;
    const context = $e698a72e93240346$var$useCheckboxContext($e698a72e93240346$var$INDICATOR_NAME, __scopeCheckbox);
    return /*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || $e698a72e93240346$var$isIndeterminate(context.state) || context.state === true
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({
        "data-state": $e698a72e93240346$var$getState(context.state),
        "data-disabled": context.disabled ? '' : undefined
    }, indicatorProps, {
        ref: forwardedRef,
        style: {
            pointerEvents: 'none',
            ...props.style
        }
    })));
});
/* ---------------------------------------------------------------------------------------------- */ const $e698a72e93240346$var$BubbleInput = (props)=>{
    const { control: control , checked: checked , bubbles: bubbles = true , ...inputProps } = props;
    const ref = useRef(null);
    const prevChecked = $010c2913dbd2fe3d$export$5cae361ad82dce8b(checked);
    const controlSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(control); // Bubble checked change to parents (e.g form change event)
    useEffect$1(()=>{
        const input = ref.current;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked');
        const setChecked = descriptor.set;
        if (prevChecked !== checked && setChecked) {
            const event = new Event('click', {
                bubbles: bubbles
            });
            input.indeterminate = $e698a72e93240346$var$isIndeterminate(checked);
            setChecked.call(input, $e698a72e93240346$var$isIndeterminate(checked) ? false : checked);
            input.dispatchEvent(event);
        }
    }, [
        prevChecked,
        checked,
        bubbles
    ]);
    return /*#__PURE__*/ createElement("input", _extends$2({
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: $e698a72e93240346$var$isIndeterminate(checked) ? false : checked
    }, inputProps, {
        tabIndex: -1,
        ref: ref,
        style: {
            ...props.style,
            ...controlSize,
            position: 'absolute',
            pointerEvents: 'none',
            opacity: 0,
            margin: 0
        }
    }));
};
function $e698a72e93240346$var$isIndeterminate(checked) {
    return checked === 'indeterminate';
}
function $e698a72e93240346$var$getState(checked) {
    return $e698a72e93240346$var$isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';
}
const $e698a72e93240346$export$be92b6f5f03c0fe9 = $e698a72e93240346$export$48513f6b9f8ce62d;
const $e698a72e93240346$export$adb584737d712b70 = $e698a72e93240346$export$59aad738f51d1c05;

const Container$3 = styled.div`
  align-items: center;
  display: flex;
  margin-bottom: 12px;
`;
const StyledCheckbox = styled($e698a72e93240346$export$be92b6f5f03c0fe9)`
  align-items: center;
  background-color: ${({ theme }) => theme.checkbox.bg};
  border: 2px solid ${({ theme }) => theme.checkbox.border};
  border-radius: 1px;
  cursor: pointer;
  display: flex;
  height: 18px;
  justify-content: center;
  width: 18px;

  :hover {
    background-color: ${({ theme }) => theme.checkbox.hoverBg};
    border: 2px solid
      ${({ theme }) => theme.checkbox.hoverBorder};
  }

  :focus {
    background-color: ${({ theme }) => theme.checkbox.focusBg};
    border: 2px solid
      ${({ theme }) => theme.checkbox.focusBorder};
    outline: none;
  }

  :disabled {
    background-color: ${({ theme }) => theme.checkbox.disabledBg};
    border: 2px solid
      ${({ theme }) => theme.checkbox.disabledBorder};
    cursor: not-allowed;
  }

  &[data-state='checked'] {
    background-color: ${({ theme }) => theme.checkbox.activeBg};
    border: 2px solid
      ${({ theme }) => theme.checkbox.activeBorder};

    :hover {
      background-color: ${({ theme }) => theme.checkbox.activeHoverBg};
      border: 2px solid
        ${({ theme }) => theme.checkbox.activeHoverBorder};
    }

    :focus {
      background-color: ${({ theme }) => theme.checkbox.activeFocusBg};
      border: 2px solid
        ${({ theme }) => theme.checkbox.activeFocusBorder};
      outline: none;
    }

    :disabled {
      background-color: ${({ theme }) => theme.checkbox.activeDisabledBg};
      border: 2px solid
        ${({ theme }) => theme.checkbox.activeDisabledBorder};
      cursor: not-allowed;
    }
  }
`;
const StyledIndicator = styled($e698a72e93240346$export$adb584737d712b70)`
  color: ${({ theme }) => theme.primary};
  font-size: 2rem;
  padding-top: 3px;
  :disabled {
    color: ${({ theme }) => theme.checkbox.disabledBg};
  }
`;
const LabelContainer$3 = styled.label`
  align-items: center;
  display: flex;
  margin-left: 1.2rem;
  label {
    margin-right: 0.1rem;
  }
  svg {
    transform: translateY(0.1rem);
  }
`;
const RequiredAsterisk$1 = styled.span`
  color: ${({ theme }) => theme.warning};
  font-weight: ${font.weight.bold};
  margin-right: 8px;
  transform: translateY(-0.25rem);
`;

const Checkbox = React__default.forwardRef((props, ref) => {
  const {
    id,
    title,
    disabled,
    required
  } = props;
  const classes = classNames({
    disabled
  });
  return /* @__PURE__ */ jsxs(Container$3, {
    children: [/* @__PURE__ */ jsx(StyledCheckbox, {
      ...props,
      ref,
      children: /* @__PURE__ */ jsx(StyledIndicator, {
        className: classes,
        children: /* @__PURE__ */ jsx(RiCheckLine, {})
      })
    }), /* @__PURE__ */ jsxs(LabelContainer$3, {
      children: [required && /* @__PURE__ */ jsx(RequiredAsterisk$1, {
        children: /* @__PURE__ */ jsx(Icon, {
          label: "Required",
          children: /* @__PURE__ */ jsx(RiAsterisk, {})
        })
      }), /* @__PURE__ */ jsx(Label$1, {
        id,
        children: title ? title : "No Title Found"
      })]
    })]
  });
});

const border = {
  radius: "0.4rem",
  cardRadius: "0.8rem"
};

/**
 * CSS to normalize abnormalities across browsers (normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css)
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *    ...normalize(),
 * }
 *
 * // styled-components usage
 * const GlobalStyle = createGlobalStyle`${normalize()}`
 *
 * // CSS as JS Output
 *
 * html {
 *   lineHeight: 1.15,
 *   textSizeAdjust: 100%,
 * } ...
 */
function normalize() {
  var _ref;

  return [(_ref = {
    html: {
      lineHeight: '1.15',
      textSizeAdjust: '100%'
    },
    body: {
      margin: '0'
    },
    main: {
      display: 'block'
    },
    h1: {
      fontSize: '2em',
      margin: '0.67em 0'
    },
    hr: {
      boxSizing: 'content-box',
      height: '0',
      overflow: 'visible'
    },
    pre: {
      fontFamily: 'monospace, monospace',
      fontSize: '1em'
    },
    a: {
      backgroundColor: 'transparent'
    },
    'abbr[title]': {
      borderBottom: 'none',
      textDecoration: 'underline'
    }
  }, _ref["b,\n    strong"] = {
    fontWeight: 'bolder'
  }, _ref["code,\n    kbd,\n    samp"] = {
    fontFamily: 'monospace, monospace',
    fontSize: '1em'
  }, _ref.small = {
    fontSize: '80%'
  }, _ref["sub,\n    sup"] = {
    fontSize: '75%',
    lineHeight: '0',
    position: 'relative',
    verticalAlign: 'baseline'
  }, _ref.sub = {
    bottom: '-0.25em'
  }, _ref.sup = {
    top: '-0.5em'
  }, _ref.img = {
    borderStyle: 'none'
  }, _ref["button,\n    input,\n    optgroup,\n    select,\n    textarea"] = {
    fontFamily: 'inherit',
    fontSize: '100%',
    lineHeight: '1.15',
    margin: '0'
  }, _ref["button,\n    input"] = {
    overflow: 'visible'
  }, _ref["button,\n    select"] = {
    textTransform: 'none'
  }, _ref["button,\n    html [type=\"button\"],\n    [type=\"reset\"],\n    [type=\"submit\"]"] = {
    WebkitAppearance: 'button'
  }, _ref["button::-moz-focus-inner,\n    [type=\"button\"]::-moz-focus-inner,\n    [type=\"reset\"]::-moz-focus-inner,\n    [type=\"submit\"]::-moz-focus-inner"] = {
    borderStyle: 'none',
    padding: '0'
  }, _ref["button:-moz-focusring,\n    [type=\"button\"]:-moz-focusring,\n    [type=\"reset\"]:-moz-focusring,\n    [type=\"submit\"]:-moz-focusring"] = {
    outline: '1px dotted ButtonText'
  }, _ref.fieldset = {
    padding: '0.35em 0.625em 0.75em'
  }, _ref.legend = {
    boxSizing: 'border-box',
    color: 'inherit',
    display: 'table',
    maxWidth: '100%',
    padding: '0',
    whiteSpace: 'normal'
  }, _ref.progress = {
    verticalAlign: 'baseline'
  }, _ref.textarea = {
    overflow: 'auto'
  }, _ref["[type=\"checkbox\"],\n    [type=\"radio\"]"] = {
    boxSizing: 'border-box',
    padding: '0'
  }, _ref["[type=\"number\"]::-webkit-inner-spin-button,\n    [type=\"number\"]::-webkit-outer-spin-button"] = {
    height: 'auto'
  }, _ref['[type="search"]'] = {
    WebkitAppearance: 'textfield',
    outlineOffset: '-2px'
  }, _ref['[type="search"]::-webkit-search-decoration'] = {
    WebkitAppearance: 'none'
  }, _ref['::-webkit-file-upload-button'] = {
    WebkitAppearance: 'button',
    font: 'inherit'
  }, _ref.details = {
    display: 'block'
  }, _ref.summary = {
    display: 'list-item'
  }, _ref.template = {
    display: 'none'
  }, _ref['[hidden]'] = {
    display: 'none'
  }, _ref), {
    'abbr[title]': {
      textDecoration: 'underline dotted'
    }
  }];
}

const GlobalStyles = createGlobalStyle`
  ${normalize()}

  * {
    &,
    &::before,
    &::after {
      box-sizing: border-box;
    }
  }
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;

  #root {
     min-height: 100%;
     height: 100%;
     margin: 0px;
     padding: 0px;
  }

  h1, h2, h3, h4, h5, h6, p{
    margin: 0;
    line-height: ${font.lineHeight};
    letter-spacing: ${font.letterSpacing};
  }

  html {
    font-size: 10px;
    background-color: ${({ theme }) => theme.bgColor};
  }
  body {
    font-family: ${font.family.body};
    color: ${({ theme }) => theme.fontColor}
  }
  `;

const breakpoints = {
  xs: "480px",
  sm: "768px",
  md: "1024px",
  lg: "1250px"
};
const widthQuery = {
  xs: `(max-width: ${breakpoints.xs})`,
  sm: `(max-width: ${breakpoints.sm})`,
  md: `(max-width: ${breakpoints.md})`,
  lg: `(max-width: ${breakpoints.lg})`
};

const field = {
  fontFamily: font.family.body,
  fontWeight: font.weight.reg,
  fontSize: font.size.md,
  size: {
    md: "28rem",
    lg: "52rem",
    full: "100%"
  },
  borderRadius: "0.4rem",
  transition: "0.2s all ease-in-out"
};

const BaseInput = styled.input`
  background-color: ${({ theme }) => theme.field.bg};
  border: 1px solid ${({ theme }) => theme.field.border};
  border-radius: ${field.borderRadius};
  color: ${({ theme }) => theme.fontColor};
  font-size: ${field.fontSize};
  font-weight: ${field.fontWeight};
  font-family: ${field.fontFamily};
  height: 4.8rem;
  line-height: 150%;
  letter-spacing: 1.5px;
  max-width: ${field.size.md};
  padding: 1.2rem 1.8rem;
  transition: ${field.transition};
  width: 100%;

  ::placeholder {
    color: ${({ theme }) => theme.field.placeholderText};
  }

  :hover {
    background-color: ${({ theme }) => theme.field.hoverBg};
    border: 1px solid
      ${({ theme }) => theme.field.hoverBorder};
  }

  :focus {
    background-color: ${({ theme }) => theme.field.focusBg};
    border: 1px solid
      ${({ theme }) => theme.field.focusBorder};
    outline: none;
  }

  :disabled {
    background-color: ${({ theme }) => theme.field.disabledBg};
    border: 1px solid
      ${({ theme }) => theme.field.disabledBorder};
    color: ${({ theme }) => theme.field.disabledPlaceholder};
    cursor: not-allowed;
    font-style: italic;

    ::placeholder {
      color: ${({ theme }) => theme.field.disabledPlaceholder};
    }
  }

  &.number {
    font-family: ${font.family.data};
    font-weight: ${font.weight.reg};
    letter-spacing: 1px;
  }

  &.long {
    max-width: ${field.size.lg};
  }

  &.full {
    max-width: ${field.size.full};
  }

  &.input-select {
    max-width: ${field.size.full};
  }

  &.success {
    border: 1px solid ${({ theme }) => theme.success};
  }

  &.warning {
    border: 1px solid ${({ theme }) => theme.warning};
  }

  &.error {
    border: 1px solid ${({ theme }) => theme.error};
  }
`;
const WithIcon$2 = styled.div`
  display: inline-block;
  position: relative;
  max-width: ${field.size.md};
  width: 100%;

  svg {
    color: ${({ theme }) => theme.field.placeholderText};
    position: absolute;
    right: 2rem;
    top: 1.4rem;
  }

  input {
    padding: 1.2rem 4.2rem 1.2rem 1.8rem;
  }

  &.long {
    max-width: ${field.size.lg};
  }

  &.full {
    max-width: ${field.size.full};
  }
`;

const Input = React__default.forwardRef((props, ref) => {
  const {
    id,
    long,
    full,
    icon,
    success,
    warning,
    error,
    number,
    address,
    className
  } = props;
  const inputClasses = classNames({
    long: long || address,
    full,
    success,
    warning,
    error,
    number: number || address
  });
  if (icon) {
    const wrapperClasses = classNames({
      long: long || address,
      full
    });
    const Icon = icon;
    return /* @__PURE__ */ jsxs(WithIcon$2, {
      className: wrapperClasses,
      children: [/* @__PURE__ */ jsx(BaseInput, {
        name: id,
        className: `${inputClasses} ${className}`,
        ref,
        ...props
      }), /* @__PURE__ */ jsx(Icon, {
        size: "2rem"
      })]
    });
  }
  return /* @__PURE__ */ jsx(BaseInput, {
    name: id,
    className: `${inputClasses} ${className}`,
    ref,
    ...props
  }, id);
});

const WithIcon$1 = styled.div`
  display: flex;
  align-items: flex-start;
  svg {
    color: ${(props) => props.color};
  }
  p {
    margin-left: 0.65rem;
    color: ${(props) => props.color};
  }
`;

const Par = styled.p`
  font-family: ${font.family.body};
  font-weight: ${font.weight.reg};
  color: ${({
  theme,
  color
}) => color || theme.fontColor};
`;
const Data = styled.p`
  font-family: ${font.family.data};
  font-weight: ${font.weight.reg};
  color: ${(props) => props.color};
  letter-spacing: 1px;
`;
const ParXs = styled(Par)`
  font-size: ${font.size.xs};
`;
const ParSm = styled(Par)`
  font-size: ${font.size.sm};
`;
const ParMd = styled(Par)`
  font-size: ${font.size.md};
`;
const ParLg = styled(Par)`
  font-size: ${font.size.lg};
`;
const ParXl = styled(Par)`
  font-size: ${font.size.xl};
`;
const H6 = styled.h6`
  font-size: ${font.size.md};
  font-weight: ${font.weight.black};
  font-family: ${font.family.body};
  color: ${(props) => props.color};
`;
const H5 = styled.h5`
  font-size: ${font.size.lg};
  font-weight: ${font.weight.bold};
  font-family: ${font.family.body};
  color: ${(props) => props.color};
`;
const H4 = styled.h4`
  font-size: ${font.size.xl};
  font-weight: ${font.weight.bold};
  font-family: ${font.family.body};
  color: ${(props) => props.color};
`;
const H3 = styled.h3`
  font-size: ${font.size.xxl};
  font-weight: ${font.weight.reg};
  font-family: ${font.family.body};
  color: ${(props) => props.color};
`;
const H2 = styled.h2`
  font-size: ${font.size.xxxl};
  font-weight: ${font.weight.light};
  font-family: ${font.family.body};
  color: ${(props) => props.color};
`;
const H1 = styled.h1`
  font-size: ${font.size.xxxxl};
  font-weight: ${font.weight.light};
  font-family: ${font.family.body};
  color: ${(props) => props.color};
`;
const DataXs = styled(Data)`
  font-size: ${font.size.xs};
`;
const DataSm = styled(Data)`
  font-size: ${font.size.sm};
`;
const DataMd = styled(Data)`
  font-size: ${font.size.md};
`;
const DataLg = styled(Data)`
  font-size: ${font.size.lg};
`;
const DataXl = styled(Data)`
  font-size: ${font.size.xl};
`;
const ExtraLight = styled.span`
  font-weight: ${font.weight.extraLight};
`;
const Light = styled.span`
  font-weight: ${font.weight.light};
`;
const Bold = styled.span`
  font-weight: ${font.weight.bold};
  color: ${({
  theme,
  color
}) => color || theme.fontColor};
`;
const ExtraBold = styled.span`
  font-weight: ${font.weight.black};
`;
const Italic = styled.span`
  font-style: italic;
`;
const Underline = styled.span`
  text-decoration: underline;
`;
const StrikeThrough = styled.span`
  text-decoration: line-through;
`;
const TintSecondary = styled.span`
  color: ${({
  theme
}) => theme.tint.secondary};
`;

const HelperText = ({
  color,
  icon,
  children
}) => {
  if (icon) {
    const Icon = icon;
    return /* @__PURE__ */ jsxs(WithIcon$1, {
      children: [/* @__PURE__ */ jsx(Icon, {
        size: "1.6rem",
        color
      }), /* @__PURE__ */ jsx(ParXs, {
        color,
        children
      })]
    });
  }
  return /* @__PURE__ */ jsx(ParXs, {
    color,
    children
  });
};
const SuccessText = ({
  children
}) => {
  const theme = useTheme();
  return /* @__PURE__ */ jsx(HelperText, {
    color: theme.success,
    icon: RiCheckboxCircleLine,
    children
  });
};
const WarningText = ({
  children
}) => {
  const theme = useTheme();
  return /* @__PURE__ */ jsx(HelperText, {
    color: theme.warning,
    icon: RiErrorWarningLine,
    children
  });
};
const ErrorText = ({
  children
}) => {
  const theme = useTheme();
  return /* @__PURE__ */ jsx(HelperText, {
    color: theme.error,
    icon: RiErrorWarningLine,
    children
  });
};

const BaseFileInput = styled(BaseInput)`
  padding-bottom: 4.3rem;
`;

const FileInput = React__default.forwardRef((props, ref) => {
  const {
    id,
    success,
    warning,
    error,
    multiple,
    className
  } = props;
  const inputClasses = classNames({
    success,
    warning,
    error
  });
  return /* @__PURE__ */ jsx(BaseFileInput, {
    name: id,
    className: `${inputClasses} ${className}`,
    ref,
    type: "file",
    multiple,
    ...props
  }, id);
});

const BaseTextArea = styled.textarea`
  background-color: ${({ theme }) => theme.field.bg};
  border: 1px solid ${({ theme }) => theme.field.border};
  border-radius: ${field.borderRadius};
  color: ${({ theme }) => theme.fontColor};
  font-size: ${field.fontSize};
  font-weight: ${field.fontWeight};
  font-family: ${field.fontFamily};
  height: 7.688rem;
  max-width: ${field.size.lg};
  height: ${({ height }) => height || "12rem"};

  width: 100%;
  border: 1px solid ${({ theme }) => theme.bgColor};
  border-radius: ${field.borderRadius};
  line-height: 150%;
  letter-spacing: 1.5px;
  max-width: ${field.size.lg};
  padding: 1.2rem 1.8rem;
  resize: none;
  transition: ${field.transition};
  width: 100%;

  ::placeholder {
    color: ${({ theme }) => theme.field.placeholderText};
  }

  :hover {
    background-color: ${({ theme }) => theme.field.hoverBg};
    border: 1px solid
      ${({ theme }) => theme.field.hoverBorder};
  }

  :focus {
    background-color: ${({ theme }) => theme.field.focusBg};
    border: 1px solid
      ${({ theme }) => theme.field.focusBorder};
    outline: none;
  }

  :disabled {
    background-color: ${({ theme }) => theme.field.disabledBg};
    border: 1px solid
      ${({ theme }) => theme.field.disabledBorder};
    cursor: not-allowed;
    font-style: italic;

    ::placeholder {
      color: ${({ theme }) => theme.field.disabledPlaceholder};
    }
  }

  &.full {
    max-width: ${field.size.full};
  }

  &.success {
    border: 1px solid ${({ theme }) => theme.success};
  }

  &.warning {
    border: 1px solid ${({ theme }) => theme.warning};
  }

  &.error {
    border: 1px solid ${({ theme }) => theme.error};
  }
`;

const TextArea = React__default.forwardRef((props, ref) => {
  const {
    full,
    warning,
    error,
    success,
    className,
    height
  } = props;
  const classes = classNames({
    full,
    success,
    warning,
    error
  });
  return /* @__PURE__ */ jsx(BaseTextArea, {
    ...props,
    className: `${classes} ${className}`,
    ref,
    rows: 10,
    height
  });
});

/**
 * Listens for when the escape key is down
 */ function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp) {
    const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
    useEffect$1(()=>{
        const handleKeyDown = (event)=>{
            if (event.key === 'Escape') onEscapeKeyDown(event);
        };
        document.addEventListener('keydown', handleKeyDown);
        return ()=>document.removeEventListener('keydown', handleKeyDown)
        ;
    }, [
        onEscapeKeyDown
    ]);
}

const $5cb92bef7577960e$var$CONTEXT_UPDATE = 'dismissableLayer.update';
const $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';
const $5cb92bef7577960e$var$FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';
let $5cb92bef7577960e$var$originalBodyPointerEvents;
const $5cb92bef7577960e$var$DismissableLayerContext = /*#__PURE__*/ createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set()
});
const $5cb92bef7577960e$export$177fb62ff3ec1f22 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { disableOutsidePointerEvents: disableOutsidePointerEvents = false , onEscapeKeyDown: onEscapeKeyDown , onPointerDownOutside: onPointerDownOutside , onFocusOutside: onFocusOutside , onInteractOutside: onInteractOutside , onDismiss: onDismiss , ...layerProps } = props;
    const context = useContext($5cb92bef7577960e$var$DismissableLayerContext);
    const [node1, setNode] = useState$1(null);
    const [, force] = useState$1({});
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node)=>setNode(node)
    );
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [
        ...context.layersWithOutsidePointerEventsDisabled
    ].slice(-1); // prettier-ignore
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore
    const index = node1 ? layers.indexOf(node1) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event)=>{
        const target = event.target;
        const isPointerDownOnBranch = [
            ...context.branches
        ].some((branch)=>branch.contains(target)
        );
        if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
        onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
        onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
        if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss();
    });
    const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event)=>{
        const target = event.target;
        const isFocusInBranch = [
            ...context.branches
        ].some((branch)=>branch.contains(target)
        );
        if (isFocusInBranch) return;
        onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
        onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
        if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss();
    });
    $addc16e1bbe58fd0$export$3a72a57244d6e765((event)=>{
        const isHighestLayer = index === context.layers.size - 1;
        if (!isHighestLayer) return;
        onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
        if (!event.defaultPrevented && onDismiss) {
            event.preventDefault();
            onDismiss();
        }
    });
    useEffect$1(()=>{
        if (!node1) return;
        if (disableOutsidePointerEvents) {
            if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
                $5cb92bef7577960e$var$originalBodyPointerEvents = document.body.style.pointerEvents;
                document.body.style.pointerEvents = 'none';
            }
            context.layersWithOutsidePointerEventsDisabled.add(node1);
        }
        context.layers.add(node1);
        $5cb92bef7577960e$var$dispatchUpdate();
        return ()=>{
            if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) document.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
        };
    }, [
        node1,
        disableOutsidePointerEvents,
        context
    ]);
    /**
   * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect
   * because a change to `disableOutsidePointerEvents` would remove this layer from the stack
   * and add it to the end again so the layering order wouldn't be _creation order_.
   * We only want them to be removed from context stacks when unmounted.
   */ useEffect$1(()=>{
        return ()=>{
            if (!node1) return;
            context.layers.delete(node1);
            context.layersWithOutsidePointerEventsDisabled.delete(node1);
            $5cb92bef7577960e$var$dispatchUpdate();
        };
    }, [
        node1,
        context
    ]);
    useEffect$1(()=>{
        const handleUpdate = ()=>force({})
        ;
        document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
        return ()=>document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate)
        ;
    }, []);
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, layerProps, {
        ref: composedRefs,
        style: {
            pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? 'auto' : 'none' : undefined,
            ...props.style
        },
        onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
    }));
});
const $5cb92bef7577960e$export$4d5eb2109db14228 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const context = useContext($5cb92bef7577960e$var$DismissableLayerContext);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    useEffect$1(()=>{
        const node = ref.current;
        if (node) {
            context.branches.add(node);
            return ()=>{
                context.branches.delete(node);
            };
        }
    }, [
        context.branches
    ]);
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, props, {
        ref: composedRefs
    }));
});
/* -----------------------------------------------------------------------------------------------*/ /**
 * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`
 * to mimic layer dismissing behaviour present in OS.
 * Returns props to pass to the node we want to check for outside events.
 */ function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside) {
    const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
    const isPointerInsideReactTreeRef = useRef(false);
    const handleClickRef = useRef(()=>{});
    useEffect$1(()=>{
        const handlePointerDown = (event)=>{
            if (event.target && !isPointerInsideReactTreeRef.current) {
                const eventDetail = {
                    originalEvent: event
                };
                function handleAndDispatchPointerDownOutsideEvent() {
                    $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
                        discrete: true
                    });
                }
                /**
         * On touch devices, we need to wait for a click event because browsers implement
         * a ~350ms delay between the time the user stops touching the display and when the
         * browser executres events. We need to ensure we don't reactivate pointer-events within
         * this timeframe otherwise the browser may execute events that should have been prevented.
         *
         * Additionally, this also lets us deal automatically with cancellations when a click event
         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.
         *
         * This is why we also continuously remove the previous listener, because we cannot be
         * certain that it was raised, and therefore cleaned-up.
         */ if (event.pointerType === 'touch') {
                    document.removeEventListener('click', handleClickRef.current);
                    handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
                    document.addEventListener('click', handleClickRef.current, {
                        once: true
                    });
                } else handleAndDispatchPointerDownOutsideEvent();
            }
            isPointerInsideReactTreeRef.current = false;
        };
        /**
     * if this hook executes in a component that mounts via a `pointerdown` event, the event
     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid
     * this by delaying the event listener registration on the document.
     * This is not React specific, but rather how the DOM works, ie:
     * ```
     * button.addEventListener('pointerdown', () => {
     *   console.log('I will log');
     *   document.addEventListener('pointerdown', () => {
     *     console.log('I will also log');
     *   })
     * });
     */ const timerId = window.setTimeout(()=>{
            document.addEventListener('pointerdown', handlePointerDown);
        }, 0);
        return ()=>{
            window.clearTimeout(timerId);
            document.removeEventListener('pointerdown', handlePointerDown);
            document.removeEventListener('click', handleClickRef.current);
        };
    }, [
        handlePointerDownOutside
    ]);
    return {
        // ensures we check React component tree (not just DOM tree)
        onPointerDownCapture: ()=>isPointerInsideReactTreeRef.current = true
    };
}
/**
 * Listens for when focus happens outside a react subtree.
 * Returns props to pass to the root (node) of the subtree we want to check.
 */ function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside) {
    const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
    const isFocusInsideReactTreeRef = useRef(false);
    useEffect$1(()=>{
        const handleFocus = (event)=>{
            if (event.target && !isFocusInsideReactTreeRef.current) {
                const eventDetail = {
                    originalEvent: event
                };
                $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
                    discrete: false
                });
            }
        };
        document.addEventListener('focusin', handleFocus);
        return ()=>document.removeEventListener('focusin', handleFocus)
        ;
    }, [
        handleFocusOutside
    ]);
    return {
        onFocusCapture: ()=>isFocusInsideReactTreeRef.current = true
        ,
        onBlurCapture: ()=>isFocusInsideReactTreeRef.current = false
    };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
    const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
    document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete: discrete  }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, {
        bubbles: false,
        cancelable: true,
        detail: detail
    });
    if (handler) target.addEventListener(name, handler, {
        once: true
    });
    if (discrete) $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
    else target.dispatchEvent(event);
}
const $5cb92bef7577960e$export$be92b6f5f03c0fe9 = $5cb92bef7577960e$export$177fb62ff3ec1f22;
const $5cb92bef7577960e$export$aecb2ddcb55c95be = $5cb92bef7577960e$export$4d5eb2109db14228;

function getSide(placement) {
  return placement.split('-')[0];
}

function getAlignment(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;

  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;

    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;

    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }

  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;

    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }

  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */

const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));

  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;

  for (let i = 0; i < middleware.length; i++) {
    const {
      name,
      fn
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = { ...middlewareData,
      [name]: { ...middlewareData[name],
        ...data
      }
    };

    if (reset && resetCount <= 50) {
      resetCount++;

      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }

        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }

        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }

      i = -1;
      continue;
    }
  }

  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return { ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;

  if (options === void 0) {
    options = {};
  }

  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === 'floating' ? { ...rects.floating,
      x,
      y
    } : rects.reference,
    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}

const min$1 = Math.min;
const max$1 = Math.max;

function within(min$1$1, value, max$1$1) {
  return max$1(min$1$1, min$1(value, max$1$1));
}

/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow$1 = options => ({
  name: 'arrow',
  options,

  async fn(middlewareArguments) {
    // Since `element` is required, we don't Partial<> the type
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y,
      placement,
      rects,
      platform
    } = middlewareArguments;

    if (element == null) {

      return {};
    }

    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const alignment = getAlignment(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const minProp = axis === 'y' ? 'top' : 'left';
    const maxProp = axis === 'y' ? 'bottom' : 'right';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;

    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }

    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds

    const min = paddingObject[minProp];
    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = within(min, center, max); // Make sure that arrow points at the reference

    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];
    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];
    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset
      }
    };
  }

});

const hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }

  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';

  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }

  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const hash = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, matched => hash[matched]);
}

const sides = ['top', 'right', 'bottom', 'left'];

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

/**
 * Changes the placement of the floating element to one that will fit if the
 * initially specified `placement` does not.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'flip',
    options,

    async fn(middlewareArguments) {
      var _middlewareData$flip;

      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];

      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }

      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }

      overflowsData = [...overflowsData, {
        placement,
        overflows
      }]; // One or more sides is overflowing

      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;

        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];

        if (nextPlacement) {
          // Try next placement and re-run the lifecycle
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        let resetPlacement = 'bottom';

        switch (fallbackStrategy) {
          case 'bestFit':
            {
              var _overflowsData$map$so;

              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;

              if (placement) {
                resetPlacement = placement;
              }

              break;
            }

          case 'initialPlacement':
            resetPlacement = initialPlacement;
            break;
        }

        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }

      return {};
    }

  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}

function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide$1 = function (_temp) {
  let {
    strategy = 'referenceHidden',
    ...detectOverflowOptions
  } = _temp === void 0 ? {} : _temp;
  return {
    name: 'hide',

    async fn(middlewareArguments) {
      const {
        rects
      } = middlewareArguments;

      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }

        case 'escaped':
          {
            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }

        default:
          {
            return {};
          }
      }
    }

  };
};

async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform,
    elements
  } = middlewareArguments;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const

  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };

  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }

  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
/**
 * Displaces the floating element from its reference element.
 * @see https://floating-ui.com/docs/offset
 */

const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }

  return {
    name: 'offset',
    options: value,

    async fn(middlewareArguments) {
      const {
        x,
        y
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }

  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Shifts the floating element in order to keep it in view when it will overflow
 * a clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'shift',
    options,

    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];

      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min, mainAxisCoord, max);
      }

      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min, crossAxisCoord, max);
      }

      const limitedCoords = limiter.fn({ ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return { ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }

  };
};

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    options,

    fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = options;
      const coords = {
        x,
        y
      };
      const mainAxis = getMainAxisFromPlacement(placement);
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = typeof offset === 'function' ? offset({ ...rects,
        placement
      }) : offset;
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };

      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;

        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }

      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;

        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);

        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }

      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }

  };
};

function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function getNodeName(node) {
  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';
}

function getUAString() {
  const uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands) {
    return uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
  }

  return navigator.userAgent;
}

function isHTMLElement$1(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  // TODO: Try and use feature detection here instead
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)
  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);
}
function isLayoutViewport() {
  // Not Safari
  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways
  // â€¢ Always-visible scrollbar or not
  // â€¢ Width of <html>, etc.
  // const vV = win.visualViewport;
  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}

const min = Math.min;
const max = Math.max;
const round = Math.round;

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;

  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;

  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)
  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || ( // DOM Element detected
    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
}

function getContainingBlock(element) {
  let currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement$1(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getDimensions(element) {
  if (isHTMLElement$1(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }

  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);

  if (offsetParent === documentElement) {
    return rect;
  }

  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } // This doesn't appear to be need to be negated.
    // else if (documentElement) {
    //   offsets.x = getWindowScrollBarX(documentElement);
    // }

  }

  return { ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width,
    height,
    x,
    y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;

  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width,
    height,
    x,
    y
  };
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);

  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {
    // @ts-ignore assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }

  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;

  if (list === void 0) {
    list = [];
  }

  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here
  updatedList.concat(getOverflowAncestors(target));
}

function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;

    do {
      // use `===` replace node.isSameNode()
      if (next && parent === next) {
        return true;
      } // @ts-ignore: need a better way to handle this...


      next = next.parentNode || next.host;
    } while (next);
  }

  return false;
}

function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}

function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === 'viewport') {
    return rectToClientRect(getViewportRect(element, strategy));
  }

  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }

  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping ancestor" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // @ts-ignore isElement check ensures we return Array<Element>


  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');
} // Gets the maximum area that the element is visible in due to any number of
// clipping ancestors


function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: _ref => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: { ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$1(element).direction === 'rtl'
};

/**
 * Automatically updates the position of the floating element when necessary.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }

  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  let observer = null;

  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }

      initialUpdate = false;
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    observer.observe(floating);
  }

  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;

  if (animationFrame) {
    frameLoop();
  }

  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);

    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }

    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }

  update();
  return () => {
    var _observer;

    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;

    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */

const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
  platform,
  ...options
});

var index = typeof document !== 'undefined' ? useLayoutEffect$1 : useEffect$1;

// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function deepEqual$1(a, b) {
  if (a === b) {
    return true;
  }

  if (typeof a !== typeof b) {
    return false;
  }

  if (typeof a === 'function' && a.toString() === b.toString()) {
    return true;
  }

  let length, i, keys;

  if (a && b && typeof a == 'object') {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) {
        if (!deepEqual$1(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    keys = Object.keys(a);
    length = keys.length;

    if (length !== Object.keys(b).length) {
      return false;
    }

    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }

    for (i = length; i-- !== 0;) {
      const key = keys[i];

      if (key === '_owner' && a.$$typeof) {
        continue;
      }

      if (!deepEqual$1(a[key], b[key])) {
        return false;
      }
    }

    return true;
  }

  return a !== a && b !== b;
}

function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}

function useFloating(_temp) {
  let {
    middleware,
    placement = 'bottom',
    strategy = 'absolute',
    whileElementsMounted
  } = _temp === void 0 ? {} : _temp;
  const reference = React.useRef(null);
  const floating = React.useRef(null);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const cleanupRef = React.useRef(null);
  const [data, setData] = React.useState({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {}
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);

  if (!deepEqual$1(latestMiddleware == null ? void 0 : latestMiddleware.map(_ref => {
    let {
      options
    } = _ref;
    return options;
  }), middleware == null ? void 0 : middleware.map(_ref2 => {
    let {
      options
    } = _ref2;
    return options;
  }))) {
    setLatestMiddleware(middleware);
  }

  const update = React.useCallback(() => {
    if (!reference.current || !floating.current) {
      return;
    }

    computePosition(reference.current, floating.current, {
      middleware: latestMiddleware,
      placement,
      strategy
    }).then(data => {
      if (isMountedRef.current) {
        ReactDOM.flushSync(() => {
          setData(data);
        });
      }
    });
  }, [latestMiddleware, placement, strategy]);
  index(() => {
    // Skip first update
    if (isMountedRef.current) {
      update();
    }
  }, [update]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const runElementMountCallback = React.useCallback(() => {
    if (typeof cleanupRef.current === 'function') {
      cleanupRef.current();
      cleanupRef.current = null;
    }

    if (reference.current && floating.current) {
      if (whileElementsMountedRef.current) {
        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);
        cleanupRef.current = cleanupFn;
      } else {
        update();
      }
    }
  }, [update, whileElementsMountedRef]);
  const setReference = React.useCallback(node => {
    reference.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const setFloating = React.useCallback(node => {
    floating.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const refs = React.useMemo(() => ({
    reference,
    floating
  }), []);
  return React.useMemo(() => ({ ...data,
    update,
    refs,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, setReference, setFloating]);
}

/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */

const arrow = options => {
  const {
    element,
    padding
  } = options;

  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, 'current');
  }

  return {
    name: 'arrow',
    options,

    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return arrow$1({
            element: element.current,
            padding
          }).fn(args);
        }

        return {};
      } else if (element) {
        return arrow$1({
          element,
          padding
        }).fn(args);
      }

      return {};
    }

  };
};

const $7e8f5cd07187803e$export$21b07c8f274aebd5 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { children: children , width: width = 10 , height: height = 5 , ...arrowProps } = props;
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends$2({}, arrowProps, {
        ref: forwardedRef,
        width: width,
        height: height,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none"
    }), props.asChild ? children : /*#__PURE__*/ createElement("polygon", {
        points: "0,0 30,0 15,10"
    }));
});
/* -----------------------------------------------------------------------------------------------*/ const $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;

/* -------------------------------------------------------------------------------------------------
 * Popper
 * -----------------------------------------------------------------------------------------------*/ const $cf1ac5d9fe0e8206$var$POPPER_NAME = 'Popper';
const [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
const [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
const $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props)=>{
    const { __scopePopper: __scopePopper , children: children  } = props;
    const [anchor, setAnchor] = useState$1(null);
    return /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$var$PopperProvider, {
        scope: __scopePopper,
        anchor: anchor,
        onAnchorChange: setAnchor
    }, children);
};
/* -------------------------------------------------------------------------------------------------
 * PopperAnchor
 * -----------------------------------------------------------------------------------------------*/ const $cf1ac5d9fe0e8206$var$ANCHOR_NAME = 'PopperAnchor';
const $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopePopper: __scopePopper , virtualRef: virtualRef , ...anchorProps } = props;
    const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    useEffect$1(()=>{
        // Consumer can anchor the popper to something that isn't
        // a DOM node e.g. pointer position, so we override the
        // `anchorRef` with their virtual ref in this case.
        context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, anchorProps, {
        ref: composedRefs
    }));
});
/* -------------------------------------------------------------------------------------------------
 * PopperContent
 * -----------------------------------------------------------------------------------------------*/ const $cf1ac5d9fe0e8206$var$CONTENT_NAME = 'PopperContent';
const [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
const [$cf1ac5d9fe0e8206$var$PositionContextProvider, $cf1ac5d9fe0e8206$var$usePositionContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, {
    hasParent: false,
    positionUpdateFns: new Set()
});
const $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$hide, _middlewareData$trans, _middlewareData$trans2;
    const { __scopePopper: __scopePopper , side: side = 'bottom' , sideOffset: sideOffset = 0 , align: align = 'center' , alignOffset: alignOffset = 0 , arrowPadding: arrowPadding = 0 , collisionBoundary: collisionBoundary = [] , collisionPadding: collisionPaddingProp = 0 , sticky: sticky = 'partial' , hideWhenDetached: hideWhenDetached = false , avoidCollisions: avoidCollisions = true , ...contentProps } = props;
    const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
    const [content, setContent] = useState$1(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node)=>setContent(node)
    );
    const [arrow$1, setArrow] = useState$1(null);
    const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow$1);
    const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
    const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
    const desiredPlacement = side + (align !== 'center' ? '-' + align : '');
    const collisionPadding = typeof collisionPaddingProp === 'number' ? collisionPaddingProp : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...collisionPaddingProp
    };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
        collisionBoundary
    ];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
        padding: collisionPadding,
        boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: hasExplicitBoundaries
    };
    const { reference: reference , floating: floating , strategy: strategy , x: x , y: y , placement: placement , middlewareData: middlewareData , update: update  } = useFloating({
        // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
        strategy: 'fixed',
        placement: desiredPlacement,
        whileElementsMounted: autoUpdate,
        middleware: [
            offset({
                mainAxis: sideOffset + arrowHeight,
                alignmentAxis: alignOffset
            }),
            avoidCollisions ? shift({
                mainAxis: true,
                crossAxis: false,
                limiter: sticky === 'partial' ? limitShift() : undefined,
                ...detectOverflowOptions
            }) : undefined,
            arrow$1 ? arrow({
                element: arrow$1,
                padding: arrowPadding
            }) : undefined,
            avoidCollisions ? flip({
                ...detectOverflowOptions
            }) : undefined,
            $cf1ac5d9fe0e8206$var$transformOrigin({
                arrowWidth: arrowWidth,
                arrowHeight: arrowHeight
            }),
            hideWhenDetached ? hide$1({
                strategy: 'referenceHidden'
            }) : undefined
        ].filter($cf1ac5d9fe0e8206$var$isDefined)
    }); // assign the reference dynamically once `Content` has mounted so we can collocate the logic
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        reference(context.anchor);
    }, [
        reference,
        context.anchor
    ]);
    const isPlaced = x !== null && y !== null;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
    const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
    const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = useState$1();
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [
        content
    ]);
    const { hasParent: hasParent , positionUpdateFns: positionUpdateFns  } = $cf1ac5d9fe0e8206$var$usePositionContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
    const isRoot = !hasParent;
    useLayoutEffect$1(()=>{
        if (!isRoot) {
            positionUpdateFns.add(update);
            return ()=>{
                positionUpdateFns.delete(update);
            };
        }
    }, [
        isRoot,
        positionUpdateFns,
        update
    ]); // when nested contents are rendered in portals, they are appended out of order causing
    // children to be positioned incorrectly if initially open.
    // we need to re-compute the positioning once the parent has finally been placed.
    // https://github.com/floating-ui/floating-ui/issues/1531
    useLayoutEffect$1(()=>{
        if (isRoot && isPlaced) Array.from(positionUpdateFns).reverse().forEach((fn)=>requestAnimationFrame(fn)
        );
    }, [
        isRoot,
        isPlaced,
        positionUpdateFns
    ]);
    const commonProps = {
        'data-side': placedSide,
        'data-align': placedAlign,
        ...contentProps,
        ref: composedRefs,
        style: {
            ...contentProps.style,
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: !isPlaced ? 'none' : undefined,
            // hide the content if using the hide middleware and should be hidden
            opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : undefined
        }
    };
    return /*#__PURE__*/ createElement("div", {
        ref: floating,
        "data-radix-popper-content-wrapper": "",
        style: {
            position: strategy,
            left: 0,
            top: 0,
            transform: isPlaced ? `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)` : 'translate3d(0, -200%, 0)',
            // keep off the page when measuring
            minWidth: 'max-content',
            zIndex: contentZIndex,
            ['--radix-popper-transform-origin']: [
                (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
                (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
            ].join(' ')
        }
    }, /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$var$PopperContentProvider, {
        scope: __scopePopper,
        placedSide: placedSide,
        onArrowChange: setArrow,
        arrowX: arrowX,
        arrowY: arrowY,
        shouldHideArrow: cannotCenterArrow
    }, isRoot ? /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$var$PositionContextProvider, {
        scope: __scopePopper,
        hasParent: true,
        positionUpdateFns: positionUpdateFns
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)) : /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)));
});
/* -------------------------------------------------------------------------------------------------
 * PopperArrow
 * -----------------------------------------------------------------------------------------------*/ const $cf1ac5d9fe0e8206$var$ARROW_NAME = 'PopperArrow';
const $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
    top: 'bottom',
    right: 'left',
    bottom: 'top',
    left: 'right'
};
const $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /*#__PURE__*/ forwardRef(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0(props, forwardedRef) {
    const { __scopePopper: __scopePopper , ...arrowProps } = props;
    const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
    const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
    return(/*#__PURE__*/ // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    createElement("span", {
        ref: contentContext.onArrowChange,
        style: {
            position: 'absolute',
            left: contentContext.arrowX,
            top: contentContext.arrowY,
            [baseSide]: 0,
            transformOrigin: {
                top: '',
                right: '0 0',
                bottom: 'center 0',
                left: '100% 0'
            }[contentContext.placedSide],
            transform: {
                top: 'translateY(100%)',
                right: 'translateY(50%) rotate(90deg) translateX(-50%)',
                bottom: `rotate(180deg)`,
                left: 'translateY(50%) rotate(-90deg) translateX(50%)'
            }[contentContext.placedSide],
            visibility: contentContext.shouldHideArrow ? 'hidden' : undefined
        }
    }, /*#__PURE__*/ createElement($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends$2({}, arrowProps, {
        ref: forwardedRef,
        style: {
            ...arrowProps.style,
            // ensures the element can be measured correctly (mostly for if SVG)
            display: 'block'
        }
    }))));
});
/* -----------------------------------------------------------------------------------------------*/ function $cf1ac5d9fe0e8206$var$isDefined(value) {
    return value !== undefined;
}
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
    return value !== null;
}
const $cf1ac5d9fe0e8206$var$transformOrigin = (options)=>({
        name: 'transformOrigin',
        options: options,
        fn (data) {
            var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
            const { placement: placement , rects: rects , middlewareData: middlewareData  } = data;
            const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
            const isArrowHidden = cannotCenterArrow;
            const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
            const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
            const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
            const noArrowAlign = {
                start: '0%',
                center: '50%',
                end: '100%'
            }[placedAlign];
            const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
            const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
            let x = '';
            let y = '';
            if (placedSide === 'bottom') {
                x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
                y = `${-arrowHeight}px`;
            } else if (placedSide === 'top') {
                x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
                y = `${rects.floating.height + arrowHeight}px`;
            } else if (placedSide === 'right') {
                x = `${-arrowHeight}px`;
                y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
            } else if (placedSide === 'left') {
                x = `${rects.floating.width + arrowHeight}px`;
                y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
            }
            return {
                data: {
                    x: x,
                    y: y
                }
            };
        }
    })
;
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
    const [side, align = 'center'] = placement.split('-');
    return [
        side,
        align
    ];
}
const $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
const $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
const $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
const $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;

const $f1701beae083dbae$export$602eac185826482c = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    var _globalThis$document;
    const { container: container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body , ...portalProps } = props;
    return container ? /*#__PURE__*/ ReactDOM__default.createPortal(/*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, portalProps, {
        ref: forwardedRef
    })), container) : null;
});

const [$a093c7e1ec25a057$var$createTooltipContext, $a093c7e1ec25a057$export$1c540a2224f0d865] = $c512c27ab02ef895$export$50c7b4e9d9f19c1('Tooltip', [
    $cf1ac5d9fe0e8206$export$722aac194ae923
]);
const $a093c7e1ec25a057$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
/* -------------------------------------------------------------------------------------------------
 * TooltipProvider
 * -----------------------------------------------------------------------------------------------*/ const $a093c7e1ec25a057$var$PROVIDER_NAME = 'TooltipProvider';
const $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION = 700;
const $a093c7e1ec25a057$var$TOOLTIP_OPEN = 'tooltip.open';
const [$a093c7e1ec25a057$var$TooltipProviderContextProvider, $a093c7e1ec25a057$var$useTooltipProviderContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PROVIDER_NAME);
const $a093c7e1ec25a057$export$f78649fb9ca566b8 = (props)=>{
    const { __scopeTooltip: __scopeTooltip , delayDuration: delayDuration = $a093c7e1ec25a057$var$DEFAULT_DELAY_DURATION , skipDelayDuration: skipDelayDuration = 300 , disableHoverableContent: disableHoverableContent = false , children: children  } = props;
    const [isOpenDelayed, setIsOpenDelayed] = useState$1(true);
    const isPointerInTransitRef = useRef(false);
    const skipDelayTimerRef = useRef(0);
    useEffect$1(()=>{
        const skipDelayTimer = skipDelayTimerRef.current;
        return ()=>window.clearTimeout(skipDelayTimer)
        ;
    }, []);
    return /*#__PURE__*/ createElement($a093c7e1ec25a057$var$TooltipProviderContextProvider, {
        scope: __scopeTooltip,
        isOpenDelayed: isOpenDelayed,
        delayDuration: delayDuration,
        onOpen: useCallback(()=>{
            window.clearTimeout(skipDelayTimerRef.current);
            setIsOpenDelayed(false);
        }, []),
        onClose: useCallback(()=>{
            window.clearTimeout(skipDelayTimerRef.current);
            skipDelayTimerRef.current = window.setTimeout(()=>setIsOpenDelayed(true)
            , skipDelayDuration);
        }, [
            skipDelayDuration
        ]),
        isPointerInTransitRef: isPointerInTransitRef,
        onPointerInTransitChange: useCallback((inTransit)=>{
            isPointerInTransitRef.current = inTransit;
        }, []),
        disableHoverableContent: disableHoverableContent
    }, children);
};
/* -------------------------------------------------------------------------------------------------
 * Tooltip
 * -----------------------------------------------------------------------------------------------*/ const $a093c7e1ec25a057$var$TOOLTIP_NAME = 'Tooltip';
const [$a093c7e1ec25a057$var$TooltipContextProvider, $a093c7e1ec25a057$var$useTooltipContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME);
const $a093c7e1ec25a057$export$28c660c63b792dea = (props)=>{
    const { __scopeTooltip: __scopeTooltip , children: children , open: openProp , defaultOpen: defaultOpen = false , onOpenChange: onOpenChange , disableHoverableContent: disableHoverableContentProp , delayDuration: delayDurationProp  } = props;
    const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TOOLTIP_NAME, props.__scopeTooltip);
    const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
    const [trigger, setTrigger] = useState$1(null);
    const contentId = $1746a345f3d73bb7$export$f680877a34711e37();
    const openTimerRef = useRef(0);
    const disableHoverableContent = disableHoverableContentProp !== null && disableHoverableContentProp !== void 0 ? disableHoverableContentProp : providerContext.disableHoverableContent;
    const delayDuration = delayDurationProp !== null && delayDurationProp !== void 0 ? delayDurationProp : providerContext.delayDuration;
    const wasOpenDelayedRef = useRef(false);
    const [open1 = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: (open)=>{
            if (open) {
                providerContext.onOpen(); // as `onChange` is called within a lifecycle method we
                // avoid dispatching via `dispatchDiscreteCustomEvent`.
                document.dispatchEvent(new CustomEvent($a093c7e1ec25a057$var$TOOLTIP_OPEN));
            } else providerContext.onClose();
            onOpenChange === null || onOpenChange === void 0 || onOpenChange(open);
        }
    });
    const stateAttribute = useMemo(()=>{
        return open1 ? wasOpenDelayedRef.current ? 'delayed-open' : 'instant-open' : 'closed';
    }, [
        open1
    ]);
    const handleOpen = useCallback(()=>{
        window.clearTimeout(openTimerRef.current);
        wasOpenDelayedRef.current = false;
        setOpen(true);
    }, [
        setOpen
    ]);
    const handleClose = useCallback(()=>{
        window.clearTimeout(openTimerRef.current);
        setOpen(false);
    }, [
        setOpen
    ]);
    const handleDelayedOpen = useCallback(()=>{
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = window.setTimeout(()=>{
            wasOpenDelayedRef.current = true;
            setOpen(true);
        }, delayDuration);
    }, [
        delayDuration,
        setOpen
    ]);
    useEffect$1(()=>{
        return ()=>window.clearTimeout(openTimerRef.current)
        ;
    }, []);
    return /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /*#__PURE__*/ createElement($a093c7e1ec25a057$var$TooltipContextProvider, {
        scope: __scopeTooltip,
        contentId: contentId,
        open: open1,
        stateAttribute: stateAttribute,
        trigger: trigger,
        onTriggerChange: setTrigger,
        onTriggerEnter: useCallback(()=>{
            if (providerContext.isOpenDelayed) handleDelayedOpen();
            else handleOpen();
        }, [
            providerContext.isOpenDelayed,
            handleDelayedOpen,
            handleOpen
        ]),
        onTriggerLeave: useCallback(()=>{
            if (disableHoverableContent) handleClose();
            else // Clear the timer in case the pointer leaves the trigger before the tooltip is opened.
            window.clearTimeout(openTimerRef.current);
        }, [
            handleClose,
            disableHoverableContent
        ]),
        onOpen: handleOpen,
        onClose: handleClose,
        disableHoverableContent: disableHoverableContent
    }, children));
};
/* -------------------------------------------------------------------------------------------------
 * TooltipTrigger
 * -----------------------------------------------------------------------------------------------*/ const $a093c7e1ec25a057$var$TRIGGER_NAME = 'TooltipTrigger';
const $a093c7e1ec25a057$export$8c610744efcf8a1d = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeTooltip: __scopeTooltip , ...triggerProps } = props;
    const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);
    const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TRIGGER_NAME, __scopeTooltip);
    const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = useRef(false);
    const hasPointerMoveOpenedRef = useRef(false);
    const handlePointerUp = useCallback(()=>isPointerDownRef.current = false
    , []);
    useEffect$1(()=>{
        return ()=>document.removeEventListener('pointerup', handlePointerUp)
        ;
    }, [
        handlePointerUp
    ]);
    return /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends$2({
        asChild: true
    }, popperScope), /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
        // We purposefully avoid adding `type=button` here because tooltip triggers are also
        // commonly anchors and the anchor `type` attribute signifies MIME type.
        "aria-describedby": context.open ? context.contentId : undefined,
        "data-state": context.stateAttribute
    }, triggerProps, {
        ref: composedRefs,
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event)=>{
            if (event.pointerType === 'touch') return;
            if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
                context.onTriggerEnter();
                hasPointerMoveOpenedRef.current = true;
            }
        }),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, ()=>{
            context.onTriggerLeave();
            hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, ()=>{
            isPointerDownRef.current = true;
            document.addEventListener('pointerup', handlePointerUp, {
                once: true
            });
        }),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, ()=>{
            if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, context.onClose),
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, (event)=>{
            // keyboard click will occur under different conditions for different node
            // types so we use `onClick` instead of `onKeyDown` to respect that
            const isKeyboardClick = event.detail === 0;
            if (isKeyboardClick) context.onClose();
        })
    })));
});
/* -------------------------------------------------------------------------------------------------
 * TooltipPortal
 * -----------------------------------------------------------------------------------------------*/ const $a093c7e1ec25a057$var$PORTAL_NAME = 'TooltipPortal';
const [$a093c7e1ec25a057$var$PortalProvider, $a093c7e1ec25a057$var$usePortalContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, {
    forceMount: undefined
});
const $a093c7e1ec25a057$export$7b36b8f925ab7497 = (props)=>{
    const { __scopeTooltip: __scopeTooltip , forceMount: forceMount , children: children , container: container  } = props;
    const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME, __scopeTooltip);
    return /*#__PURE__*/ createElement($a093c7e1ec25a057$var$PortalProvider, {
        scope: __scopeTooltip,
        forceMount: forceMount
    }, /*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
    }, /*#__PURE__*/ createElement($f1701beae083dbae$export$602eac185826482c, {
        asChild: true,
        container: container
    }, children)));
};
/* -------------------------------------------------------------------------------------------------
 * TooltipContent
 * -----------------------------------------------------------------------------------------------*/ const $a093c7e1ec25a057$var$CONTENT_NAME = 'TooltipContent';
const $a093c7e1ec25a057$export$e9003e2be37ec060 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const portalContext = $a093c7e1ec25a057$var$usePortalContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
    const { forceMount: forceMount = portalContext.forceMount , side: side = 'top' , ...contentProps } = props;
    const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
    return /*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
    }, context.disableHoverableContent ? /*#__PURE__*/ createElement($a093c7e1ec25a057$var$TooltipContentImpl, _extends$2({
        side: side
    }, contentProps, {
        ref: forwardedRef
    })) : /*#__PURE__*/ createElement($a093c7e1ec25a057$var$TooltipContentHoverable, _extends$2({
        side: side
    }, contentProps, {
        ref: forwardedRef
    })));
});
const $a093c7e1ec25a057$var$TooltipContentHoverable = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
    const providerContext = $a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$CONTENT_NAME, props.__scopeTooltip);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const [pointerGraceArea, setPointerGraceArea] = useState$1(null);
    const { trigger: trigger , onClose: onClose  } = context;
    const content = ref.current;
    const { onPointerInTransitChange: onPointerInTransitChange  } = providerContext;
    const handleRemoveGraceArea = useCallback(()=>{
        setPointerGraceArea(null);
        onPointerInTransitChange(false);
    }, [
        onPointerInTransitChange
    ]);
    const handleCreateGraceArea = useCallback((event, hoverTarget)=>{
        const currentTarget = event.currentTarget;
        const exitPoint = {
            x: event.clientX,
            y: event.clientY
        };
        const exitSide = $a093c7e1ec25a057$var$getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
        const bleed = exitSide === 'right' || exitSide === 'bottom' ? -5 : 5;
        const isXAxis = exitSide === 'right' || exitSide === 'left';
        const startPoint = isXAxis ? {
            x: event.clientX + bleed,
            y: event.clientY
        } : {
            x: event.clientX,
            y: event.clientY + bleed
        };
        const hoverTargetPoints = $a093c7e1ec25a057$var$getPointsFromRect(hoverTarget.getBoundingClientRect());
        const graceArea = $a093c7e1ec25a057$var$getHull([
            startPoint,
            ...hoverTargetPoints
        ]);
        setPointerGraceArea(graceArea);
        onPointerInTransitChange(true);
    }, [
        onPointerInTransitChange
    ]);
    useEffect$1(()=>{
        return ()=>handleRemoveGraceArea()
        ;
    }, [
        handleRemoveGraceArea
    ]);
    useEffect$1(()=>{
        if (trigger && content) {
            const handleTriggerLeave = (event)=>handleCreateGraceArea(event, content)
            ;
            const handleContentLeave = (event)=>handleCreateGraceArea(event, trigger)
            ;
            trigger.addEventListener('pointerleave', handleTriggerLeave);
            content.addEventListener('pointerleave', handleContentLeave);
            return ()=>{
                trigger.removeEventListener('pointerleave', handleTriggerLeave);
                content.removeEventListener('pointerleave', handleContentLeave);
            };
        }
    }, [
        trigger,
        content,
        handleCreateGraceArea,
        handleRemoveGraceArea
    ]);
    useEffect$1(()=>{
        if (pointerGraceArea) {
            const handleTrackPointerGrace = (event)=>{
                const target = event.target;
                const pointerPosition = {
                    x: event.clientX,
                    y: event.clientY
                };
                const hasEnteredTarget = (trigger === null || trigger === void 0 ? void 0 : trigger.contains(target)) || (content === null || content === void 0 ? void 0 : content.contains(target));
                const isPointerOutsideGraceArea = !$a093c7e1ec25a057$var$isPointInPolygon(pointerPosition, pointerGraceArea);
                if (hasEnteredTarget) handleRemoveGraceArea();
                else if (isPointerOutsideGraceArea) {
                    handleRemoveGraceArea();
                    onClose();
                }
            };
            document.addEventListener('pointermove', handleTrackPointerGrace);
            return ()=>document.removeEventListener('pointermove', handleTrackPointerGrace)
            ;
        }
    }, [
        trigger,
        content,
        pointerGraceArea,
        onClose,
        handleRemoveGraceArea
    ]);
    return /*#__PURE__*/ createElement($a093c7e1ec25a057$var$TooltipContentImpl, _extends$2({}, props, {
        ref: composedRefs
    }));
});
const [$a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, $a093c7e1ec25a057$var$useVisuallyHiddenContentContext] = $a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME, {
    isInside: false
});
const $a093c7e1ec25a057$var$TooltipContentImpl = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeTooltip: __scopeTooltip , children: children , 'aria-label': ariaLabel , onEscapeKeyDown: onEscapeKeyDown , onPointerDownOutside: onPointerDownOutside , ...contentProps } = props;
    const context = $a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME, __scopeTooltip);
    const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
    const { onClose: onClose  } = context; // Close this tooltip if another one opens
    useEffect$1(()=>{
        document.addEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose);
        return ()=>document.removeEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN, onClose)
        ;
    }, [
        onClose
    ]); // Close the tooltip if the trigger is scrolled
    useEffect$1(()=>{
        if (context.trigger) {
            const handleScroll = (event)=>{
                const target = event.target;
                if (target !== null && target !== void 0 && target.contains(context.trigger)) onClose();
            };
            window.addEventListener('scroll', handleScroll, {
                capture: true
            });
            return ()=>window.removeEventListener('scroll', handleScroll, {
                    capture: true
                })
            ;
        }
    }, [
        context.trigger,
        onClose
    ]);
    return /*#__PURE__*/ createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown: onEscapeKeyDown,
        onPointerDownOutside: onPointerDownOutside,
        onFocusOutside: (event)=>event.preventDefault()
        ,
        onDismiss: onClose
    }, /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends$2({
        "data-state": context.stateAttribute
    }, popperScope, contentProps, {
        ref: forwardedRef,
        style: {
            ...contentProps.style,
            // re-namespace exposed content custom property
            ['--radix-tooltip-content-transform-origin']: 'var(--radix-popper-transform-origin)'
        }
    }), /*#__PURE__*/ createElement($5e63c961fc1ce211$export$d9f1ccf0bdb05d45, null, children), /*#__PURE__*/ createElement($a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider, {
        scope: __scopeTooltip,
        isInside: true
    }, /*#__PURE__*/ createElement($ea1ef594cf570d83$export$be92b6f5f03c0fe9, {
        id: context.contentId,
        role: "tooltip"
    }, ariaLabel || children))));
});
/* -------------------------------------------------------------------------------------------------
 * TooltipArrow
 * -----------------------------------------------------------------------------------------------*/ const $a093c7e1ec25a057$var$ARROW_NAME = 'TooltipArrow';
const $a093c7e1ec25a057$export$c27ee0ad710f7559 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeTooltip: __scopeTooltip , ...arrowProps } = props;
    const popperScope = $a093c7e1ec25a057$var$usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = $a093c7e1ec25a057$var$useVisuallyHiddenContentContext($a093c7e1ec25a057$var$ARROW_NAME, __scopeTooltip); // if the arrow is inside the `VisuallyHidden`, we don't want to render it all to
    // prevent issues in positioning the arrow due to the duplicate
    return visuallyHiddenContentContext.isInside ? null : /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends$2({}, popperScope, arrowProps, {
        ref: forwardedRef
    }));
});
/* -----------------------------------------------------------------------------------------------*/ function $a093c7e1ec25a057$var$getExitSideFromRect(point, rect) {
    const top = Math.abs(rect.top - point.y);
    const bottom = Math.abs(rect.bottom - point.y);
    const right = Math.abs(rect.right - point.x);
    const left = Math.abs(rect.left - point.x);
    switch(Math.min(top, bottom, right, left)){
        case left:
            return 'left';
        case right:
            return 'right';
        case top:
            return 'top';
        case bottom:
            return 'bottom';
        default:
            return null;
    }
}
function $a093c7e1ec25a057$var$getPointsFromRect(rect) {
    const { top: top , right: right , bottom: bottom , left: left  } = rect;
    return [
        {
            x: left,
            y: top
        },
        {
            x: right,
            y: top
        },
        {
            x: right,
            y: bottom
        },
        {
            x: left,
            y: bottom
        }
    ];
} // Determine if a point is inside of a polygon.
// Based on https://github.com/substack/point-in-polygon
function $a093c7e1ec25a057$var$isPointInPolygon(point, polygon) {
    const { x: x , y: y  } = point;
    let inside = false;
    for(let i = 0, j = polygon.length - 1; i < polygon.length; j = i++){
        const xi = polygon[i].x;
        const yi = polygon[i].y;
        const xj = polygon[j].x;
        const yj = polygon[j].y; // prettier-ignore
        const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
    }
    return inside;
} // Returns a new array of points representing the convex hull of the given set of points.
// https://www.nayuki.io/page/convex-hull-algorithm
function $a093c7e1ec25a057$var$getHull(points) {
    const newPoints = points.slice();
    newPoints.sort((a, b)=>{
        if (a.x < b.x) return -1;
        else if (a.x > b.x) return 1;
        else if (a.y < b.y) return -1;
        else if (a.y > b.y) return 1;
        else return 0;
    });
    return $a093c7e1ec25a057$var$getHullPresorted(newPoints);
} // Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.
function $a093c7e1ec25a057$var$getHullPresorted(points) {
    if (points.length <= 1) return points.slice();
    const upperHull = [];
    for(let i = 0; i < points.length; i++){
        const p = points[i];
        while(upperHull.length >= 2){
            const q = upperHull[upperHull.length - 1];
            const r = upperHull[upperHull.length - 2];
            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();
            else break;
        }
        upperHull.push(p);
    }
    upperHull.pop();
    const lowerHull = [];
    for(let i1 = points.length - 1; i1 >= 0; i1--){
        const p = points[i1];
        while(lowerHull.length >= 2){
            const q = lowerHull[lowerHull.length - 1];
            const r = lowerHull[lowerHull.length - 2];
            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();
            else break;
        }
        lowerHull.push(p);
    }
    lowerHull.pop();
    if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) return upperHull;
    else return upperHull.concat(lowerHull);
}
const $a093c7e1ec25a057$export$2881499e37b75b9a = $a093c7e1ec25a057$export$f78649fb9ca566b8;
const $a093c7e1ec25a057$export$be92b6f5f03c0fe9 = $a093c7e1ec25a057$export$28c660c63b792dea;
const $a093c7e1ec25a057$export$41fb9f06171c75f4 = $a093c7e1ec25a057$export$8c610744efcf8a1d;
const $a093c7e1ec25a057$export$602eac185826482c = $a093c7e1ec25a057$export$7b36b8f925ab7497;
const $a093c7e1ec25a057$export$7c6e2c02157bb7d2 = $a093c7e1ec25a057$export$e9003e2be37ec060;
const $a093c7e1ec25a057$export$21b07c8f274aebd5 = $a093c7e1ec25a057$export$c27ee0ad710f7559;

const fadeIn = keyframes`
  from{
    opacity: 0
  }
  to {
    opacity: 1
  }
`;
keyframes`
from{
    opacity: 1
  }
  to {
    opactity: 0
  }
`;

const TooltipProvider = $a093c7e1ec25a057$export$2881499e37b75b9a;
const TooltipRoot = $a093c7e1ec25a057$export$be92b6f5f03c0fe9;
const TooltipPortal = $a093c7e1ec25a057$export$602eac185826482c;
const TooltipTrigger = styled($a093c7e1ec25a057$export$41fb9f06171c75f4)`
  background-color: transparent;
  border: none;
  padding: 0;
  svg {
    color: ${({ theme }) => theme.primary};
  }
`;
const TooltipArrow = styled($a093c7e1ec25a057$export$21b07c8f274aebd5)`
  fill: ${({ theme }) => theme.tooltip.bg};
`;
const TooltipContent = styled($a093c7e1ec25a057$export$7c6e2c02157bb7d2)`
  background-color: ${({ theme }) => theme.tooltip.bg};
  border-radius: ${border.radius};
  color: ${({ theme }) => theme.fontColor};
  font-size: ${font.size.md};
  line-height: 2.4rem;
  max-width: 30rem;
  padding: 1.2rem 1.5rem;

  &[data-state='delayed-open'] {
    animation: ${fadeIn} 0.15s ease-in forwards;
  }
`;

const SmTooltipIcon = () => /* @__PURE__ */ jsx(RiErrorWarningLine, {
  size: "1.4rem"
});
const LgTooltipIcon = () => /* @__PURE__ */ jsx(RiErrorWarningLine, {
  size: "2rem"
});

const Tooltip = ({
  content = "Content goes here",
  side = "right",
  triggerEl = /* @__PURE__ */ jsx(SmTooltipIcon, {}),
  offset = 18,
  delay = 400,
  triggerAsChild = false
}) => {
  const [open, setOpen] = useState$1(false);
  const [stayOpen, setStayOpen] = useState$1(false);
  const handleClickOpen = () => {
    setOpen(true);
    setStayOpen(true);
  };
  const handleClickOutside = () => {
    setOpen(false);
    setStayOpen(false);
  };
  return /* @__PURE__ */ jsx(TooltipProvider, {
    delayDuration: delay,
    children: /* @__PURE__ */ jsxs(TooltipRoot, {
      open: open || stayOpen,
      onOpenChange: setOpen,
      children: [/* @__PURE__ */ jsx(TooltipTrigger, {
        onClick: handleClickOpen,
        asChild: triggerAsChild,
        children: triggerEl
      }), /* @__PURE__ */ jsx(TooltipPortal, {
        children: /* @__PURE__ */ jsxs(TooltipContent, {
          side,
          sideOffset: offset,
          onEscapeKeyDown: handleClickOutside,
          onPointerDownOutside: handleClickOutside,
          children: [content, /* @__PURE__ */ jsx(TooltipArrow, {})]
        })
      })]
    })
  });
};

/**
 * @remix-run/router v1.0.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * Actions represent the type of change to a location value.
 */
var Action;

(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */

  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */

  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */

function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */

function parsePath(path) {
  let parsedPath = {};

  if (path) {
    let hashIndex = path.indexOf("#");

    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }

    let searchIndex = path.indexOf("?");

    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }

    if (path) {
      parsedPath.pathname = path;
    }
  }

  return parsedPath;
}

var ResultType;

(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {})); // Walk the route tree generating unique IDs where necessary so we are working
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/docs/en/v6/utils/resolve-path
 */

function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }

  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}

function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
/**
 * @private
 */


function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }

  let to = typeof toArg === "string" ? parsePath(toArg) : _extends$1({}, toArg);
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from; // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;

    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }

      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.


    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }

  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");

  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }

  return path;
}
/**
 * @private
 */

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

/**
 * React Router v6.4.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function isPolyfill(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

const is = typeof Object.is === "function" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic
// dispatch for CommonJS interop named imports.

const {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = React;
// because of a very particular set of implementation details and assumptions
// -- change any one of them and it will break. The most important assumption
// is that updates are always synchronous, because concurrent rendering is
// only available in versions of React that also have a built-in
// useSyncExternalStore API. And we only use this shim when the built-in API
// does not exist.
//
// Do not assume that the clever hacks used by this hook also work in general.
// The point of this shim is to replace the need for hacks by other libraries.

function useSyncExternalStore$2(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of
// React do not expose a way to check if we're hydrating. So users of the shim
// will need to track that themselves and return the correct value
// from `getSnapshot`.
getServerSnapshot) {
  // breaks the rules of React, and only works here because of specific
  // implementation details, most importantly that updates are
  // always synchronous.


  const value = getSnapshot();
  // re-render whenever the subscribed state changes by updating an some
  // arbitrary useState hook. Then, during render, we call getSnapshot to read
  // the current value.
  //
  // Because we don't actually use the state returned by the useState hook, we
  // can save a bit of memory by storing other stuff in that slot.
  //
  // To implement the early bailout, we need to track some things on a mutable
  // object. Usually, we would put that in a useRef hook, but we can stash it in
  // our useState hook instead.
  //
  // To force a re-render, we call forceUpdate({inst}). That works because the
  // new object always fails an equality check.


  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  }); // Track the latest getSnapshot function with a ref. This needs to be updated
  // in the layout phase so we can access it during the tearing check that
  // happens on subscribe.

  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
    // commit phase if there was an interleaved mutation. In concurrent mode
    // this can happen all the time, but even in synchronous mode, an earlier
    // effect may have mutated the store.

    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [subscribe, value, getSnapshot]);
  useEffect(() => {
    // Check for changes right before subscribing. Subsequent changes will be
    // detected in the subscription handler.
    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    }

    const handleStoreChange = () => {
      // TODO: Because there is no cross-renderer API for batching updates, it's
      // up to the consumer of this library to wrap their subscription event
      // with unstable_batchedUpdates. Should we try to detect when this isn't
      // the case and print a warning in development?
      // The store changed. Check if the snapshot changed since the last time we
      // read from the store.
      if (checkIfSnapshotChanged(inst)) {
        // Force a re-render.
        forceUpdate({
          inst
        });
      }
    }; // Subscribe to the store and return a clean-up function.


    return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [subscribe]);
  useDebugValue(value);
  return value;
}

function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;

  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  // React do not expose a way to check if we're hydrating. So users of the shim
  // will need to track that themselves and return the correct value
  // from `getSnapshot`.
  return getSnapshot();
}

/**
 * Inlined into the react-router repo since use-sync-external-store does not
 * provide a UMD-compatible package, so we need this to be able to distribute
 * UMD react-router bundles
 */
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React ? (module => module.useSyncExternalStore)(React) : shim;

const NavigationContext = /*#__PURE__*/React.createContext(null);

const LocationContext = /*#__PURE__*/React.createContext(null);

const RouteContext = /*#__PURE__*/React.createContext({
  outlet: null,
  matches: []
});

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-href
 */

function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator
  } = React.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior
  // to creating the href.  If this is a root navigation, then just use the raw
  // basename which allows the basename to have full control over the presence
  // of a trailing slash on root links

  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }

  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-in-router-context
 */

function useInRouterContext() {
  return React.useContext(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-location
 */

function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return React.useContext(LocationContext).location;
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || !match.route.index && match.pathnameBase !== matches[index - 1].pathnameBase);
}
/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-navigate
 */


function useNavigate() {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator
  } = React.useContext(NavigationContext);
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(match => match.pathnameBase));
  let activeRef = React.useRef(false);
  React.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = React.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;

    if (typeof to === "number") {
      navigator.go(to);
      return;
    }

    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path"); // If we're operating within a basename, prepend it to the pathname prior
    // to handing off to history.  If this is a root navigation, then we
    // navigate to the raw basename which allows the basename to have full
    // control over the presence of a trailing slash on root links

    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }

    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-resolved-path
 */

function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(match => match.pathnameBase));
  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
var DataRouterHook;

(function (DataRouterHook) {
  DataRouterHook["UseLoaderData"] = "useLoaderData";
  DataRouterHook["UseActionData"] = "useActionData";
  DataRouterHook["UseRouteError"] = "useRouteError";
  DataRouterHook["UseNavigation"] = "useNavigation";
  DataRouterHook["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterHook["UseMatches"] = "useMatches";
  DataRouterHook["UseRevalidator"] = "useRevalidator";
})(DataRouterHook || (DataRouterHook = {}));
var AwaitRenderStatus;

(function (AwaitRenderStatus) {
  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));

new Promise(() => {});

/**
 * React Router DOM v6.4.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

function shouldProcessLinkClick(event, target) {
  return event.button === 0 && ( // Ignore everything but left clicks
  !target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event) // Ignore clicks with modifier keys
  ;
}

const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
/**
 * The public API for rendering a history-aware <a>.
 */

const Link$1 = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4,
      rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });

  function handleClick(event) {
    if (onClick) onClick(event);

    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }

  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    React.createElement("a", _extends({}, rest, {
      href: href,
      onClick: reloadDocument ? onClick : handleClick,
      ref: ref,
      target: target
    }))
  );
});
////////////////////////////////////////////////////////////////////////////////
//#region Hooks
////////////////////////////////////////////////////////////////////////////////

/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */


function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return React.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here unless the replace prop is explicitly set

      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}

const LinkStyles = css`
  align-items: center;
  color: ${({ theme }) => theme.link.color};
  cursor: pointer;
  display: inline-flex;
  font-family: ${font.family.body};
  font-weight: ${font.weight.reg};
  font-size: ${font.size.md};
  text-decoration: none;
  letter-spacing: 1.5px;
  :hover {
    text-decoration: underline;
  }

  .icon-left {
    width: 25px;
    margin-right: 0.5rem;
  }

  svg {
    margin-left: 0.3rem;
  }
  &.button-link {
    :hover {
      text-decoration: none;
    }
  }
`;
const ExternalLink = styled.a`
  ${LinkStyles}
`;
const InternalLink = styled(Link$1)`
  ${LinkStyles}
`;

const Link = React__default.forwardRef(({
  href = "/",
  target = "_blank",
  linkType = "internal",
  selected,
  disabled,
  Icon,
  LeftIcon,
  className,
  children
}, ref) => {
  const classes = classNames({
    selected,
    disabled
  });
  if (linkType === "external" || linkType === "no-icon-external") {
    return /* @__PURE__ */ jsxs(ExternalLink, {
      href,
      className: `${classes} ${className}`,
      target,
      ref,
      children: [LeftIcon && /* @__PURE__ */ jsx(LeftIcon, {
        className: "icon-left"
      }), children, linkType === "external" ? Icon ? /* @__PURE__ */ jsx(Icon, {}) : /* @__PURE__ */ jsx(RiExternalLinkLine, {}) : null]
    });
  }
  return /* @__PURE__ */ jsxs(InternalLink, {
    to: href,
    className: `${classes} ${className}`,
    ref,
    children: [children, Icon && /* @__PURE__ */ jsx(Icon, {})]
  });
});

const WithIcon = styled.div`
  position: relative;
  width: 100%;
  max-width: ${field.size.md};

  svg {
    position: absolute;
    color: ${({ theme }) => theme.select.text};
    top: 1.4rem;
    right: 2rem;
    pointer-events: none;
  }

  &.long {
    max-width: ${field.size.lg};
  }

  &.full {
    max-width: ${field.size.full};
  }

  &.warning {
    border: 1px solid ${({ theme }) => theme.warning};
  }

  &.error {
    border: 1px solid ${({ theme }) => theme.error};
  }
`;
const BaseSelect = styled.select`
  align-items: center;
  appearance: none;
  background-color: ${({ theme }) => theme.select.bg};
  border: 1px ${({ theme }) => theme.select.borderColor} solid;
  border-radius: ${field.borderRadius};
  color: ${({ theme }) => theme.select.text};
  display: inline-flex;
  font-size: ${field.fontSize};
  font-weight: ${field.fontWeight};
  font-family: ${field.fontFamily};
  height: 4.8rem;
  justify-content: space-between;
  line-height: 150%;
  max-width: ${field.size.md};
  padding: 0 1.8rem;
  transition: ${field.transition};
  width: 100%;

  &.long {
    max-width: ${field.size.lg};
  }
  &.full {
    max-width: ${field.size.full};
  }
  &.warning {
    border: 1px solid ${({ theme }) => theme.warning};
  }

  &.error {
    border: 1px solid ${({ theme }) => theme.error};
  }

  :hover {
    background-color: ${({ theme }) => theme.field.hoverBg};
    border: 1px solid
      ${({ theme }) => theme.field.hoverBorder};
  }

  :focus {
    background-color: ${({ theme }) => theme.field.focusBg};
    border: 1px solid
      ${({ theme }) => theme.field.focusBorder};
    outline: none;
  }

  :disabled {
    background-color: ${({ theme }) => theme.field.disabledBg};
    color: ${({ theme }) => theme.field.disabledColor};
    cursor: not-allowed;
    font-style: italic;

    ::placeholder {
      color: ${({ theme }) => theme.field.disabledPlaceholder};
    }
  }
`;
const StyledOption = styled.option`
  background-color: ${({ theme }) => theme.select.bg};
  color: ${({ theme }) => theme.select.text};
  font-family: ${field.fontFamily};
  font-size: ${field.fontSize};
  font-weight: ${field.fontWeight};
  height: 4.8rem;
`;

const Select = forwardRef(({
  options,
  defaultValue,
  long,
  full,
  placeholder,
  disabled,
  error,
  warning,
  className,
  containerClassName,
  ...props
}, ref) => {
  const theme = useTheme();
  const wrapperClasses = classNames({
    long,
    full
  });
  const classes = classNames({
    long,
    full,
    error,
    warning
  });
  return /* @__PURE__ */ jsxs(WithIcon, {
    className: `${containerClassName} ${wrapperClasses}`,
    children: [/* @__PURE__ */ jsxs(BaseSelect, {
      ...props,
      ref,
      className: `${className} ${classes}`,
      defaultValue,
      disabled,
      children: [placeholder && /* @__PURE__ */ jsx(StyledOption, {
        value: "",
        children: placeholder
      }), options?.map((option) => /* @__PURE__ */ jsx(StyledOption, {
        value: option.value,
        children: option.name
      }, option.key || option.value))]
    }), /* @__PURE__ */ jsx(RiArrowDropDownLine, {
      size: "2rem",
      color: disabled ? theme.field.disabledColor : theme.select.text
    })]
  });
});

const StyledSpinner = styled.div`
  &.loader,
  &.loader:after {
    border-radius: 50%;
    width: 100%;
    height: 100%;
  }
  &.loader {
    font-size: 1rem;
    position: relative;
    text-indent: -9999em;
    border-top: ${(props) => `${props.strokeWidth} solid ${props.bottomColor}`};
    border-right: ${(props) => `${props.strokeWidth} solid ${props.bottomColor}`};
    border-bottom: ${(props) => `${props.strokeWidth} solid ${props.bottomColor}`};
    border-left: ${(props) => `${props.strokeWidth} solid ${props.topColor}`};
    -webkit-transform: translateZ(0);
    -ms-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-animation: load8 ${(props) => props.speed} infinite
      linear;
    animation: load8 ${(props) => props.speed} infinite linear;
  }
  @-webkit-keyframes load8 {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
  @keyframes load8 {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
`;
const Container$2 = styled.div`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: ${(props) => props.size};
  height: ${(props) => props.size};
  margin: ${(props) => props.margin};
  padding: ${(props) => props.padding};
`;
const Spinner = ({
  topColor,
  bottomColor,
  size = "4rem",
  margin = "0",
  padding = "0",
  strokeWidth = ".5rem",
  speed = "1.1s"
}) => {
  const theme = useTheme();
  return /* @__PURE__ */ jsx(Container$2, {
    size,
    margin,
    padding,
    children: /* @__PURE__ */ jsx(StyledSpinner, {
      topColor: topColor || theme.spinner.topColor,
      bottomColor: bottomColor || theme.spinner.bottomColor,
      size,
      className: "loader",
      strokeWidth,
      speed
    })
  });
};

const $89eedd556c436f6a$var$DEFAULT_ORIENTATION = 'horizontal';
const $89eedd556c436f6a$var$ORIENTATIONS = [
    'horizontal',
    'vertical'
];
const $89eedd556c436f6a$export$1ff3c3f08ae963c0 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { decorative: decorative , orientation: orientationProp = $89eedd556c436f6a$var$DEFAULT_ORIENTATION , ...domProps } = props;
    const orientation = $89eedd556c436f6a$var$isValidOrientation(orientationProp) ? orientationProp : $89eedd556c436f6a$var$DEFAULT_ORIENTATION; // `aria-orientation` defaults to `horizontal` so we only need it if `orientation` is vertical
    const ariaOrientation = orientation === 'vertical' ? orientation : undefined;
    const semanticProps = decorative ? {
        role: 'none'
    } : {
        'aria-orientation': ariaOrientation,
        role: 'separator'
    };
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
        "data-orientation": orientation
    }, semanticProps, domProps, {
        ref: forwardedRef
    }));
});
$89eedd556c436f6a$export$1ff3c3f08ae963c0.propTypes = {
    orientation (props, propName, componentName) {
        const propValue = props[propName];
        const strVal = String(propValue);
        if (propValue && !$89eedd556c436f6a$var$isValidOrientation(propValue)) return new Error($89eedd556c436f6a$var$getInvalidOrientationError(strVal, componentName));
        return null;
    }
};
/* -----------------------------------------------------------------------------------------------*/ // Split this out for clearer readability of the error message.
function $89eedd556c436f6a$var$getInvalidOrientationError(value, componentName) {
    return `Invalid prop \`orientation\` of value \`${value}\` supplied to \`${componentName}\`, expected one of:
  - horizontal
  - vertical

Defaulting to \`${$89eedd556c436f6a$var$DEFAULT_ORIENTATION}\`.`;
}
function $89eedd556c436f6a$var$isValidOrientation(orientation) {
    return $89eedd556c436f6a$var$ORIENTATIONS.includes(orientation);
}
const $89eedd556c436f6a$export$be92b6f5f03c0fe9 = $89eedd556c436f6a$export$1ff3c3f08ae963c0;

const StyledDivider = styled($89eedd556c436f6a$export$be92b6f5f03c0fe9)`
  background-color: ${(props) => props.color || slate$1.slate6};
  margin: ${(props) => props.margin};
  &[data-orientation='horizontal'] {
    height: 0.1rem;
    width: 100%;
  }
  &[data-orientation='vertical'] {
    height: 100%;
    width: 0.1rem;
  }
`;
const Divider = ({
  orientation = "horizontal",
  decorative = false,
  asChild = false,
  margin = "0rem",
  className,
  color
}) => {
  return /* @__PURE__ */ jsx(StyledDivider, {
    margin,
    orientation,
    decorative,
    asChild,
    className,
    color
  });
};

/* -------------------------------------------------------------------------------------------------
 * Switch
 * -----------------------------------------------------------------------------------------------*/ const $6be4966fd9bbc698$var$SWITCH_NAME = 'Switch';
const [$6be4966fd9bbc698$var$createSwitchContext, $6be4966fd9bbc698$export$cf7f5f17f69cbd43] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6be4966fd9bbc698$var$SWITCH_NAME);
const [$6be4966fd9bbc698$var$SwitchProvider, $6be4966fd9bbc698$var$useSwitchContext] = $6be4966fd9bbc698$var$createSwitchContext($6be4966fd9bbc698$var$SWITCH_NAME);
const $6be4966fd9bbc698$export$b5d5cf8927ab7262 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeSwitch: __scopeSwitch , 'aria-labelledby': ariaLabelledby , name: name , checked: checkedProp , defaultChecked: defaultChecked , required: required , disabled: disabled , value: value = 'on' , onCheckedChange: onCheckedChange , ...switchProps } = props;
    const [button, setButton] = useState$1(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node)=>setButton(node)
    );
    const labelId = $b73a6c6685e72184$export$feddbbf47baabdb9(button);
    const labelledBy = ariaLabelledby || labelId;
    const hasConsumerStoppedPropagationRef = useRef(false); // We set this to true by default so that events bubble to forms without JS (SSR)
    const isFormControl = button ? Boolean(button.closest('form')) : true;
    const [checked = false, setChecked] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: checkedProp,
        defaultProp: defaultChecked,
        onChange: onCheckedChange
    });
    return /*#__PURE__*/ createElement($6be4966fd9bbc698$var$SwitchProvider, {
        scope: __scopeSwitch,
        checked: checked,
        disabled: disabled
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
        type: "button",
        role: "switch",
        "aria-checked": checked,
        "aria-labelledby": labelledBy,
        "aria-required": required,
        "data-state": $6be4966fd9bbc698$var$getState(checked),
        "data-disabled": disabled ? '' : undefined,
        disabled: disabled,
        value: value
    }, switchProps, {
        ref: composedRefs,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, (event)=>{
            setChecked((prevChecked)=>!prevChecked
            );
            if (isFormControl) {
                hasConsumerStoppedPropagationRef.current = event.isPropagationStopped(); // if switch is in a form, stop propagation from the button so that we only propagate
                // one click event (from the input). We propagate changes from an input so that native
                // form validation works and form events reflect switch updates.
                if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
        })
    })), isFormControl && /*#__PURE__*/ createElement($6be4966fd9bbc698$var$BubbleInput, {
        control: button,
        bubbles: !hasConsumerStoppedPropagationRef.current,
        name: name,
        value: value,
        checked: checked,
        required: required,
        disabled: disabled // We transform because the input is absolutely positioned but we have
        ,
        style: {
            transform: 'translateX(-100%)'
        }
    }));
});
/* -------------------------------------------------------------------------------------------------
 * SwitchThumb
 * -----------------------------------------------------------------------------------------------*/ const $6be4966fd9bbc698$var$THUMB_NAME = 'SwitchThumb';
const $6be4966fd9bbc698$export$4d07bf653ea69106 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeSwitch: __scopeSwitch , ...thumbProps } = props;
    const context = $6be4966fd9bbc698$var$useSwitchContext($6be4966fd9bbc698$var$THUMB_NAME, __scopeSwitch);
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({
        "data-state": $6be4966fd9bbc698$var$getState(context.checked),
        "data-disabled": context.disabled ? '' : undefined
    }, thumbProps, {
        ref: forwardedRef
    }));
});
/* ---------------------------------------------------------------------------------------------- */ const $6be4966fd9bbc698$var$BubbleInput = (props)=>{
    const { control: control , checked: checked , bubbles: bubbles = true , ...inputProps } = props;
    const ref = useRef(null);
    const prevChecked = $010c2913dbd2fe3d$export$5cae361ad82dce8b(checked);
    const controlSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(control); // Bubble checked change to parents (e.g form change event)
    useEffect$1(()=>{
        const input = ref.current;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked');
        const setChecked = descriptor.set;
        if (prevChecked !== checked && setChecked) {
            const event = new Event('click', {
                bubbles: bubbles
            });
            setChecked.call(input, checked);
            input.dispatchEvent(event);
        }
    }, [
        prevChecked,
        checked,
        bubbles
    ]);
    return /*#__PURE__*/ createElement("input", _extends$2({
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: checked
    }, inputProps, {
        tabIndex: -1,
        ref: ref,
        style: {
            ...props.style,
            ...controlSize,
            position: 'absolute',
            pointerEvents: 'none',
            opacity: 0,
            margin: 0
        }
    }));
};
function $6be4966fd9bbc698$var$getState(checked) {
    return checked ? 'checked' : 'unchecked';
}
const $6be4966fd9bbc698$export$be92b6f5f03c0fe9 = $6be4966fd9bbc698$export$b5d5cf8927ab7262;
const $6be4966fd9bbc698$export$6521433ed15a34db = $6be4966fd9bbc698$export$4d07bf653ea69106;

const Container$1 = styled.div`
  align-items: center;
  display: flex;
  padding-top: 12px;
  padding-bottom: 12px;
`;
const SwitchBase = styled($6be4966fd9bbc698$export$be92b6f5f03c0fe9)`
  all: unset;
  background-color: ${({ theme }) => theme.switch.bar.bg};
  border-radius: 9999px;
  cursor: pointer;
  height: 16px;
  left: 9px;
  position: relative;
  width: 54px;

  &[data-disabled] {
    background-color: ${({ theme }) => theme.switch.bar.disabledBg};
    cursor: not-allowed;
  }

  &[data-state='checked'] {
    background-color: ${({ theme }) => theme.switch.bar.activeBg};

    &[data-disabled] {
      background-color: ${({ theme }) => theme.switch.bar.disabledBg};
      cursor: not-allowed;
    }
  }
`;
const SwitchSlider = styled($6be4966fd9bbc698$export$6521433ed15a34db)`
  background-color: ${({ theme }) => theme.switch.thumb.bg};
  border: 2px solid
    ${({ theme }) => theme.switch.thumb.border};
  border-radius: 9999px;
  height: 34px;
  position: absolute;
  top: -10px;
  transform: translateX(-9px);
  transition: transform 0.4s;
  width: 34px;
  will-change: transform;

  :hover {
    background-color: ${({ theme }) => theme.switch.thumb.hoverBg};
    border: 1px solid
      ${({ theme }) => theme.switch.thumb.hoverBorder};
  }

  :focus {
    background-color: ${({ theme }) => theme.switch.thumb.focusBg};
    border: 1px solid
      ${({ theme }) => theme.switch.thumb.focusBorder};
    outline: none;
  }

  &[data-disabled] {
    background-color: ${({ theme }) => theme.switch.thumb.disabledBg};
    border: 1px solid
      ${({ theme }) => theme.switch.thumb.disabledBorder};
    cursor: not-allowed;
  }

  &[data-state='checked'] {
    background-color: ${({ theme }) => theme.switch.thumb.activeBg};
    border: 2px solid
      ${({ theme }) => theme.switch.thumb.activeBorder};
    transform: translateX(27px);

    :hover {
      background-color: ${({ theme }) => theme.switch.thumb.activeHoverBg};
      border: 1px solid
        ${({ theme }) => theme.switch.thumb.activeHoverBorder};
    }

    :focus {
      background-color: ${({ theme }) => theme.switch.thumb.activeFocusBg};
      border: 1px solid
        ${({ theme }) => theme.switch.thumb.activeFocusBorder};
      outline: none;
    }

    &[data-disabled] {
      background-color: ${({ theme }) => theme.switch.thumb.activeDisabledBg};
      border: 1px solid
        ${({ theme }) => theme.switch.thumb.activeDisabledBorder};
      cursor: not-allowed;
    }
  }
`;
const LabelContainer$2 = styled.label`
  align-items: center;
  display: flex;
  margin-left: 28px;

  label {
    margin-right: 10px;
  }

  svg {
    transform: translateY(0.1rem);
  }
`;
const StyledLabel = styled.label`
  color: white;
  font-family: ${font.family.body};
  font-weight: ${font.weight.reg};
  font-size: ${font.size.md};

  &.disabled {
    color: ${({ theme }) => theme.switch.thumb.disabledBg};
  }
`;

const Label = ({
  children = "label",
  id,
  className
}) => {
  return /* @__PURE__ */ jsx(StyledLabel, {
    htmlFor: id,
    className,
    children
  });
};
const Switch = React__default.forwardRef((props, ref) => {
  const {
    fieldLabel,
    id,
    className,
    disabled,
    switchOn,
    defaultOn = false,
    onBlur,
    onChange,
    onCheckedChange
  } = props;
  const classes = classNames({
    disabled
  });
  return /* @__PURE__ */ jsxs(Container$1, {
    className,
    children: [/* @__PURE__ */ jsx(SwitchBase, {
      checked: switchOn,
      defaultChecked: defaultOn,
      onBlur,
      onChange,
      onCheckedChange,
      disabled,
      children: /* @__PURE__ */ jsx(SwitchSlider, {
        ref
      })
    }), /* @__PURE__ */ jsx(LabelContainer$2, {
      children: /* @__PURE__ */ jsx(Label, {
        id,
        className: classes,
        children: fieldLabel
      })
    })]
  });
});

const CardStyles = css`
  background-color: ${({ theme }) => theme.card.bg};
  border: 1px solid ${({ theme }) => theme.card.border};
  border-radius: ${border.cardRadius};
  padding: 2rem;
  /* min-width: 40rem; */

  width: ${({ width }) => width};
  max-width: 90vw;
`;
const BaseCard = styled.div`
  ${CardStyles}/* Disabling the interaction styles here as per our meeting in the component sync */
  /* Saving the styles here for when we want to make an interactive card */

  /*
  :hover {
    background-color: ${({ theme }) => theme.card.hoverBg};
    border: 1px solid ${({ theme }) => theme.card.hoverBorder};
  }

  :focus {
    background-color: ${({ theme }) => theme.card.focusBg};
    border: 1px solid ${({ theme }) => theme.card.focusBorder};
    outline: none;
  } */

  /* We might not need this */
  /* :disabled {
    background-color: ${({ theme }) => theme.card.disabledBg};
    border: 1px solid
      ${({ theme }) => theme.card.disabledBorder};
    cursor: not-allowed;
  } */
`;

const Card = ({
  className,
  width = "fit-content",
  children
}) => {
  return /* @__PURE__ */ jsx(BaseCard, {
    className,
    width,
    children
  });
};

const darkTagColors = {
  ...blue$1,
  ...violet$1,
  ...pink$1,
  ...green$1,
  ...yellow$1,
  ...red$1
};
const BaseTag = styled.div`
  display: inline-flex;
  align-items: center;
  background-color: ${({ tagColor }) => `${darkTagColors[`${tagColor}3`]}`};
  border: 1px solid ${({ tagColor }) => `${darkTagColors[`${tagColor}3`]}`};
  border-radius: ${border.radius};
  color: ${({ tagColor }) => `${darkTagColors[`${tagColor}11`]}`};
  min-height: 2.6rem;
  min-width: fit-content;
  padding: 0.2rem 0.5rem;

  :hover {
    background-color: ${({ tagColor }) => `${darkTagColors[`${tagColor}3`]}`};
    border: 1px solid ${({ tagColor }) => `${darkTagColors[`${tagColor}4`]}`};
  }

  :focus {
    background-color: ${({ tagColor }) => `${darkTagColors[`${tagColor}3`]}`};
    border: 1px solid ${({ tagColor }) => `${darkTagColors[`${tagColor}5`]}`};
    outline: none;
  }

  /* We might not need this */
  :disabled {
    background-color: ${({ theme }) => theme.card.disabledBg};
    border: 1px solid
      ${({ theme }) => theme.card.disabledBorder};
    cursor: not-allowed;
  }

  svg {
    width: 1.2rem;
    height: 1.2rem;
    color: ${({ tagColor }) => `${darkTagColors[`${tagColor}11`]}`};
  }

  svg.icon-left {
    margin-right: 1rem;
  }

  svg.icon-right {
    margin-left: 0.5rem;
  }
`;

const Tag = forwardRef(({
  className,
  children,
  tagColor,
  IconLeft,
  IconRight
}, ref) => {
  const iconClasses = classNames({
    tagColor
  });
  return /* @__PURE__ */ jsxs(BaseTag, {
    tagColor: tagColor || "green",
    className,
    children: [IconLeft && /* @__PURE__ */ jsx(IconLeft, {
      className: `${iconClasses} icon-left`
    }), children, IconRight && /* @__PURE__ */ jsx(IconRight, {
      className: `${iconClasses} icon-right`
    })]
  });
});

const ProgressVisualFull = styled.div`
  background-color: ${({ backgroundColor }) => backgroundColor};
  display: flex;
  height: 10px;
`;
const ProgressVisualPart = styled.div`
  width: ${(props) => props.width};
  background-color: ${({ backgroundColor }) => backgroundColor};
  /* Number of the seconds for complete animation */
  transition: width 2s;
`;

const Progress = ({
  backgroundColor,
  progressSection = [{
    percentage: "0%",
    color: "transparent"
  }]
}) => {
  const theme = useTheme();
  const [widths, setWidths] = useState$1(progressSection.map(() => {
    return "0%";
  }));
  useEffect$1(() => {
    requestAnimationFrame(() => {
      setWidths(progressSection.map((item) => {
        return item.percentage;
      }));
    });
  }, [progressSection]);
  return /* @__PURE__ */ jsx(ProgressVisualFull, {
    backgroundColor: backgroundColor || theme.progress.bg,
    children: progressSection.map((item, index) => {
      return /* @__PURE__ */ jsx(ProgressVisualPart, {
        width: widths[index],
        backgroundColor: item.color
      }, index);
    })
  });
};

const darkColors = {
  ...blue$1,
  ...violet$1,
  ...pink$1,
  ...green$1
};
const BaseBadge = styled.div`
  display: inline-flex;
  align-items: center;
  background-color: ${({ badgeColor }) => `${darkColors[`${badgeColor}6`]}`};
  border: 1px solid ${({ badgeColor }) => `${darkColors[`${badgeColor}3`]}`};
  border-radius: 2.1rem;
  justify-content: center;
  min-height: ${({ badgeSize }) => {
  return badgeSize === "sm" ? "2.4rem;" : "3.6rem;";
}};
  min-width: ${({ badgeSize }) => {
  return badgeSize === "sm" ? "3rem;" : "8.1rem;";
}};
  padding: ${({ badgeSize }) => {
  return badgeSize === "sm" ? "0.3rem 0.8rem;" : "0.6rem 1.6rem;";
}};

  font-size: ${({ badgeSize }) => badgeSize === "sm" ? "1.2rem;" : "1.6rem;"};
  color: ${({ badgeColor }) => `${darkColors[`${badgeColor}12`]}`};

  :hover {
    background-color: ${({ badgeColor }) => `${darkColors[`${badgeColor}7`]}`};
  }

  :focus {
    background-color: ${({ badgeColor }) => `${darkColors[`${badgeColor}6`]}`};
    border: 1px solid ${({ badgeColor }) => `${darkColors[`${badgeColor}8`]}`};
  }

  :disabled {
    background-color: ${({ badgeColor }) => `${darkColors[`${badgeColor}7`]}`};
    color: ${({ badgeColor }) => `${darkColors[`${badgeColor}9`]}`};
  }
`;

const Badge = forwardRef(({
  className,
  badgeLabel,
  badgeSize = "sm",
  badgeColor = "blue"
}, ref) => {
  return /* @__PURE__ */ jsxs(BaseBadge, {
    badgeColor,
    badgeSize,
    className,
    children: [badgeSize === "sm" && /* @__PURE__ */ jsx(ParXs, {
      children: /* @__PURE__ */ jsx(Bold, {
        children: badgeLabel
      })
    }), badgeSize === "lg" && /* @__PURE__ */ jsx(ParMd, {
      children: /* @__PURE__ */ jsx(Bold, {
        children: badgeLabel
      })
    })]
  });
});

const ENDPOINTS = {
  V3_SUBGRAPH: {
    "0x5": "https://api.thegraph.com/subgraphs/name/hausdao/daohaus-v3-goerli",
    "0x64": "https://api.thegraph.com/subgraphs/name/hausdao/daohaus-v3-gnosis"
  },
  EXPLORER: {
    "0x1": "https://etherscan.io",
    "0x5": "https://goerli.etherscan.io",
    "0x64": "https://blockscout.com/xdai/mainnet",
    "0xa": "https://optimistic.etherscan.io",
    "0x89": "https://polygonscan.com",
    "0xa4b1": "https://arbiscan.io/",
    "0xa4ec": "https://explorer.celo.org"
  },
  GNOSIS_API: {
    "0x1": "https://safe-transaction.gnosis.io/api/v1",
    "0x5": "https://safe-transaction.goerli.gnosis.io/api/v1",
    "0x64": "https://safe-transaction.xdai.gnosis.io/api/v1",
    "0xa": "https://safe-transaction.optimism.gnosis.io/api/v1",
    "0x89": "https://safe-transaction.polygon.gnosis.io/api/v1",
    "0xa4b1": "https://safe-transaction.arbitrum.gnosis.io/api/v1"
  },
  GAS_ESTIMATE: {
    "0x5": "https://safe-transaction.goerli.gnosis.io/api/v1/safes/<<safeId>>/multisig-transactions/estimations/",
    "0x64": "https://safe-transaction.xdai.gnosis.io/api/v1/safes/<<safeId>>/multisig-transactions/estimations/"
  },
  GNOSIS_SAFE_UI: {
    "0x1": "https://gnosis-safe.io/app/eth",
    "0x5": "https://gnosis-safe.io/app/gor",
    "0x64": "https://gnosis-safe.io/app/gno",
    "0xa": "https://gnosis-safe.io/app/opt",
    "0x89": "https://gnosis-safe.io/app/pol",
    "0xa4b1": "https://gnosis-safe.io/app/arb"
  },
  TABULA_GRAPH: {
    "0x5": "https://api.thegraph.com/subgraphs/name/auryn-macmillan/tabula-goerli"
  }
};

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
/**
 * Seconds in 1 hour
 *
 * @name secondsInHour
 * @constant
 * @type {number}
 * @default
 */

var secondsInHour = 3600;
/**
 * Seconds in 1 minute
 *
 * @name secondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var secondsInMinute = 60;

/**
 * @name hoursToSeconds
 * @category Conversion Helpers
 * @summary Convert hours to seconds.
 *
 * @description
 * Convert a number of hours to a full number of seconds.
 *
 * @param {number} hours - number of hours to be converted
 *
 * @returns {number} the number of hours converted in seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 hours to seconds:
 * const result = hoursToSeconds(2)
 * //=> 7200
 */

function hoursToSeconds(hours) {
  requiredArgs(1, arguments);
  return Math.floor(hours * secondsInHour);
}

/**
 * @name minutesToSeconds
 * @category Conversion Helpers
 * @summary Convert minutes to seconds.
 *
 * @description
 * Convert a number of minutes to a full number of seconds.
 *
 * @param { number } minutes - number of minutes to be converted
 *
 * @returns {number} the number of minutes converted in seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Convert 2 minutes to seconds
 * const result = minutesToSeconds(2)
 * //=> 120
 */

function minutesToSeconds(minutes) {
  requiredArgs(1, arguments);
  return Math.floor(minutes * secondsInMinute);
}

const generateExplorerLink = ({
  chainId,
  address,
  type = "address"
}) => `${ENDPOINTS["EXPLORER"][chainId]}/${type}/${address || ""}`;

const truncateAddress = (addr) => `${addr.slice(0, 6)}...${addr.slice(-4)}`;
const handlePluralNoun = (noun, count) => count === 1 ? noun.singular : noun.plural;

const isString$1 = (item) => typeof item === "string";
const isNumberString = (item) => isString$1(item) && !isNaN(parseFloat(item)) && isFinite(Number(item));

var numbro_min = {exports: {}};

(function (module, exports) {
!function(e){module.exports=e();}(function(){return function a(o,u,c){function s(t,e){if(!u[t]){if(!o[t]){var r="function"==typeof commonjsRequire&&commonjsRequire;if(!e&&r)return r(t,!0);if(l)return l(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=u[t]={exports:{}};o[t][0].call(i.exports,function(e){return s(o[t][1][e]||e)},i,i.exports,a,o,u,c);}return u[t].exports}for(var l="function"==typeof commonjsRequire&&commonjsRequire,e=0;e<c.length;e++)s(c[e]);return s}({1:[function(e,r,t){!function(e){var t,T=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,C="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator,U=Math.ceil,R=Math.floor,I="[BigNumber Error] ",$=I+"Number primitive has more than 15 significant digits: ",G=1e14,V=14,q=9007199254740991,Z=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],z=1e7,W=1e9;function H(e){var t=0|e;return 0<e||e===t?t:t-1}function Y(e){for(var t,r,n=1,i=e.length,a=e[0]+"";n<i;){for(t=e[n++]+"",r=V-t.length;r--;t="0"+t);a+=t;}for(i=a.length;48===a.charCodeAt(--i););return a.slice(0,i+1||1)}function K(e,t){var r,n,i=e.c,a=t.c,o=e.s,u=t.s,c=e.e,s=t.e;if(!o||!u)return null;if(r=i&&!i[0],n=a&&!a[0],r||n)return r?n?0:-u:o;if(o!=u)return o;if(r=o<0,n=c==s,!i||!a)return n?0:!i^r?1:-1;if(!n)return s<c^r?1:-1;for(u=(c=i.length)<(s=a.length)?c:s,o=0;o<u;o++)if(i[o]!=a[o])return i[o]>a[o]^r?1:-1;return c==s?0:s<c^r?1:-1}function J(e,t,r,n){if(e<t||r<e||e!==R(e))throw Error(I+(n||"Argument")+("number"==typeof e?e<t||r<e?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function X(e){var t=e.c.length-1;return H(e.e/V)==t&&e.c[t]%2!=0}function Q(e,t){return (1<e.length?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function ee(e,t,r){var n,i;if(t<0){for(i=r+".";++t;i+=r);e=i+e;}else if(++t>(n=e.length)){for(i=r,t-=n;--t;i+=r);e+=i;}else t<n&&(e=e.slice(0,t)+"."+e.slice(t));return e}(t=function e(t){var v,f,g,r,s,m,o,u,c,l,p,n=A.prototype={constructor:A,toString:null,valueOf:null},h=new A(1),y=20,b=4,d=-7,w=21,S=-1e7,O=1e7,x=!1,a=1,N=0,B={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:"Â ",suffix:""},M="0123456789abcdefghijklmnopqrstuvwxyz";function A(e,t){var r,n,i,a,o,u,c,s,l=this;if(!(l instanceof A))return new A(e,t);if(null==t){if(e&&!0===e._isBigNumber)return l.s=e.s,void(!e.c||e.e>O?l.c=l.e=null:e.e<S?l.c=[l.e=0]:(l.e=e.e,l.c=e.c.slice()));if((u="number"==typeof e)&&0*e==0){if(l.s=1/e<0?(e=-e,-1):1,e===~~e){for(a=0,o=e;10<=o;o/=10,a++);return void(O<a?l.c=l.e=null:(l.e=a,l.c=[e]))}s=String(e);}else {if(!T.test(s=String(e)))return g(l,s,u);l.s=45==s.charCodeAt(0)?(s=s.slice(1),-1):1;}-1<(a=s.indexOf("."))&&(s=s.replace(".","")),0<(o=s.search(/e/i))?(a<0&&(a=o),a+=+s.slice(o+1),s=s.substring(0,o)):a<0&&(a=s.length);}else {if(J(t,2,M.length,"Base"),10==t)return j(l=new A(e),y+l.e+1,b);if(s=String(e),u="number"==typeof e){if(0*e!=0)return g(l,s,u,t);if(l.s=1/e<0?(s=s.slice(1),-1):1,A.DEBUG&&15<s.replace(/^0\.0*|\./,"").length)throw Error($+e)}else l.s=45===s.charCodeAt(0)?(s=s.slice(1),-1):1;for(r=M.slice(0,t),a=o=0,c=s.length;o<c;o++)if(r.indexOf(n=s.charAt(o))<0){if("."==n){if(a<o){a=c;continue}}else if(!i&&(s==s.toUpperCase()&&(s=s.toLowerCase())||s==s.toLowerCase()&&(s=s.toUpperCase()))){i=!0,o=-1,a=0;continue}return g(l,String(e),u,t)}u=!1,-1<(a=(s=f(s,t,10,l.s)).indexOf("."))?s=s.replace(".",""):a=s.length;}for(o=0;48===s.charCodeAt(o);o++);for(c=s.length;48===s.charCodeAt(--c););if(s=s.slice(o,++c)){if(c-=o,u&&A.DEBUG&&15<c&&(q<e||e!==R(e)))throw Error($+l.s*e);if((a=a-o-1)>O)l.c=l.e=null;else if(a<S)l.c=[l.e=0];else {if(l.e=a,l.c=[],o=(a+1)%V,a<0&&(o+=V),o<c){for(o&&l.c.push(+s.slice(0,o)),c-=V;o<c;)l.c.push(+s.slice(o,o+=V));o=V-(s=s.slice(o)).length;}else o-=c;for(;o--;s+="0");l.c.push(+s);}}else l.c=[l.e=0];}function D(e,t,r,n){for(var i,a,o=[0],u=0,c=e.length;u<c;){for(a=o.length;a--;o[a]*=t);for(o[0]+=n.indexOf(e.charAt(u++)),i=0;i<o.length;i++)o[i]>r-1&&(null==o[i+1]&&(o[i+1]=0),o[i+1]+=o[i]/r|0,o[i]%=r);}return o.reverse()}function E(e,t,r){var n,i,a,o,u=0,c=e.length,s=t%z,l=t/z|0;for(e=e.slice();c--;)u=((i=s*(a=e[c]%z)+(n=l*a+(o=e[c]/z|0)*s)%z*z+u)/r|0)+(n/z|0)+l*o,e[c]=i%r;return u&&(e=[u].concat(e)),e}function F(e,t,r,n){var i,a;if(r!=n)a=n<r?1:-1;else for(i=a=0;i<r;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function k(e,t,r,n){for(var i=0;r--;)e[r]-=i,i=e[r]<t[r]?1:0,e[r]=i*n+e[r]-t[r];for(;!e[0]&&1<e.length;e.splice(0,1));}function i(e,t,r,n){var i,a,o,u,c;if(null==r?r=b:J(r,0,8),!e.c)return e.toString();if(i=e.c[0],o=e.e,null==t)c=Y(e.c),c=1==n||2==n&&(o<=d||w<=o)?Q(c,o):ee(c,o,"0");else if(a=(e=j(new A(e),t,r)).e,u=(c=Y(e.c)).length,1==n||2==n&&(t<=a||a<=d)){for(;u<t;c+="0",u++);c=Q(c,a);}else if(t-=o,c=ee(c,a,"0"),u<a+1){if(0<--t)for(c+=".";t--;c+="0");}else if(0<(t+=a-u))for(a+1==u&&(c+=".");t--;c+="0");return e.s<0&&i?"-"+c:c}function _(e,t){for(var r,n=1,i=new A(e[0]);n<e.length;n++){if(!(r=new A(e[n])).s){i=r;break}t.call(i,r)&&(i=r);}return i}function L(e,t,r){for(var n=1,i=t.length;!t[--i];t.pop());for(i=t[0];10<=i;i/=10,n++);return (r=n+r*V-1)>O?e.c=e.e=null:r<S?e.c=[e.e=0]:(e.e=r,e.c=t),e}function j(e,t,r,n){var i,a,o,u,c,s,l,f=e.c,g=Z;if(f){e:{for(i=1,u=f[0];10<=u;u/=10,i++);if((a=t-i)<0)a+=V,o=t,l=(c=f[s=0])/g[i-o-1]%10|0;else if((s=U((a+1)/V))>=f.length){if(!n)break e;for(;f.length<=s;f.push(0));c=l=0,o=(a%=V)-V+(i=1);}else {for(c=u=f[s],i=1;10<=u;u/=10,i++);l=(o=(a%=V)-V+i)<0?0:c/g[i-o-1]%10|0;}if(n=n||t<0||null!=f[s+1]||(o<0?c:c%g[i-o-1]),n=r<4?(l||n)&&(0==r||r==(e.s<0?3:2)):5<l||5==l&&(4==r||n||6==r&&(0<a?0<o?c/g[i-o]:0:f[s-1])%10&1||r==(e.s<0?8:7)),t<1||!f[0])return f.length=0,n?(t-=e.e+1,f[0]=g[(V-t%V)%V],e.e=-t||0):f[0]=e.e=0,e;if(0==a?(f.length=s,u=1,s--):(f.length=s+1,u=g[V-a],f[s]=0<o?R(c/g[i-o]%g[o])*u:0),n)for(;;){if(0==s){for(a=1,o=f[0];10<=o;o/=10,a++);for(o=f[0]+=u,u=1;10<=o;o/=10,u++);a!=u&&(e.e++,f[0]==G&&(f[0]=1));break}if(f[s]+=u,f[s]!=G)break;f[s--]=0,u=1;}for(a=f.length;0===f[--a];f.pop());}e.e>O?e.c=e.e=null:e.e<S&&(e.c=[e.e=0]);}return e}function P(e){var t,r=e.e;return null===r?e.toString():(t=Y(e.c),t=r<=d||w<=r?Q(t,r):ee(t,r,"0"),e.s<0?"-"+t:t)}return A.clone=e,A.ROUND_UP=0,A.ROUND_DOWN=1,A.ROUND_CEIL=2,A.ROUND_FLOOR=3,A.ROUND_HALF_UP=4,A.ROUND_HALF_DOWN=5,A.ROUND_HALF_EVEN=6,A.ROUND_HALF_CEIL=7,A.ROUND_HALF_FLOOR=8,A.EUCLID=9,A.config=A.set=function(e){var t,r;if(null!=e){if("object"!=typeof e)throw Error(I+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(J(r=e[t],0,W,t),y=r),e.hasOwnProperty(t="ROUNDING_MODE")&&(J(r=e[t],0,8,t),b=r),e.hasOwnProperty(t="EXPONENTIAL_AT")&&((r=e[t])&&r.pop?(J(r[0],-W,0,t),J(r[1],0,W,t),d=r[0],w=r[1]):(J(r,-W,W,t),d=-(w=r<0?-r:r))),e.hasOwnProperty(t="RANGE"))if((r=e[t])&&r.pop)J(r[0],-W,-1,t),J(r[1],1,W,t),S=r[0],O=r[1];else {if(J(r,-W,W,t),!r)throw Error(I+t+" cannot be zero: "+r);S=-(O=r<0?-r:r);}if(e.hasOwnProperty(t="CRYPTO")){if((r=e[t])!==!!r)throw Error(I+t+" not true or false: "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw x=!r,Error(I+"crypto unavailable");x=r;}else x=r;}if(e.hasOwnProperty(t="MODULO_MODE")&&(J(r=e[t],0,9,t),a=r),e.hasOwnProperty(t="POW_PRECISION")&&(J(r=e[t],0,W,t),N=r),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(r=e[t]))throw Error(I+t+" not an object: "+r);B=r;}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(r=e[t])||/^.$|[+-.\s]|(.).*\1/.test(r))throw Error(I+t+" invalid: "+r);M=r;}}return {DECIMAL_PLACES:y,ROUNDING_MODE:b,EXPONENTIAL_AT:[d,w],RANGE:[S,O],CRYPTO:x,MODULO_MODE:a,POW_PRECISION:N,FORMAT:B,ALPHABET:M}},A.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return !1;if(!A.DEBUG)return !0;var t,r,n=e.c,i=e.e,a=e.s;e:if("[object Array]"=={}.toString.call(n)){if((1===a||-1===a)&&-W<=i&&i<=W&&i===R(i)){if(0===n[0]){if(0===i&&1===n.length)return !0;break e}if((t=(i+1)%V)<1&&(t+=V),String(n[0]).length==t){for(t=0;t<n.length;t++)if((r=n[t])<0||G<=r||r!==R(r))break e;if(0!==r)return !0}}}else if(null===n&&null===i&&(null===a||1===a||-1===a))return !0;throw Error(I+"Invalid BigNumber: "+e)},A.maximum=A.max=function(){return _(arguments,n.lt)},A.minimum=A.min=function(){return _(arguments,n.gt)},A.random=(r=9007199254740992,s=Math.random()*r&2097151?function(){return R(Math.random()*r)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,r,n,i,a,o=0,u=[],c=new A(h);if(null==e?e=y:J(e,0,W),i=U(e/V),x)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(i*=2));o<i;)9e15<=(a=131072*t[o]+(t[o+1]>>>11))?(r=crypto.getRandomValues(new Uint32Array(2)),t[o]=r[0],t[o+1]=r[1]):(u.push(a%1e14),o+=2);o=i/2;}else {if(!crypto.randomBytes)throw x=!1,Error(I+"crypto unavailable");for(t=crypto.randomBytes(i*=7);o<i;)9e15<=(a=281474976710656*(31&t[o])+1099511627776*t[o+1]+4294967296*t[o+2]+16777216*t[o+3]+(t[o+4]<<16)+(t[o+5]<<8)+t[o+6])?crypto.randomBytes(7).copy(t,o):(u.push(a%1e14),o+=7);o=i/7;}if(!x)for(;o<i;)(a=s())<9e15&&(u[o++]=a%1e14);for(i=u[--o],e%=V,i&&e&&(a=Z[V-e],u[o]=R(i/a)*a);0===u[o];u.pop(),o--);if(o<0)u=[n=0];else {for(n=-1;0===u[0];u.splice(0,1),n-=V);for(o=1,a=u[0];10<=a;a/=10,o++);o<V&&(n-=V-o);}return c.e=n,c.c=u,c}),A.sum=function(){for(var e=1,t=arguments,r=new A(t[0]);e<t.length;)r=r.plus(t[e++]);return r},m="0123456789",f=function(e,t,r,n,i){var a,o,u,c,s,l,f,g,p=e.indexOf("."),d=y,h=b;for(0<=p&&(c=N,N=0,e=e.replace(".",""),l=(g=new A(t)).pow(e.length-p),N=c,g.c=D(ee(Y(l.c),l.e,"0"),10,r,m),g.e=g.c.length),u=c=(f=D(e,t,r,i?(a=M,m):(a=m,M))).length;0==f[--c];f.pop());if(!f[0])return a.charAt(0);if(p<0?--u:(l.c=f,l.e=u,l.s=n,f=(l=v(l,g,d,h,r)).c,s=l.r,u=l.e),p=f[o=u+d+1],c=r/2,s=s||o<0||null!=f[o+1],s=h<4?(null!=p||s)&&(0==h||h==(l.s<0?3:2)):c<p||p==c&&(4==h||s||6==h&&1&f[o-1]||h==(l.s<0?8:7)),o<1||!f[0])e=s?ee(a.charAt(1),-d,a.charAt(0)):a.charAt(0);else {if(f.length=o,s)for(--r;++f[--o]>r;)f[o]=0,o||(++u,f=[1].concat(f));for(c=f.length;!f[--c];);for(p=0,e="";p<=c;e+=a.charAt(f[p++]));e=ee(e,u,a.charAt(0));}return e},v=function(e,t,r,n,i){var a,o,u,c,s,l,f,g,p,d,h,v,m,y,b,w,S,O=e.s==t.s?1:-1,x=e.c,N=t.c;if(!(x&&x[0]&&N&&N[0]))return new A(e.s&&t.s&&(x?!N||x[0]!=N[0]:N)?x&&0==x[0]||!N?0*O:O/0:NaN);for(p=(g=new A(O)).c=[],O=r+(o=e.e-t.e)+1,i||(i=G,o=H(e.e/V)-H(t.e/V),O=O/V|0),u=0;N[u]==(x[u]||0);u++);if(N[u]>(x[u]||0)&&o--,O<0)p.push(1),c=!0;else {for(y=x.length,w=N.length,O+=2,1<(s=R(i/(N[u=0]+1)))&&(N=E(N,s,i),x=E(x,s,i),w=N.length,y=x.length),m=w,h=(d=x.slice(0,w)).length;h<w;d[h++]=0);S=N.slice(),S=[0].concat(S),b=N[0],N[1]>=i/2&&b++;do{if(s=0,(a=F(N,d,w,h))<0){if(v=d[0],w!=h&&(v=v*i+(d[1]||0)),1<(s=R(v/b)))for(i<=s&&(s=i-1),f=(l=E(N,s,i)).length,h=d.length;1==F(l,d,f,h);)s--,k(l,w<f?S:N,f,i),f=l.length,a=1;else 0==s&&(a=s=1),f=(l=N.slice()).length;if(f<h&&(l=[0].concat(l)),k(d,l,h,i),h=d.length,-1==a)for(;F(N,d,w,h)<1;)s++,k(d,w<h?S:N,h,i),h=d.length;}else 0===a&&(s++,d=[0]);p[u++]=s,d[0]?d[h++]=x[m]||0:(d=[x[m]],h=1);}while((m++<y||null!=d[0])&&O--);c=null!=d[0],p[0]||p.splice(0,1);}if(i==G){for(u=1,O=p[0];10<=O;O/=10,u++);j(g,r+(g.e=u+o*V-1)+1,n,c);}else g.e=o,g.r=+c;return g},o=/^(-?)0([xbo])(?=\w[\w.]*$)/i,u=/^([^.]+)\.$/,c=/^\.([^.]+)$/,l=/^-?(Infinity|NaN)$/,p=/^\s*\+(?=[\w.])|^\s+|\s+$/g,g=function(e,t,r,n){var i,a=r?t:t.replace(p,"");if(l.test(a))e.s=isNaN(a)?null:a<0?-1:1;else {if(!r&&(a=a.replace(o,function(e,t,r){return i="x"==(r=r.toLowerCase())?16:"b"==r?2:8,n&&n!=i?e:t}),n&&(i=n,a=a.replace(u,"$1").replace(c,"0.$1")),t!=a))return new A(a,i);if(A.DEBUG)throw Error(I+"Not a"+(n?" base "+n:"")+" number: "+t);e.s=null;}e.c=e.e=null;},n.absoluteValue=n.abs=function(){var e=new A(this);return e.s<0&&(e.s=1),e},n.comparedTo=function(e,t){return K(this,new A(e,t))},n.decimalPlaces=n.dp=function(e,t){var r,n,i;if(null!=e)return J(e,0,W),null==t?t=b:J(t,0,8),j(new A(this),e+this.e+1,t);if(!(r=this.c))return null;if(n=((i=r.length-1)-H(this.e/V))*V,i=r[i])for(;i%10==0;i/=10,n--);return n<0&&(n=0),n},n.dividedBy=n.div=function(e,t){return v(this,new A(e,t),y,b)},n.dividedToIntegerBy=n.idiv=function(e,t){return v(this,new A(e,t),0,1)},n.exponentiatedBy=n.pow=function(e,t){var r,n,i,a,o,u,c,s,l=this;if((e=new A(e)).c&&!e.isInteger())throw Error(I+"Exponent not an integer: "+P(e));if(null!=t&&(t=new A(t)),o=14<e.e,!l.c||!l.c[0]||1==l.c[0]&&!l.e&&1==l.c.length||!e.c||!e.c[0])return s=new A(Math.pow(+P(l),o?2-X(e):+P(e))),t?s.mod(t):s;if(u=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new A(NaN);(n=!u&&l.isInteger()&&t.isInteger())&&(l=l.mod(t));}else {if(9<e.e&&(0<l.e||l.e<-1||(0==l.e?1<l.c[0]||o&&24e7<=l.c[1]:l.c[0]<8e13||o&&l.c[0]<=9999975e7)))return a=l.s<0&&X(e)?-0:0,-1<l.e&&(a=1/a),new A(u?1/a:a);N&&(a=U(N/V+2));}for(c=o?(r=new A(.5),u&&(e.s=1),X(e)):(i=Math.abs(+P(e)))%2,s=new A(h);;){if(c){if(!(s=s.times(l)).c)break;a?s.c.length>a&&(s.c.length=a):n&&(s=s.mod(t));}if(i){if(0===(i=R(i/2)))break;c=i%2;}else if(j(e=e.times(r),e.e+1,1),14<e.e)c=X(e);else {if(0==(i=+P(e)))break;c=i%2;}l=l.times(l),a?l.c&&l.c.length>a&&(l.c.length=a):n&&(l=l.mod(t));}return n?s:(u&&(s=h.div(s)),t?s.mod(t):a?j(s,N,b,void 0):s)},n.integerValue=function(e){var t=new A(this);return null==e?e=b:J(e,0,8),j(t,t.e+1,e)},n.isEqualTo=n.eq=function(e,t){return 0===K(this,new A(e,t))},n.isFinite=function(){return !!this.c},n.isGreaterThan=n.gt=function(e,t){return 0<K(this,new A(e,t))},n.isGreaterThanOrEqualTo=n.gte=function(e,t){return 1===(t=K(this,new A(e,t)))||0===t},n.isInteger=function(){return !!this.c&&H(this.e/V)>this.c.length-2},n.isLessThan=n.lt=function(e,t){return K(this,new A(e,t))<0},n.isLessThanOrEqualTo=n.lte=function(e,t){return -1===(t=K(this,new A(e,t)))||0===t},n.isNaN=function(){return !this.s},n.isNegative=function(){return this.s<0},n.isPositive=function(){return 0<this.s},n.isZero=function(){return !!this.c&&0==this.c[0]},n.minus=function(e,t){var r,n,i,a,o=this,u=o.s;if(t=(e=new A(e,t)).s,!u||!t)return new A(NaN);if(u!=t)return e.s=-t,o.plus(e);var c=o.e/V,s=e.e/V,l=o.c,f=e.c;if(!c||!s){if(!l||!f)return l?(e.s=-t,e):new A(f?o:NaN);if(!l[0]||!f[0])return f[0]?(e.s=-t,e):new A(l[0]?o:3==b?-0:0)}if(c=H(c),s=H(s),l=l.slice(),u=c-s){for((i=(a=u<0)?(u=-u,l):(s=c,f)).reverse(),t=u;t--;i.push(0));i.reverse();}else for(n=(a=(u=l.length)<(t=f.length))?u:t,u=t=0;t<n;t++)if(l[t]!=f[t]){a=l[t]<f[t];break}if(a&&(i=l,l=f,f=i,e.s=-e.s),0<(t=(n=f.length)-(r=l.length)))for(;t--;l[r++]=0);for(t=G-1;u<n;){if(l[--n]<f[n]){for(r=n;r&&!l[--r];l[r]=t);--l[r],l[n]+=G;}l[n]-=f[n];}for(;0==l[0];l.splice(0,1),--s);return l[0]?L(e,l,s):(e.s=3==b?-1:1,e.c=[e.e=0],e)},n.modulo=n.mod=function(e,t){var r,n,i=this;return e=new A(e,t),!i.c||!e.s||e.c&&!e.c[0]?new A(NaN):!e.c||i.c&&!i.c[0]?new A(i):(9==a?(n=e.s,e.s=1,r=v(i,e,0,3),e.s=n,r.s*=n):r=v(i,e,0,a),(e=i.minus(r.times(e))).c[0]||1!=a||(e.s=i.s),e)},n.multipliedBy=n.times=function(e,t){var r,n,i,a,o,u,c,s,l,f,g,p,d,h,v,m=this,y=m.c,b=(e=new A(e,t)).c;if(!(y&&b&&y[0]&&b[0]))return !m.s||!e.s||y&&!y[0]&&!b||b&&!b[0]&&!y?e.c=e.e=e.s=null:(e.s*=m.s,y&&b?(e.c=[0],e.e=0):e.c=e.e=null),e;for(n=H(m.e/V)+H(e.e/V),e.s*=m.s,(c=y.length)<(f=b.length)&&(d=y,y=b,b=d,i=c,c=f,f=i),i=c+f,d=[];i--;d.push(0));for(h=G,v=z,i=f;0<=--i;){for(r=0,g=b[i]%v,p=b[i]/v|0,a=i+(o=c);i<a;)r=((s=g*(s=y[--o]%v)+(u=p*s+(l=y[o]/v|0)*g)%v*v+d[a]+r)/h|0)+(u/v|0)+p*l,d[a--]=s%h;d[a]=r;}return r?++n:d.splice(0,1),L(e,d,n)},n.negated=function(){var e=new A(this);return e.s=-e.s||null,e},n.plus=function(e,t){var r,n=this,i=n.s;if(t=(e=new A(e,t)).s,!i||!t)return new A(NaN);if(i!=t)return e.s=-t,n.minus(e);var a=n.e/V,o=e.e/V,u=n.c,c=e.c;if(!a||!o){if(!u||!c)return new A(i/0);if(!u[0]||!c[0])return c[0]?e:new A(u[0]?n:0*i)}if(a=H(a),o=H(o),u=u.slice(),i=a-o){for((r=0<i?(o=a,c):(i=-i,u)).reverse();i--;r.push(0));r.reverse();}for((i=u.length)-(t=c.length)<0&&(r=c,c=u,u=r,t=i),i=0;t;)i=(u[--t]=u[t]+c[t]+i)/G|0,u[t]=G===u[t]?0:u[t]%G;return i&&(u=[i].concat(u),++o),L(e,u,o)},n.precision=n.sd=function(e,t){var r,n,i;if(null!=e&&e!==!!e)return J(e,1,W),null==t?t=b:J(t,0,8),j(new A(this),e,t);if(!(r=this.c))return null;if(n=(i=r.length-1)*V+1,i=r[i]){for(;i%10==0;i/=10,n--);for(i=r[0];10<=i;i/=10,n++);}return e&&this.e+1>n&&(n=this.e+1),n},n.shiftedBy=function(e){return J(e,-q,q),this.times("1e"+e)},n.squareRoot=n.sqrt=function(){var e,t,r,n,i,a=this,o=a.c,u=a.s,c=a.e,s=y+4,l=new A("0.5");if(1!==u||!o||!o[0])return new A(!u||u<0&&(!o||o[0])?NaN:o?a:1/0);if((r=0==(u=Math.sqrt(+P(a)))||u==1/0?(((t=Y(o)).length+c)%2==0&&(t+="0"),u=Math.sqrt(+t),c=H((c+1)/2)-(c<0||c%2),new A(t=u==1/0?"1e"+c:(t=u.toExponential()).slice(0,t.indexOf("e")+1)+c)):new A(u+"")).c[0])for((u=(c=r.e)+s)<3&&(u=0);;)if(i=r,r=l.times(i.plus(v(a,i,s,1))),Y(i.c).slice(0,u)===(t=Y(r.c)).slice(0,u)){if(r.e<c&&--u,"9999"!=(t=t.slice(u-3,u+1))&&(n||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(j(r,r.e+y+2,1),e=!r.times(r).eq(a));break}if(!n&&(j(i,i.e+y+2,0),i.times(i).eq(a))){r=i;break}s+=4,u+=4,n=1;}return j(r,r.e+y+1,b,e)},n.toExponential=function(e,t){return null!=e&&(J(e,0,W),e++),i(this,e,t,1)},n.toFixed=function(e,t){return null!=e&&(J(e,0,W),e=e+this.e+1),i(this,e,t)},n.toFormat=function(e,t,r){var n;if(null==r)null!=e&&t&&"object"==typeof t?(r=t,t=null):e&&"object"==typeof e?(r=e,e=t=null):r=B;else if("object"!=typeof r)throw Error(I+"Argument not an object: "+r);if(n=this.toFixed(e,t),this.c){var i,a=n.split("."),o=+r.groupSize,u=+r.secondaryGroupSize,c=r.groupSeparator||"",s=a[0],l=a[1],f=this.s<0,g=f?s.slice(1):s,p=g.length;if(u&&(i=o,o=u,p-=u=i),0<o&&0<p){for(i=p%o||o,s=g.substr(0,i);i<p;i+=o)s+=c+g.substr(i,o);0<u&&(s+=c+g.slice(i)),f&&(s="-"+s);}n=l?s+(r.decimalSeparator||"")+((u=+r.fractionGroupSize)?l.replace(new RegExp("\\d{"+u+"}\\B","g"),"$&"+(r.fractionGroupSeparator||"")):l):s;}return (r.prefix||"")+n+(r.suffix||"")},n.toFraction=function(e){var t,r,n,i,a,o,u,c,s,l,f,g,p=this,d=p.c;if(null!=e&&(!(u=new A(e)).isInteger()&&(u.c||1!==u.s)||u.lt(h)))throw Error(I+"Argument "+(u.isInteger()?"out of range: ":"not an integer: ")+P(u));if(!d)return new A(p);for(t=new A(h),s=r=new A(h),n=c=new A(h),g=Y(d),a=t.e=g.length-p.e-1,t.c[0]=Z[(o=a%V)<0?V+o:o],e=!e||0<u.comparedTo(t)?0<a?t:s:u,o=O,O=1/0,u=new A(g),c.c[0]=0;l=v(u,t,0,1),1!=(i=r.plus(l.times(n))).comparedTo(e);)r=n,n=i,s=c.plus(l.times(i=s)),c=i,t=u.minus(l.times(i=t)),u=i;return i=v(e.minus(r),n,0,1),c=c.plus(i.times(s)),r=r.plus(i.times(n)),c.s=s.s=p.s,f=v(s,n,a*=2,b).minus(p).abs().comparedTo(v(c,r,a,b).minus(p).abs())<1?[s,n]:[c,r],O=o,f},n.toNumber=function(){return +P(this)},n.toPrecision=function(e,t){return null!=e&&J(e,1,W),i(this,e,t,2)},n.toString=function(e){var t,r=this,n=r.s,i=r.e;return null===i?n?(t="Infinity",n<0&&(t="-"+t)):t="NaN":(t=null==e?i<=d||w<=i?Q(Y(r.c),i):ee(Y(r.c),i,"0"):10===e?ee(Y((r=j(new A(r),y+i+1,b)).c),r.e,"0"):(J(e,2,M.length,"Base"),f(ee(Y(r.c),i,"0"),10,e,n,!0)),n<0&&r.c[0]&&(t="-"+t)),t},n.valueOf=n.toJSON=function(){return P(this)},n._isBigNumber=!0,C&&(n[Symbol.toStringTag]="BigNumber",n[Symbol.for("nodejs.util.inspect.custom")]=n.valueOf),null!=t&&A.set(t),A}()).default=t.BigNumber=t,void 0!==r&&r.exports?r.exports=t:(e=e||("undefined"!=typeof self&&self?self:window)).BigNumber=t;}(this);},{}],2:[function(e,t,r){t.exports={languageTag:"en-US",delimiters:{thousands:",",decimal:"."},abbreviations:{thousand:"k",million:"m",billion:"b",trillion:"t"},spaceSeparated:!1,ordinal:function(e){var t=e%10;return 1==~~(e%100/10)?"th":1==t?"st":2==t?"nd":3==t?"rd":"th"},bytes:{binarySuffixes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],decimalSuffixes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"]},currency:{symbol:"$",position:"prefix",code:"USD"},currencyFormat:{thousandSeparated:!0,totalLength:4,spaceSeparated:!0,spaceSeparatedCurrency:!0},formats:{fourDigits:{totalLength:4,spaceSeparated:!0},fullWithTwoDecimals:{output:"currency",thousandSeparated:!0,mantissa:2},fullWithTwoDecimalsNoCurrency:{thousandSeparated:!0,mantissa:2},fullWithNoDecimals:{output:"currency",thousandSeparated:!0,mantissa:0}}};},{}],3:[function(e,t,r){function I(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var r=[],n=!0,i=!1,a=void 0;try{for(var o,u=e[Symbol.iterator]();!(n=(o=u.next()).done)&&(r.push(o.value),!t||r.length!==t);n=!0);}catch(e){i=!0,a=e;}finally{try{n||null==u.return||u.return();}finally{if(i)throw a}}return r}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var $=e("./globalState"),o=e("./validating"),u=e("./parsing"),i=e("bignumber.js"),G={trillion:Math.pow(10,12),billion:Math.pow(10,9),million:Math.pow(10,6),thousand:Math.pow(10,3)},V={totalLength:0,characteristic:0,forceAverage:!1,average:!1,mantissa:-1,optionalMantissa:!0,thousandSeparated:!1,spaceSeparated:!1,negative:"sign",forceSign:!1,roundingFunction:Math.round,spaceSeparatedAbbreviation:!1},n=$.currentBytes(),d=n.binarySuffixes,h=n.decimalSuffixes,a={general:{scale:1024,suffixes:h,marker:"bd"},binary:{scale:1024,suffixes:d,marker:"b"},decimal:{scale:1e3,suffixes:h,marker:"d"}};function c(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length?arguments[2]:void 0;if("string"==typeof t&&(t=u.parseFormat(t)),!o.validateFormat(t))return "ERROR: invalid format";var n=t.prefix||"",i=t.postfix||"",a=function(e,t,r){switch(t.output){case"currency":return t=s(t,$.currentCurrencyDefaultFormat()),function(e,t,r){var n=r.currentCurrency(),i=Object.assign({},t),a=Object.assign({},V,i),o=void 0,u="",c=!!a.totalLength||!!a.forceAverage||a.average,s=i.currencyPosition||n.position,l=i.currencySymbol||n.symbol,f=void 0!==a.spaceSeparatedCurrency?a.spaceSeparatedCurrency:a.spaceSeparated;void 0===i.lowPrecision&&(i.lowPrecision=!1);f&&(u=" ");"infix"===s&&(o=u+l+u);var g=m({instance:e,providedFormat:i,state:r,decimalSeparator:o});"prefix"===s&&(g=e._value<0&&"sign"===a.negative?"-".concat(u).concat(l).concat(g.slice(1)):0<e._value&&a.forceSign?"+".concat(u).concat(l).concat(g.slice(1)):l+u+g);s&&"postfix"!==s||(u=!a.spaceSeparatedAbbreviation&&c?"":u,g=g+u+l);return g}(e,t,$);case"percent":return t=s(t,$.currentPercentageDefaultFormat()),function(e,t,r,n){var i=t.prefixSymbol,a=m({instance:n(100*e._value),providedFormat:t,state:r}),o=Object.assign({},V,t);if(i)return "%".concat(o.spaceSeparated?" ":"").concat(a);return "".concat(a).concat(o.spaceSeparated?" ":"","%")}(e,t,$,r);case"byte":return t=s(t,$.currentByteDefaultFormat()),function(e,t,r,n){var i=t.base||"binary",a=Object.assign({},V,t),o=r.currentBytes(),u=o.binarySuffixes,c=o.decimalSuffixes,s={general:{scale:1024,suffixes:c||h,marker:"bd"},binary:{scale:1024,suffixes:u||d,marker:"b"},decimal:{scale:1e3,suffixes:c||h,marker:"d"}}[i],l=v(e._value,s.suffixes,s.scale),f=l.value,g=l.suffix,p=m({instance:n(f),providedFormat:t,state:r,defaults:r.currentByteDefaultFormat()});return "".concat(p).concat(a.spaceSeparated?" ":"").concat(g)}(e,t,$,r);case"time":return t=s(t,$.currentTimeDefaultFormat()),function(e){var t=Math.floor(e._value/60/60),r=Math.floor((e._value-60*t*60)/60),n=Math.round(e._value-60*t*60-60*r);return "".concat(t,":").concat(r<10?"0":"").concat(r,":").concat(n<10?"0":"").concat(n)}(e);case"ordinal":return t=s(t,$.currentOrdinalDefaultFormat()),function(e,t,r){var n=r.currentOrdinal(),i=Object.assign({},V,t),a=m({instance:e,providedFormat:t,state:r}),o=n(e._value);return "".concat(a).concat(i.spaceSeparated?" ":"").concat(o)}(e,t,$);case"number":default:return m({instance:e,providedFormat:t,numbro:r})}}(e,t,r);return a=(a=n+a)+i}function v(e,t,r){var n=t[0],i=Math.abs(e);if(r<=i){for(var a=1;a<t.length;++a){var o=Math.pow(r,a),u=Math.pow(r,a+1);if(o<=i&&i<u){n=t[a],e/=o;break}}n===t[0]&&(e/=Math.pow(r,t.length-1),n=t[t.length-1]);}return {value:e,suffix:n}}function g(e){for(var t="",r=0;r<e;r++)t+="0";return t}function q(e,t,r){var n=2<arguments.length&&void 0!==r?r:Math.round;return -1!==e.toString().indexOf("e")?function(e,t){var r=e.toString(),n=I(r.split("e"),2),i=n[0],a=n[1],o=I(i.split("."),2),u=o[0],c=o[1],s=void 0===c?"":c;if(0<+a)r=u+s+g(a-s.length);else {var l=".";l=+u<0?"-0".concat(l):"0".concat(l);var f=(g(-a-1)+Math.abs(u)+s).substr(0,t);f.length<t&&(f+=g(t-f.length)),r=l+f;}return 0<+a&&0<t&&(r+=".".concat(g(t))),r}(e,t):new i(n(+"".concat(e,"e+").concat(t))/Math.pow(10,t)).toFixed(t)}function Z(e,t,r,n,i){var a=n.currentDelimiters(),o=a.thousands;i=i||a.decimal;var u=a.thousandsSize||3,c=e.toString(),s=c.split(".")[0],l=c.split(".")[1],f=t<0&&0===s.indexOf("-");r&&(f&&(s=s.slice(1)),function(e,t){for(var r=[],n=0,i=e;0<i;i--)n===t&&(r.unshift(i),n=0),n++;return r}(s.length,u).forEach(function(e,t){s=s.slice(0,e+t)+o+s.slice(e+t);}),f&&(s="-".concat(s)));return c=l?s+i+l:s}function m(e){var t=e.instance,r=e.providedFormat,n=e.state,i=void 0===n?$:n,a=e.decimalSeparator,o=e.defaults,u=void 0===o?i.currentDefaults():o,c=t._value;if(0===c&&i.hasZeroFormat())return i.getZeroFormat();if(!isFinite(c))return c.toString();var s,l,f,g,p,d,h,v,m=Object.assign({},V,u,r),y=m.totalLength,b=y?0:m.characteristic,w=m.optionalCharacteristic,S=m.forceAverage,O=m.lowPrecision,x=!!y||!!S||m.average,N=y?-1:x&&void 0===r.mantissa?0:m.mantissa,B=!y&&(void 0===r.optionalMantissa?-1===N:m.optionalMantissa),M=m.trimMantissa,A=m.thousandSeparated,D=m.spaceSeparated,E=m.negative,F=m.forceSign,k=m.exponential,_=m.roundingFunction,L="";if(x){var j=function(e){var t=e.value,r=e.forceAverage,n=e.lowPrecision,i=void 0===n||n,a=e.abbreviations,o=e.spaceSeparated,u=void 0!==o&&o,c=e.totalLength,s=void 0===c?0:c,l=e.roundingFunction,f=void 0===l?Math.round:l,g="",p=Math.abs(t),d=-1;if(r&&a[r]&&G[r]?(g=a[r],t/=G[r]):p>=G.trillion||i&&1===f(p/G.trillion)?(g=a.trillion,t/=G.trillion):p<G.trillion&&p>=G.billion||i&&1===f(p/G.billion)?(g=a.billion,t/=G.billion):p<G.billion&&p>=G.million||i&&1===f(p/G.million)?(g=a.million,t/=G.million):(p<G.million&&p>=G.thousand||i&&1===f(p/G.thousand))&&(g=a.thousand,t/=G.thousand),g=g&&(u?" ":"")+g,s){var h=t<0,v=t.toString().split(".")[0],m=h?v.length-1:v.length;d=Math.max(s-m,0);}return {value:t,abbreviation:g,mantissaPrecision:d}}({value:c,forceAverage:S,lowPrecision:O,abbreviations:i.currentAbbreviations(),spaceSeparated:D,roundingFunction:_,totalLength:y});c=j.value,L+=j.abbreviation,y&&(N=j.mantissaPrecision);}if(k){var P=(l=(s={value:c,characteristicPrecision:b}).value,f=s.characteristicPrecision,g=void 0===f?0:f,p=I(l.toExponential().split("e"),2),d=p[0],h=p[1],v=+d,g&&1<g&&(v*=Math.pow(10,g-1),h=0<=(h-=g-1)?"+".concat(h):h),{value:v,abbreviation:"e".concat(h)});c=P.value,L=P.abbreviation+L;}var T,C,U,R=function(e,t,r,n,i,a){if(-1===n)return e;var o=q(t,n,a),u=I(o.toString().split("."),2),c=u[0],s=u[1],l=void 0===s?"":s;if(l.match(/^0+$/)&&(r||i))return c;var f=l.match(/0+$/);return i&&f?"".concat(c,".").concat(l.toString().slice(0,f.index)):o.toString()}(c.toString(),c,B,N,M,_);return R=Z(R=function(e,t,r,n){var i=e,a=I(i.toString().split("."),2),o=a[0],u=a[1];if(o.match(/^-?0$/)&&r)return u?"".concat(o.replace("0",""),".").concat(u):o.replace("0","");var c=t<0&&0===o.indexOf("-");if(c&&(o=o.slice(1),i=i.slice(1)),o.length<n)for(var s=n-o.length,l=0;l<s;l++)i="0".concat(i);return c&&(i="-".concat(i)),i.toString()}(R,c,w,b),c,A,i,a),(x||k)&&(R=R+L),(F||c<0)&&(T=R,U=E,R=0===(C=c)?T:0==+T?T.replace("-",""):0<C?"+".concat(T):"sign"===U?T:"(".concat(T.replace("-",""),")")),R}function s(e,t){if(!e)return t;var r=Object.keys(e);return 1===r.length&&"output"===r[0]?t:e}t.exports=function(n){return {format:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return c.apply(void 0,t.concat([n]))},getByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=a.general;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getBinaryByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=a.binary;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},getDecimalByteUnit:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){var t=a.decimal;return v(e._value,t.suffixes,t.scale).suffix}.apply(void 0,t.concat([n]))},formatOrDefault:s}};},{"./globalState":4,"./parsing":8,"./validating":10,"bignumber.js":1}],4:[function(e,t,r){var i=e("./en-US"),n=e("./validating"),a=e("./parsing"),o={},u=void 0,c={},s=null,l={};function f(e){u=e;}function g(){return c[u]}o.languages=function(){return Object.assign({},c)},o.currentLanguage=function(){return u},o.currentBytes=function(){return g().bytes||{}},o.currentCurrency=function(){return g().currency},o.currentAbbreviations=function(){return g().abbreviations},o.currentDelimiters=function(){return g().delimiters},o.currentOrdinal=function(){return g().ordinal},o.currentDefaults=function(){return Object.assign({},g().defaults,l)},o.currentOrdinalDefaultFormat=function(){return Object.assign({},o.currentDefaults(),g().ordinalFormat)},o.currentByteDefaultFormat=function(){return Object.assign({},o.currentDefaults(),g().byteFormat)},o.currentPercentageDefaultFormat=function(){return Object.assign({},o.currentDefaults(),g().percentageFormat)},o.currentCurrencyDefaultFormat=function(){return Object.assign({},o.currentDefaults(),g().currencyFormat)},o.currentTimeDefaultFormat=function(){return Object.assign({},o.currentDefaults(),g().timeFormat)},o.setDefaults=function(e){e=a.parseFormat(e),n.validateFormat(e)&&(l=e);},o.getZeroFormat=function(){return s},o.setZeroFormat=function(e){return s="string"==typeof e?e:null},o.hasZeroFormat=function(){return null!==s},o.languageData=function(e){if(e){if(c[e])return c[e];throw new Error('Unknown tag "'.concat(e,'"'))}return g()},o.registerLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1];if(!n.validateLanguage(e))throw new Error("Invalid language data");c[e.languageTag]=e,t&&f(e.languageTag);},o.setLanguage=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:i.languageTag;if(!c[e]){var r=e.split("-")[0],n=Object.keys(c).find(function(e){return e.split("-")[0]===r});return c[n]?void f(n):void f(t)}f(e);},o.registerLanguage(i),u=i.languageTag,t.exports=o;},{"./en-US":2,"./parsing":8,"./validating":10}],5:[function(n,e,t){e.exports=function(t){return {loadLanguagesInNode:function(e){return r=t,void e.forEach(function(t){var e=void 0;try{e=n("../languages/".concat(t));}catch(e){console.error('Unable to load "'.concat(t,'". No matching language file found.'));}e&&r.registerLanguage(e);});var r;}}};},{}],6:[function(e,t,r){var c=e("bignumber.js");function a(e,t,r){var n=new c(e._value),i=t;return r.isNumbro(t)&&(i=t._value),i=new c(i),e._value=n.minus(i).toNumber(),e}t.exports=function(u){return {add:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.plus(o).toNumber(),r;var r,n,i,a,o;},subtract:function(e,t){return a(e,t,u)},multiply:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.times(o).toNumber(),r;var r,n,i,a,o;},divide:function(e,t){return n=t,i=u,a=new c((r=e)._value),o=n,i.isNumbro(n)&&(o=n._value),o=new c(o),r._value=a.dividedBy(o).toNumber(),r;var r,n,i,a,o;},set:function(e,t){return r=e,i=n=t,u.isNumbro(n)&&(i=n._value),r._value=i,r;var r,n,i;},difference:function(e,t){return r=t,a(i=(n=u)(e._value),r,n),Math.abs(i._value);var r,n,i;},BigNumber:c}};},{"bignumber.js":1}],7:[function(e,t,r){function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var a=e("./globalState"),n=e("./validating"),o=e("./loading")(p),u=e("./unformatting"),c=e("./formatting")(p),s=e("./manipulating")(p),l=e("./parsing"),f=function(){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),this._value=e;}var e,r;return e=t,(r=[{key:"clone",value:function(){return p(this._value)}},{key:"format",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};return c.format(this,t)}},{key:"formatCurrency",value:function(e){return "string"==typeof e&&(e=l.parseFormat(e)),(e=c.formatOrDefault(e,a.currentCurrencyDefaultFormat())).output="currency",c.format(this,e)}},{key:"formatTime",value:function(e){var t=0<arguments.length&&void 0!==e?e:{};return t.output="time",c.format(this,t)}},{key:"binaryByteUnits",value:function(){return c.getBinaryByteUnit(this)}},{key:"decimalByteUnits",value:function(){return c.getDecimalByteUnit(this)}},{key:"byteUnits",value:function(){return c.getByteUnit(this)}},{key:"difference",value:function(e){return s.difference(this,e)}},{key:"add",value:function(e){return s.add(this,e)}},{key:"subtract",value:function(e){return s.subtract(this,e)}},{key:"multiply",value:function(e){return s.multiply(this,e)}},{key:"divide",value:function(e){return s.divide(this,e)}},{key:"set",value:function(e){return s.set(this,g(e))}},{key:"value",value:function(){return this._value}},{key:"valueOf",value:function(){return this._value}}])&&i(e.prototype,r),t}();function g(e){var t=e;return p.isNumbro(e)?t=e._value:"string"==typeof e?t=p.unformat(e):isNaN(e)&&(t=NaN),t}function p(e){return new f(g(e))}p.version="2.3.6",p.isNumbro=function(e){return e instanceof f},p.language=a.currentLanguage,p.registerLanguage=a.registerLanguage,p.setLanguage=a.setLanguage,p.languages=a.languages,p.languageData=a.languageData,p.zeroFormat=a.setZeroFormat,p.defaultFormat=a.currentDefaults,p.setDefaults=a.setDefaults,p.defaultCurrencyFormat=a.currentCurrencyDefaultFormat,p.validate=n.validate,p.loadLanguagesInNode=o.loadLanguagesInNode,p.unformat=u.unformat,p.BigNumber=s.BigNumber,t.exports=p;},{"./formatting":3,"./globalState":4,"./loading":5,"./manipulating":6,"./parsing":8,"./unformatting":9,"./validating":10}],8:[function(e,t,r){t.exports={parseFormat:function(e){var t,r,n,i,a,o,u,c,s,l,f,g,p,d,h,v,m,y,b,w,S,O,x=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return "string"!=typeof e?e:(r=x,e=(n=(t=e).match(/^{([^}]*)}/))?(r.prefix=n[1],t.slice(n[0].length)):t,a=x,function(e,t){if(-1===e.indexOf("$")){if(-1===e.indexOf("%"))return -1!==e.indexOf("bd")?(t.output="byte",t.base="general"):-1!==e.indexOf("b")?(t.output="byte",t.base="binary"):-1!==e.indexOf("d")?(t.output="byte",t.base="decimal"):-1===e.indexOf(":")?-1!==e.indexOf("o")&&(t.output="ordinal"):t.output="time";t.output="percent";}else t.output="currency";}(e=(o=(i=e).match(/{([^}]*)}$/))?(a.postfix=o[1],i.slice(0,-o[0].length)):i,x),u=x,(c=e.match(/[1-9]+[0-9]*/))&&(u.totalLength=+c[0]),s=x,(l=e.split(".")[0].match(/0+/))&&(s.characteristic=l[0].length),function(e,t){if(-1!==e.indexOf(".")){var r=e.split(".")[0];t.optionalCharacteristic=-1===r.indexOf("0");}}(e,x),f=x,-1!==e.indexOf("a")&&(f.average=!0),p=x,-1!==(g=e).indexOf("K")?p.forceAverage="thousand":-1!==g.indexOf("M")?p.forceAverage="million":-1!==g.indexOf("B")?p.forceAverage="billion":-1!==g.indexOf("T")&&(p.forceAverage="trillion"),function(e,t){var r=e.split(".")[1];if(r){var n=r.match(/0+/);n&&(t.mantissa=n[0].length);}}(e,x),h=x,(d=e).match(/\[\.]/)?h.optionalMantissa=!0:d.match(/\./)&&(h.optionalMantissa=!1),v=x,(m=e.split(".")[1])&&(v.trimMantissa=-1!==m.indexOf("[")),y=x,-1!==e.indexOf(",")&&(y.thousandSeparated=!0),b=x,-1!==e.indexOf(" ")&&(b.spaceSeparated=!0,b.spaceSeparatedCurrency=!0,(b.average||b.forceAverage)&&(b.spaceSeparatedAbbreviation=!0)),S=x,(w=e).match(/^\+?\([^)]*\)$/)&&(S.negative="parenthesis"),w.match(/^\+?-/)&&(S.negative="sign"),O=x,e.match(/^\+/)&&(O.forceSign=!0),x)}};},{}],9:[function(g,e,t){var M=[{key:"ZiB",factor:Math.pow(1024,7)},{key:"ZB",factor:Math.pow(1e3,7)},{key:"YiB",factor:Math.pow(1024,8)},{key:"YB",factor:Math.pow(1e3,8)},{key:"TiB",factor:Math.pow(1024,4)},{key:"TB",factor:Math.pow(1e3,4)},{key:"PiB",factor:Math.pow(1024,5)},{key:"PB",factor:Math.pow(1e3,5)},{key:"MiB",factor:Math.pow(1024,2)},{key:"MB",factor:Math.pow(1e3,2)},{key:"KiB",factor:Math.pow(1024,1)},{key:"KB",factor:Math.pow(1e3,1)},{key:"GiB",factor:Math.pow(1024,3)},{key:"GB",factor:Math.pow(1e3,3)},{key:"EiB",factor:Math.pow(1024,6)},{key:"EB",factor:Math.pow(1e3,6)},{key:"B",factor:1}];function A(e){return e.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function p(e,t,r,n,i,a,o){var u=2<arguments.length&&void 0!==r?r:"",c=3<arguments.length?n:void 0,s=4<arguments.length?i:void 0,l=5<arguments.length?a:void 0,f=6<arguments.length?o:void 0;if(""!==e)return e===s?0:function e(t,r,n,i,a,o,u){var c=2<arguments.length&&void 0!==n?n:"",s=3<arguments.length?i:void 0,l=4<arguments.length?a:void 0,f=5<arguments.length?o:void 0,g=6<arguments.length?u:void 0;if(!isNaN(+t))return +t;var p="",d=t.replace(/(^[^(]*)\((.*)\)([^)]*$)/,"$1$2$3");if(d!==t)return -1*e(d,r,c,s,l,f,g);for(var h=0;h<M.length;h++){var v=M[h];if((p=t.replace(RegExp("([0-9 ])(".concat(v.key,")$")),"$1"))!==t)return e(p,r,c,s,l,f,g)*v.factor}if((p=t.replace("%",""))!==t)return e(p,r,c,s,l,f,g)/100;var m=parseFloat(t);if(!isNaN(m)){var y=s(m);if(y&&"."!==y&&(p=t.replace(new RegExp("".concat(A(y),"$")),""))!==t)return e(p,r,c,s,l,f,g);var b={};Object.keys(f).forEach(function(e){b[f[e]]=e;});for(var w=Object.keys(b).sort().reverse(),S=w.length,O=0;O<S;O++){var x=w[O],N=b[x];if((p=t.replace(x,""))!==t){var B=void 0;switch(N){case"thousand":B=Math.pow(10,3);break;case"million":B=Math.pow(10,6);break;case"billion":B=Math.pow(10,9);break;case"trillion":B=Math.pow(10,12);}return e(p,r,c,s,l,f,g)*B}}}}(function(e,t,r){var n=2<arguments.length&&void 0!==r?r:"",i=e.replace(n,"");return i=(i=i.replace(new RegExp("([0-9])".concat(A(t.thousands),"([0-9])"),"g"),"$1$2")).replace(t.decimal,".")}(e,t,u),t,u,c,s,l,f)}e.exports={unformat:function(e,t){var r,n,i,a=g("./globalState"),o=a.currentDelimiters(),u=a.currentCurrency().symbol,c=a.currentOrdinal(),s=a.getZeroFormat(),l=a.currentAbbreviations(),f=void 0;if("string"==typeof e)f=function(e,t){if(e.indexOf(":")&&":"!==t.thousands){var r=e.split(":");if(3===r.length){var n=+r[0],i=+r[1],a=+r[2];return !isNaN(n)&&!isNaN(i)&&!isNaN(a)}}}(e,o)?(r=e.split(":"),n=+r[0],i=+r[1],+r[2]+60*i+3600*n):p(e,o,u,c,s,l,t);else {if("number"!=typeof e)return;f=e;}if(void 0!==f)return f}};},{"./globalState":4}],10:[function(e,t,r){function n(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function f(e){return (f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var i=e("./unformatting"),a=/^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/,g={output:{type:"string",validValues:["currency","percent","byte","time","ordinal","number"]},base:{type:"string",validValues:["decimal","binary","general"],restriction:function(e,t){return "byte"===t.output},message:"`base` must be provided only when the output is `byte`",mandatory:function(e){return "byte"===e.output}},characteristic:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},prefix:"string",postfix:"string",forceAverage:{type:"string",validValues:["trillion","billion","million","thousand"]},average:"boolean",lowPrecision:{type:"boolean",restriction:function(e,t){return !0===t.average},message:"`lowPrecision` must be provided only when the option `average` is set"},currencyPosition:{type:"string",validValues:["prefix","infix","postfix"]},currencySymbol:"string",totalLength:{type:"number",restrictions:[{restriction:function(e){return 0<=e},message:"value must be positive"},{restriction:function(e,t){return !t.exponential},message:"`totalLength` is incompatible with `exponential`"}]},mantissa:{type:"number",restriction:function(e){return 0<=e},message:"value must be positive"},optionalMantissa:"boolean",trimMantissa:"boolean",roundingFunction:"function",optionalCharacteristic:"boolean",thousandSeparated:"boolean",spaceSeparated:"boolean",spaceSeparatedCurrency:"boolean",spaceSeparatedAbbreviation:"boolean",abbreviations:{type:"object",children:{thousand:"string",million:"string",billion:"string",trillion:"string"}},negative:{type:"string",validValues:["sign","parenthesis"]},forceSign:"boolean",exponential:{type:"boolean"},prefixSymbol:{type:"boolean",restriction:function(e,t){return "percent"===t.output},message:"`prefixSymbol` can be provided only when the output is `percent`"}},o={languageTag:{type:"string",mandatory:!0,restriction:function(e){return e.match(a)},message:"the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)"},delimiters:{type:"object",children:{thousands:"string",decimal:"string",thousandsSize:"number"},mandatory:!0},abbreviations:{type:"object",children:{thousand:{type:"string",mandatory:!0},million:{type:"string",mandatory:!0},billion:{type:"string",mandatory:!0},trillion:{type:"string",mandatory:!0}},mandatory:!0},spaceSeparated:"boolean",spaceSeparatedCurrency:"boolean",ordinal:{type:"function",mandatory:!0},bytes:{type:"object",children:{binarySuffixes:"object",decimalSuffixes:"object"}},currency:{type:"object",children:{symbol:"string",position:"string",code:"string"},mandatory:!0},defaults:"format",ordinalFormat:"format",byteFormat:"format",percentageFormat:"format",currencyFormat:"format",timeDefaults:"format",formats:{type:"object",children:{fourDigits:{type:"format",mandatory:!0},fullWithTwoDecimals:{type:"format",mandatory:!0},fullWithTwoDecimalsNoCurrency:{type:"format",mandatory:!0},fullWithNoDecimals:{type:"format",mandatory:!0}}}};function u(e){return void 0!==i.unformat(e)}function p(c,s,l,e){var t=3<arguments.length&&void 0!==e&&e,r=Object.keys(c).map(function(e){if(!s[e])return console.error("".concat(l," Invalid key: ").concat(e)),!1;var t=c[e],r=s[e];if("string"==typeof r&&(r={type:r}),"format"===r.type){if(!p(t,g,"[Validate ".concat(e,"]"),!0))return !1}else if(f(t)!==r.type)return console.error("".concat(l," ").concat(e,' type mismatched: "').concat(r.type,'" expected, "').concat(f(t),'" provided')),!1;if(r.restrictions&&r.restrictions.length)for(var n=r.restrictions.length,i=0;i<n;i++){var a=r.restrictions[i],o=a.restriction,u=a.message;if(!o(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(u)),!1}if(r.restriction&&!r.restriction(t,c))return console.error("".concat(l," ").concat(e," invalid value: ").concat(r.message)),!1;if(r.validValues&&-1===r.validValues.indexOf(t))return console.error("".concat(l," ").concat(e," invalid value: must be among ").concat(JSON.stringify(r.validValues),', "').concat(t,'" provided')),!1;if(r.children&&!p(t,r.children,"[Validate ".concat(e,"]")))return !1;return !0});return t||r.push.apply(r,n(Object.keys(s).map(function(e){var t=s[e];if("string"==typeof t&&(t={type:t}),t.mandatory){var r=t.mandatory;if("function"==typeof r&&(r=r(c)),r&&void 0===c[e])return console.error("".concat(l,' Missing mandatory key "').concat(e,'"')),!1}return !0}))),r.reduce(function(e,t){return e&&t},!0)}function c(e){return p(e,g,"[Validate format]")}t.exports={validate:function(e,t){var r=u(e),n=c(t);return r&&n},validateFormat:c,validateInput:u,validateLanguage:function(e){return p(e,o,"[Validate language]")}};},{"./unformatting":9}]},{},[7])(7)});

}(numbro_min));

const conversionFns = {
  days: (amt) => hoursToSeconds(amt * 24),
  hours: (amt) => hoursToSeconds(amt),
  minutes: (amt) => minutesToSeconds(amt),
  seconds: (amt) => amt
};
const toSeconds = (amt, unit) => conversionFns[unit]?.(amt);

const SHAMAN_PERMISSIONS = [
  {
    id: "0",
    displayName: "0 - No permission"
  },
  {
    id: "1",
    displayName: "1 - Admin only"
  },
  {
    id: "2",
    displayName: "2 - Manager only"
  },
  {
    id: "3",
    displayName: "3 - Admin and manager"
  },
  {
    id: "4",
    displayName: "4 - Governance only"
  },
  {
    id: "5",
    displayName: "5 - Admin and governance"
  },
  {
    id: "6",
    displayName: "6 - Manager and governance"
  },
  {
    id: "7",
    displayName: "7 - Admin, manager and governance"
  }
];

const AddressContainer = styled.div`
  display: flex;
  justify-content: flex-start;
  align-items: center;
  gap: 1rem;
`;
const AddressDataSm = styled(DataSm)`
  color: ${({
  theme
}) => theme.tint.secondary};
`;
const AddressCopyIcon = styled.div`
  cursor: pointer;
  margin-top: 0.5em;
`;

const getMatches = (query) => {
  if (typeof window !== "undefined") {
    return window.matchMedia(query).matches;
  }
  return false;
};
const useBreakpoint = (query) => {
  const [matches, setMatches] = useState$1(getMatches(query));
  const handleChange = useCallback(() => {
    setMatches(getMatches(query));
  }, [query]);
  useEffect$1(() => {
    window.addEventListener("resize", handleChange);
    return () => {
      window.removeEventListener("resize", handleChange);
    };
  }, [query, handleChange]);
  return matches;
};

const primary = {
  step1: amber.amber1,
  step2: amber.amber2,
  step3: amber.amber3,
  step4: amber.amber4,
  step5: amber.amber5,
  step6: amber.amber6,
  step7: amber.amber7,
  step8: amber.amber8,
  step9: amber.amber9,
  step10: amber.amber10,
  step11: amber.amber11,
  step12: amber.amber12
};
const primaryDark = {
  step1: amber$1.amber1,
  step2: amber$1.amber2,
  step3: amber$1.amber3,
  step4: amber$1.amber4,
  step5: amber$1.amber5,
  step6: amber$1.amber6,
  step7: amber$1.amber7,
  step8: amber$1.amber8,
  step9: amber$1.amber9,
  step10: amber$1.amber10,
  step11: amber$1.amber11,
  step12: amber$1.amber12
};
const secondary = {
  step1: indigo.indigo1,
  step2: indigo.indigo2,
  step3: indigo.indigo3,
  step4: indigo.indigo4,
  step5: indigo.indigo5,
  step6: indigo.indigo6,
  step7: indigo.indigo7,
  step8: indigo.indigo8,
  step9: indigo.indigo9,
  step10: indigo.indigo10,
  step11: indigo.indigo11,
  step12: indigo.indigo12
};
const secondaryDark = {
  step1: indigo$1.indigo1,
  step2: indigo$1.indigo2,
  step3: indigo$1.indigo3,
  step4: indigo$1.indigo4,
  step5: indigo$1.indigo5,
  step6: indigo$1.indigo6,
  step7: indigo$1.indigo7,
  step8: indigo$1.indigo8,
  step9: indigo$1.indigo9,
  step10: indigo$1.indigo10,
  step11: indigo$1.indigo11,
  step12: indigo$1.indigo12
};
const secondaryDarkA = {
  step1: indigoA$1.indigoA1,
  step2: indigoA$1.indigoA2,
  step3: indigoA$1.indigoA3,
  step4: indigoA$1.indigoA4,
  step5: indigoA$1.indigoA5,
  step6: indigoA$1.indigoA6,
  step7: indigoA$1.indigoA7,
  step8: indigoA$1.indigoA8,
  step9: indigoA$1.indigoA9,
  step10: indigoA$1.indigoA10,
  step11: indigoA$1.indigoA11,
  step12: indigoA$1.indigoA12
};
const neutral = {
  step1: slate.slate1,
  step2: slate.slate2,
  step3: slate.slate3,
  step4: slate.slate4,
  step5: slate.slate5,
  step6: slate.slate6,
  step7: slate.slate7,
  step8: slate.slate8,
  step9: slate.slate9,
  step10: slate.slate10,
  step11: slate.slate11,
  step12: slate.slate12
};
const neutralDark = {
  step1: slate$1.slate1,
  step2: slate$1.slate2,
  step3: slate$1.slate3,
  step4: slate$1.slate4,
  step5: slate$1.slate5,
  step6: slate$1.slate6,
  step7: slate$1.slate7,
  step8: slate$1.slate8,
  step9: slate$1.slate9,
  step10: slate$1.slate10,
  step11: slate$1.slate11,
  step12: slate$1.slate12
};
const utility = {
  success: green.green9,
  successText: green.green12,
  successBg: green.green3,
  successBorder: green.green7,
  warning: orange.orange9,
  warningText: orange.orange12,
  warningBg: orange.orange3,
  warningBorder: orange.orange7,
  danger: red.red9,
  dangerText: red.red12,
  dangerBg: red.red3,
  dangerBorder: red.red7,
  info: blue.blue9,
  transparent: "transparent"
};
const utilityDark = {
  success: green$1.green9,
  successText: green$1.green12,
  successBg: green$1.green3,
  successBorder: green$1.green7,
  warning: orange$1.orange9,
  warningText: orange$1.orange12,
  warningBg: orange$1.orange3,
  warningBorder: orange$1.orange7,
  danger: red$1.red9,
  dangerText: red$1.red12,
  dangerBg: red$1.red3,
  dangerBorder: red$1.red7,
  info: blue$1.blue9,
  transparent: "transparent"
};
({
  step1: blue.blue1,
  step2: blue.blue2,
  step3: blue.blue3,
  step4: blue.blue4,
  step5: blue.blue5,
  step6: blue.blue6,
  step7: blue.blue7,
  step8: blue.blue8,
  step9: blue.blue9,
  step10: blue.blue10,
  step11: blue.blue11,
  step12: blue.blue12
});
({
  step1: blue$1.blue1,
  step2: blue$1.blue2,
  step3: blue$1.blue3,
  step4: blue$1.blue4,
  step5: blue$1.blue5,
  step6: blue$1.blue6,
  step7: blue$1.blue7,
  step8: blue$1.blue8,
  step9: blue$1.blue9,
  step10: blue$1.blue10,
  step11: blue$1.blue11,
  step12: blue$1.blue12
});
const success = {
  step1: green.green1,
  step2: green.green2,
  step3: green.green3,
  step4: green.green4,
  step5: green.green5,
  step6: green.green6,
  step7: green.green7,
  step8: green.green8,
  step9: green.green9,
  step10: green.green10,
  step11: green.green11,
  step12: green.green12
};
const successDark = {
  step1: green$1.green1,
  step2: green$1.green2,
  step3: green$1.green3,
  step4: green$1.green4,
  step5: green$1.green5,
  step6: green$1.green6,
  step7: green$1.green7,
  step8: green$1.green8,
  step9: green$1.green9,
  step10: green$1.green10,
  step11: green$1.green11,
  step12: green$1.green12
};
const warning = {
  step1: orange.orange1,
  step2: orange.orange2,
  step3: orange.orange3,
  step4: orange.orange4,
  step5: orange.orange5,
  step6: orange.orange6,
  step7: orange.orange7,
  step8: orange.orange8,
  step9: orange.orange9,
  step10: orange.orange10,
  step11: orange.orange11,
  step12: orange.orange12
};
const warningDark = {
  step1: orange$1.orange1,
  step2: orange$1.orange2,
  step3: orange$1.orange3,
  step4: orange$1.orange4,
  step5: orange$1.orange5,
  step6: orange$1.orange6,
  step7: orange$1.orange7,
  step8: orange$1.orange8,
  step9: orange$1.orange9,
  step10: orange$1.orange10,
  step11: orange$1.orange11,
  step12: orange$1.orange12
};
const danger = {
  step1: red.red1,
  step2: red.red2,
  step3: red.red3,
  step4: red.red4,
  step5: red.red5,
  step6: red.red6,
  step7: red.red7,
  step8: red.red8,
  step9: red.red9,
  step10: red.red10,
  step11: red.red11,
  step12: red.red12
};
const dangerDark = {
  step1: red.red1,
  step2: red.red2,
  step3: red.red3,
  step4: red.red4,
  step5: red.red5,
  step6: red.red6,
  step7: red.red7,
  step8: red.red8,
  step9: red.red9,
  step10: red.red10,
  step11: red.red11,
  step12: red.red12
};

const PrimaryDarkButton = {
  text: primaryDark.step1,
  bg: primaryDark.step9,
  border: primaryDark.step9,
  hoverBg: primaryDark.step10,
  hoverBorder: primaryDark.step10,
  focusBg: primaryDark.step9,
  focusBorder: primaryDark.step11,
  disabledBg: primaryDark.step6,
  disabledBorder: primaryDark.step6,
  outline: primaryDark.step9,
  outlineHover: primaryDark.step10,
  outlineFocus: primaryDark.step11,
  outlineDisabled: primaryDark.step6
};
const SecondaryDarkButton = {
  text: secondaryDark.step12,
  bg: secondaryDark.step6,
  border: secondaryDark.step6,
  hoverBg: secondaryDark.step7,
  hoverBorder: secondaryDark.step7,
  focusBg: secondaryDark.step6,
  focusBorder: secondaryDark.step8,
  disabledBg: secondaryDark.step3,
  disabledBorder: secondaryDark.step3,
  outline: secondaryDark.step9,
  outlineHover: secondaryDark.step10,
  outlineFocus: secondaryDark.step11,
  outlineDisabled: secondaryDark.step6
};
const TertiaryDarkButton = {
  text: primaryDark.step11,
  bg: utilityDark.transparent,
  border: primaryDark.step11,
  hoverText: primaryDark.step10,
  hoverBorder: primaryDark.step10,
  focusText: primaryDark.step12,
  focusBorder: primaryDark.step12,
  disabledText: primaryDark.step6,
  disabledBorder: primaryDark.step6,
  outline: primaryDark.step9,
  outlineHover: primaryDark.step10,
  outlineFocus: primaryDark.step11,
  outlineDisabled: primaryDark.step6
};
const SuccessDarkButton = {
  text: successDark.step1,
  bg: successDark.step9,
  border: successDark.step9,
  hoverBg: successDark.step10,
  hoverBorder: successDark.step10,
  focusBg: successDark.step9,
  focusBorder: successDark.step11,
  disabledBg: successDark.step6,
  disabledBorder: successDark.step6,
  outline: successDark.step9,
  outlineHover: successDark.step10,
  outlineFocus: successDark.step11,
  outlineDisabled: successDark.step6
};
const WarningDarkButton = {
  text: warningDark.step1,
  bg: warningDark.step9,
  border: warningDark.step9,
  hoverBg: warningDark.step10,
  hoverBorder: warningDark.step10,
  focusBg: warningDark.step9,
  focusBorder: warningDark.step11,
  disabledBg: warningDark.step6,
  disabledBorder: warningDark.step6,
  outline: warningDark.step9,
  outlineHover: warningDark.step10,
  outlineFocus: warningDark.step11,
  outlineDisabled: warningDark.step6
};
const DangerDarkButton = {
  text: dangerDark.step12,
  bg: dangerDark.step9,
  border: dangerDark.step9,
  hoverBg: dangerDark.step9,
  hoverBorder: dangerDark.step10,
  focusBg: dangerDark.step10,
  focusBorder: dangerDark.step11,
  disabledBg: dangerDark.step6,
  disabledBorder: dangerDark.step6,
  outline: dangerDark.step9,
  outlineHover: dangerDark.step10,
  outlineFocus: dangerDark.step11,
  outlineDisabled: dangerDark.step6
};
const PrimaryLightButton = {
  text: primary.step1,
  bg: primary.step9,
  border: primary.step9,
  hoverBg: primary.step10,
  hoverBorder: primary.step10,
  focusBg: primary.step9,
  focusBorder: primary.step11,
  disabledBg: primary.step6,
  disabledBorder: primary.step6,
  outline: primary.step9,
  outlineHover: primary.step10,
  outlineFocus: primary.step11,
  outlineDisabled: primary.step6
};
const SecondaryLightButton = {
  text: secondary.step12,
  bg: secondary.step6,
  border: secondary.step6,
  hoverBg: secondary.step7,
  hoverBorder: secondary.step7,
  focusBg: secondary.step6,
  focusBorder: secondary.step8,
  disabledBg: secondary.step3,
  disabledBorder: secondary.step3,
  outline: secondary.step9,
  outlineHover: secondary.step10,
  outlineFocus: secondary.step11,
  outlineDisabled: secondary.step6
};
const TertiaryLightButton = {
  bg: utility.transparent,
  text: primary.step11,
  border: primary.step11,
  hoverText: primary.step10,
  hoverBorder: primary.step10,
  focusText: primary.step12,
  focusBorder: primary.step12,
  disabledText: primary.step6,
  disabledBorder: primary.step6,
  outline: primary.step9,
  outlineHover: primary.step10,
  outlineFocus: primary.step11,
  outlineDisabled: primary.step6
};
const SuccessLightButton = {
  text: success.step1,
  bg: success.step9,
  border: success.step9,
  hoverBg: success.step10,
  hoverBorder: success.step10,
  focusBg: success.step9,
  focusBorder: success.step11,
  disabledBg: success.step6,
  disabledBorder: success.step6,
  outline: success.step9,
  outlineHover: success.step10,
  outlineFocus: success.step11,
  outlineDisabled: success.step6
};
const WarningLightButton = {
  text: warning.step1,
  bg: warning.step9,
  border: warning.step9,
  hoverBg: warning.step10,
  hoverBorder: warning.step10,
  focusBg: warning.step9,
  focusBorder: warning.step11,
  disabledBg: warning.step6,
  disabledBorder: warning.step6,
  outline: warning.step9,
  outlineHover: warning.step10,
  outlineFocus: warning.step11,
  outlineDisabled: warning.step6
};
const DangerLightButton = {
  text: danger.step1,
  bg: danger.step9,
  border: danger.step9,
  hoverBg: danger.step10,
  hoverBorder: danger.step10,
  focusBg: danger.step9,
  focusBorder: danger.step11,
  disabledBg: danger.step6,
  disabledBorder: danger.step6,
  outline: danger.step9,
  outlineHover: danger.step10,
  outlineFocus: danger.step11,
  outlineDisabled: danger.step6
};

const FieldTheme = {
  bg: secondary.step3,
  border: secondary.step3,
  placeholderText: secondary.step11,
  hoverBg: secondary.step4,
  hoverBorder: secondary.step4,
  focusBg: secondary.step3,
  focusBorder: secondary.step6,
  disabledBg: neutral.step5,
  disabledBorder: neutral.step5,
  disabledColor: neutral.step11,
  disabledPlaceholder: neutral.step10
};
const FieldThemeDark = {
  bg: secondaryDark.step3,
  border: secondaryDark.step3,
  placeholderText: secondaryDark.step11,
  hoverBg: secondaryDark.step4,
  hoverBorder: secondaryDark.step4,
  focusBg: secondaryDark.step3,
  focusBorder: secondaryDark.step6,
  disabledBg: neutralDark.step5,
  disabledBorder: neutralDark.step5,
  disabledColor: neutralDark.step11,
  disabledPlaceholder: neutralDark.step10
};

const AppSwitcherDark = {
  bg: secondaryDark.step2,
  navLinkColor: secondaryDark.step9,
  navLinkHoverColor: secondaryDark.step10,
  navLinkSelected: secondaryDark.step12,
  navLinkDropdownText: secondaryDark.step12,
  hoverNavLinkDropdownBg: secondaryDark.step4,
  hoverNavLinkDropdownBorder: secondaryDark.step8,
  activeNavLinkDropdownBg: secondaryDark.step9,
  activeNavLinkDropdownBorder: secondaryDark.step6
};
const AppSwitcherLight = {
  bg: secondaryDark.step2,
  navLinkColor: secondaryDark.step9,
  navLinkHoverColor: secondaryDark.step10,
  navLinkSelected: secondaryDark.step12,
  navLinkDropdownText: secondaryDark.step12,
  hoverNavLinkDropdownBg: secondaryDark.step4,
  hoverNavLinkDropdownBorder: secondaryDark.step8,
  activeNavLinkDropdownBg: secondaryDark.step9,
  activeNavLinkDropdownBorder: secondaryDark.step6
};

const DropdownDark = {
  text: secondaryDark.step12,
  textDisabled: neutralDark.step11,
  bgMenu: secondaryDark.step3,
  bgItem: secondaryDark.step3,
  hoverItem: secondaryDark.step4,
  focusItem: secondaryDark.step5,
  acttiveItem: secondaryDark.step9
};
const DropdownLight = {
  text: secondary.step12,
  textDisabled: neutral.step11,
  bgMenu: secondary.step3,
  bgItem: secondary.step3,
  hoverItem: secondary.step4,
  focusItem: secondary.step5,
  acttiveItem: secondary.step9
};

const defaultDarkTheme = {
  themeName: "dark",
  bgColor: neutralDark.step1,
  fontColor: secondaryDark.step12,
  primary: primaryDark.step9,
  secondary: secondaryDark.step9,
  error: utilityDark.danger,
  warning: utilityDark.warning,
  warningBg: utilityDark.warningBg,
  warningBorder: utilityDark.warningBorder,
  success: utilityDark.success,
  disabled: neutralDark.step9,
  transparent: "transparent",
  info: utilityDark.info,
  tint: {
    secondary: secondaryDark.step11
  },
  button: {
    primary: PrimaryDarkButton,
    secondary: SecondaryDarkButton,
    tertiary: TertiaryDarkButton,
    success: SuccessDarkButton,
    warning: WarningDarkButton,
    danger: DangerDarkButton
  },
  card: {
    bg: secondaryDark.step2,
    border: secondaryDark.step5,
    hoverBg: secondaryDark.step3,
    hoverBorder: secondaryDark.step6,
    focusBg: secondaryDark.step2,
    focusBorder: secondaryDark.step7,
    disabledBg: neutralDark.step2,
    disabledBorder: neutralDark.step5,
    successText: utilityDark.successText,
    successBg: utilityDark.successBg,
    successBorder: utilityDark.successBorder,
    warningText: utilityDark.warningText,
    warningBg: utilityDark.warningBg,
    warningBorder: utilityDark.warningBorder,
    errorText: utilityDark.dangerText,
    errorBg: utilityDark.dangerBg,
    errorBorder: utilityDark.dangerBorder
  },
  checkbox: {
    bg: secondaryDark.step3,
    border: secondaryDark.step6,
    hoverBg: secondaryDark.step4,
    hoverBorder: secondaryDark.step6,
    focusBg: secondaryDark.step3,
    focusBorder: secondaryDark.step7,
    disabledBg: neutralDark.step2,
    disabledBorder: neutralDark.step6,
    activeBg: primaryDark.step3,
    activeBorder: primaryDark.step9,
    activeHoverBg: primaryDark.step4,
    activeHoverBorder: primaryDark.step9,
    activeFocusBg: primaryDark.step3,
    activeFocusBorder: primaryDark.step10,
    activeDisabledBg: neutralDark.step2,
    activeDisabledBorder: neutralDark.step9
  },
  field: FieldThemeDark,
  fieldAlert: {
    bg: primaryDark.step3,
    border: primaryDark.step6,
    warningText: orange$1.orange10,
    warningBg: orange$1.orange2,
    warningBorder: orange$1.orange5,
    warningButtonBg: utilityDark.warning,
    warningButtonBorder: utilityDark.warning
  },
  link: {
    color: primaryDark.step10
  },
  progress: {
    bg: neutralDark.step8
  },
  radio: {
    item: {
      bg: secondaryDark.step3,
      border: secondaryDark.step6,
      hoverBg: secondaryDark.step4,
      hoverBorder: secondaryDark.step6,
      focusBg: secondaryDark.step3,
      focusBorder: secondaryDark.step7,
      disabledBg: neutralDark.step2,
      disabledBorder: neutralDark.step6,
      activeBg: primaryDark.step9,
      activeBorder: primaryDark.step9,
      activeHoverBg: primaryDark.step10,
      activeHoverBorder: primaryDark.step10,
      activeFocusBg: primaryDark.step9,
      activeFocusBorder: primaryDark.step11,
      activeDisabledBg: neutralDark.step9,
      activeDisabledBorder: neutralDark.step9
    },
    indicator: {
      bg: primaryDark.step3,
      disabledBg: neutralDark.step1
    }
  },
  select: {
    bg: secondaryDark.step3,
    text: secondaryDark.step11,
    borderColor: utilityDark.transparent
  },
  spinner: {
    topColor: primaryDark.step9,
    bottomColor: primaryDark.step4
  },
  switch: {
    bar: {
      bg: secondaryDark.step6,
      activeBg: primaryDark.step6,
      disabledBg: neutralDark.step6,
      activeDisabledBg: neutralDark.step6
    },
    thumb: {
      bg: secondaryDark.step9,
      border: secondaryDark.step9,
      hoverBg: secondaryDark.step10,
      hoverBorder: secondaryDark.step10,
      focusBg: secondaryDark.step9,
      focusBorder: secondaryDark.step11,
      disabledBg: neutralDark.step9,
      disabledBorder: neutralDark.step9,
      activeBg: primaryDark.step9,
      activeBorder: primaryDark.step9,
      activeHoverBg: primaryDark.step10,
      activeHoverBorder: primaryDark.step10,
      activeFocusBg: primaryDark.step9,
      activeFocusBorder: primaryDark.step11,
      activeDisabledBg: neutralDark.step9,
      activeDisabledBorder: neutralDark.step9
    }
  },
  collapsibleCard: {
    text: primaryDark.step11,
    hoverText: primaryDark.step10,
    focusText: primaryDark.step12,
    bgInnerCard: secondaryDarkA.step3,
    borderInnerCard: secondaryDark.step5
  },
  dropdown: DropdownDark,
  dialog: {
    bg: secondaryDark.step2,
    color: secondaryDark.step12
  },
  tooltip: {
    bg: secondaryDark.step6
  },
  toast: {
    bg: secondaryDark.step3,
    border: secondaryDark.step5,
    successText: utilityDark.successText,
    successBg: utilityDark.successBg,
    successBorder: utilityDark.successBorder,
    warningText: utilityDark.warningText,
    warningBg: utilityDark.warningBg,
    warningBorder: utilityDark.warningBorder,
    errorText: utilityDark.dangerText,
    errorBg: utilityDark.dangerBg,
    errorBorder: utilityDark.dangerBorder,
    icon: {
      default: utilityDark.success,
      success: utilityDark.success,
      warning: utilityDark.warning,
      error: utilityDark.danger
    }
  },
  navTabs: {
    bg: secondaryDark.step2,
    navLinkColor: secondaryDark.step9,
    navLinkHoverColor: secondaryDark.step10,
    navLinkSelected: secondaryDark.step12,
    navLinkDropdownText: secondaryDark.step12,
    hoverNavLinkDropdownBg: secondaryDark.step4,
    hoverNavLinkDropdownBorder: secondaryDark.step8,
    activeNavLinkDropdownBg: secondaryDark.step9,
    activeNavLinkDropdownBorder: secondaryDark.step6
  },
  appSwitcher: AppSwitcherDark
};
const defaultLightTheme = {
  themeName: "light",
  bgColor: secondary.step1,
  fontColor: secondary.step12,
  primary: primary.step9,
  secondary: secondary.step9,
  error: utility.danger,
  warning: utility.warning,
  warningBg: utility.warningBg,
  warningBorder: utility.warningBorder,
  success: utility.success,
  info: utility.info,
  transparent: utility.transparent,
  tint: {
    secondary: secondary.step11
  },
  disabled: neutral.step9,
  button: {
    primary: PrimaryLightButton,
    secondary: SecondaryLightButton,
    tertiary: TertiaryLightButton,
    success: SuccessLightButton,
    warning: WarningLightButton,
    danger: DangerLightButton
  },
  card: {
    bg: secondary.step2,
    border: secondary.step5,
    hoverBg: secondary.step3,
    hoverBorder: secondary.step6,
    focusBg: secondary.step2,
    focusBorder: secondary.step7,
    disabledBg: neutral.step2,
    disabledBorder: neutral.step5,
    successText: utility.successText,
    successBg: utility.successBg,
    successBorder: utility.successBorder,
    warningText: utility.warningText,
    warningBg: utility.warningBg,
    warningBorder: utility.warningBorder,
    errorText: utility.dangerText,
    errorBg: utility.dangerBg,
    errorBorder: utility.dangerBorder
  },
  checkbox: {
    bg: secondary.step3,
    border: secondary.step6,
    hoverBg: secondary.step4,
    hoverBorder: secondary.step6,
    focusBg: secondary.step3,
    focusBorder: secondary.step7,
    disabledBg: neutral.step2,
    disabledBorder: neutral.step6,
    activeBg: primaryDark.step3,
    activeBorder: primaryDark.step9,
    activeHoverBg: primaryDark.step4,
    activeHoverBorder: primaryDark.step9,
    activeFocusBg: primaryDark.step3,
    activeFocusBorder: primaryDark.step10,
    activeDisabledBg: neutral.step2,
    activeDisabledBorder: neutral.step9
  },
  field: FieldTheme,
  fieldAlert: {
    bg: primary.step3,
    border: primary.step6,
    warningText: orange$1.orange10,
    warningBg: orange$1.orange2,
    warningBorder: orange$1.orange5,
    warningButtonBg: utilityDark.warning,
    warningButtonBorder: utilityDark.warning
  },
  link: {
    color: primaryDark.step10
  },
  progress: {
    bg: neutral.step10
  },
  radio: {
    item: {
      bg: secondary.step3,
      border: secondary.step6,
      hoverBg: secondary.step4,
      hoverBorder: secondary.step6,
      focusBg: secondary.step3,
      focusBorder: secondary.step7,
      disabledBg: neutral.step2,
      disabledBorder: neutral.step6,
      activeBg: primaryDark.step9,
      activeBorder: primaryDark.step9,
      activeHoverBg: primaryDark.step10,
      activeHoverBorder: primaryDark.step10,
      activeFocusBg: primaryDark.step9,
      activeFocusBorder: primaryDark.step11,
      activeDisabledBg: neutral.step9,
      activeDisabledBorder: neutral.step9
    },
    indicator: {
      bg: primaryDark.step3,
      disabledBg: neutral.step1
    }
  },
  select: {
    bg: secondary.step3,
    text: secondary.step11,
    borderColor: utility.transparent
  },
  spinner: {
    topColor: primaryDark.step9,
    bottomColor: primaryDark.step4
  },
  switch: {
    bar: {
      bg: secondary.step6,
      activeBg: primaryDark.step6,
      disabledBg: neutral.step6,
      activeDisabledBg: neutral.step6
    },
    thumb: {
      bg: secondary.step9,
      border: secondary.step9,
      hoverBg: secondary.step10,
      hoverBorder: secondary.step10,
      focusBg: secondary.step9,
      focusBorder: secondary.step11,
      disabledBg: neutral.step9,
      disabledBorder: neutral.step9,
      activeBg: primaryDark.step9,
      activeBorder: primaryDark.step9,
      activeHoverBg: primaryDark.step10,
      activeHoverBorder: primaryDark.step10,
      activeFocusBg: primaryDark.step9,
      activeFocusBorder: primaryDark.step11,
      activeDisabledBg: neutral.step9,
      activeDisabledBorder: neutral.step9
    }
  },
  collapsibleCard: {
    text: primary.step11,
    hoverText: primary.step10,
    focusText: primary.step12,
    bgInnerCard: secondary.step5,
    borderInnerCard: secondary.step6
  },
  dropdown: DropdownLight,
  dialog: {
    bg: secondary.step2,
    color: secondary.step12
  },
  tooltip: {
    bg: secondary.step6
  },
  toast: {
    bg: secondary.step3,
    border: secondary.step5,
    successText: utility.successText,
    successBg: utility.successBg,
    successBorder: utility.successBorder,
    warningText: utility.warningText,
    warningBg: utility.warningBg,
    warningBorder: utility.warningBorder,
    errorText: utility.dangerText,
    errorBg: utility.dangerBg,
    errorBorder: utility.dangerBorder,
    icon: {
      default: utility.success,
      success: utility.success,
      warning: utility.warning,
      error: utility.danger
    }
  },
  navTabs: {
    bg: secondary.step2,
    navLinkColor: secondary.step9,
    navLinkHoverColor: secondary.step10,
    navLinkSelected: secondary.step12,
    navLinkDropdownText: secondary.step12,
    hoverNavLinkDropdownBg: secondary.step4,
    hoverNavLinkDropdownBorder: secondary.step8,
    activeNavLinkDropdownBg: secondary.step9,
    activeNavLinkDropdownBorder: secondary.step6
  },
  appSwitcher: AppSwitcherLight
};

var fonts = '';

// We have resorted to returning slots directly rather than exposing primitives that can then
// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.
// This is because we encountered issues with generic types that cannot be statically analysed
// due to creating them dynamically via createCollection.
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
    /* -----------------------------------------------------------------------------------------------
   * CollectionProvider
   * ---------------------------------------------------------------------------------------------*/ const PROVIDER_NAME = name + 'CollectionProvider';
    const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
        collectionRef: {
            current: null
        },
        itemMap: new Map()
    });
    const CollectionProvider = (props)=>{
        const { scope: scope , children: children  } = props;
        const ref = React__default.useRef(null);
        const itemMap = React__default.useRef(new Map()).current;
        return /*#__PURE__*/ React__default.createElement(CollectionProviderImpl, {
            scope: scope,
            itemMap: itemMap,
            collectionRef: ref
        }, children);
    };
    /* -----------------------------------------------------------------------------------------------
   * CollectionSlot
   * ---------------------------------------------------------------------------------------------*/ const COLLECTION_SLOT_NAME = name + 'CollectionSlot';
    const CollectionSlot = /*#__PURE__*/ React__default.forwardRef((props, forwardedRef)=>{
        const { scope: scope , children: children  } = props;
        const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
        const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);
        return /*#__PURE__*/ React__default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
            ref: composedRefs
        }, children);
    });
    /* -----------------------------------------------------------------------------------------------
   * CollectionItem
   * ---------------------------------------------------------------------------------------------*/ const ITEM_SLOT_NAME = name + 'CollectionItemSlot';
    const ITEM_DATA_ATTR = 'data-radix-collection-item';
    const CollectionItemSlot = /*#__PURE__*/ React__default.forwardRef((props, forwardedRef)=>{
        const { scope: scope , children: children , ...itemData } = props;
        const ref = React__default.useRef(null);
        const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
        const context = useCollectionContext(ITEM_SLOT_NAME, scope);
        React__default.useEffect(()=>{
            context.itemMap.set(ref, {
                ref: ref,
                ...itemData
            });
            return ()=>void context.itemMap.delete(ref)
            ;
        });
        return /*#__PURE__*/ React__default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
            [ITEM_DATA_ATTR]: '',
            ref: composedRefs
        }, children);
    });
    /* -----------------------------------------------------------------------------------------------
   * useCollection
   * ---------------------------------------------------------------------------------------------*/ function useCollection(scope) {
        const context = useCollectionContext(name + 'CollectionConsumer', scope);
        const getItems = React__default.useCallback(()=>{
            const collectionNode = context.collectionRef.current;
            if (!collectionNode) return [];
            const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
            const items = Array.from(context.itemMap.values());
            const orderedItems = items.sort((a, b)=>orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
            );
            return orderedItems;
        }, [
            context.collectionRef,
            context.itemMap
        ]);
        return getItems;
    }
    return [
        {
            Provider: CollectionProvider,
            Slot: CollectionSlot,
            ItemSlot: CollectionItemSlot
        },
        useCollection,
        createCollectionScope
    ];
}

/* -------------------------------------------------------------------------------------------------
 * ToastProvider
 * -----------------------------------------------------------------------------------------------*/ const $054eb8030ebde76e$var$PROVIDER_NAME = 'ToastProvider';
const [$054eb8030ebde76e$var$Collection, $054eb8030ebde76e$var$useCollection, $054eb8030ebde76e$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2('Toast');
const [$054eb8030ebde76e$var$createToastContext, $054eb8030ebde76e$export$8a359da18fbc9073] = $c512c27ab02ef895$export$50c7b4e9d9f19c1('Toast', [
    $054eb8030ebde76e$var$createCollectionScope
]);
const [$054eb8030ebde76e$var$ToastProviderProvider, $054eb8030ebde76e$var$useToastProviderContext] = $054eb8030ebde76e$var$createToastContext($054eb8030ebde76e$var$PROVIDER_NAME);
const $054eb8030ebde76e$export$f5d03d415824e0e = (props)=>{
    const { __scopeToast: __scopeToast , label: label = 'Notification' , duration: duration = 5000 , swipeDirection: swipeDirection = 'right' , swipeThreshold: swipeThreshold = 50 , children: children  } = props;
    const [viewport, setViewport] = useState$1(null);
    const [toastCount, setToastCount] = useState$1(0);
    const isFocusedToastEscapeKeyDownRef = useRef(false);
    const isClosePausedRef = useRef(false);
    return /*#__PURE__*/ createElement($054eb8030ebde76e$var$Collection.Provider, {
        scope: __scopeToast
    }, /*#__PURE__*/ createElement($054eb8030ebde76e$var$ToastProviderProvider, {
        scope: __scopeToast,
        label: label,
        duration: duration,
        swipeDirection: swipeDirection,
        swipeThreshold: swipeThreshold,
        toastCount: toastCount,
        viewport: viewport,
        onViewportChange: setViewport,
        onToastAdd: useCallback(()=>setToastCount((prevCount)=>prevCount + 1
            )
        , []),
        onToastRemove: useCallback(()=>setToastCount((prevCount)=>prevCount - 1
            )
        , []),
        isFocusedToastEscapeKeyDownRef: isFocusedToastEscapeKeyDownRef,
        isClosePausedRef: isClosePausedRef
    }, children));
};
$054eb8030ebde76e$export$f5d03d415824e0e.propTypes = {
    label (props) {
        if (props.label && typeof props.label === 'string' && !props.label.trim()) {
            const error = `Invalid prop \`label\` supplied to \`${$054eb8030ebde76e$var$PROVIDER_NAME}\`. Expected non-empty \`string\`.`;
            return new Error(error);
        }
        return null;
    }
};
/* -------------------------------------------------------------------------------------------------
 * ToastViewport
 * -----------------------------------------------------------------------------------------------*/ const $054eb8030ebde76e$var$VIEWPORT_NAME = 'ToastViewport';
const $054eb8030ebde76e$var$VIEWPORT_DEFAULT_HOTKEY = [
    'F8'
];
const $054eb8030ebde76e$var$VIEWPORT_PAUSE = 'toast.viewportPause';
const $054eb8030ebde76e$var$VIEWPORT_RESUME = 'toast.viewportResume';
const $054eb8030ebde76e$export$6192c2425ecfd989 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeToast: __scopeToast , hotkey: hotkey = $054eb8030ebde76e$var$VIEWPORT_DEFAULT_HOTKEY , label: label = 'Notifications ({hotkey})' , ...viewportProps } = props;
    const context = $054eb8030ebde76e$var$useToastProviderContext($054eb8030ebde76e$var$VIEWPORT_NAME, __scopeToast);
    const getItems = $054eb8030ebde76e$var$useCollection(__scopeToast);
    const wrapperRef = useRef(null);
    const headFocusProxyRef = useRef(null);
    const tailFocusProxyRef = useRef(null);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');
    const hasToasts = context.toastCount > 0;
    useEffect$1(()=>{
        const handleKeyDown = (event)=>{
            var _ref$current;
            // we use `event.code` as it is consistent regardless of meta keys that were pressed.
            // for example, `event.key` for `Control+Alt+t` is `â€ ` and `t !== â€ `
            const isHotkeyPressed = hotkey.every((key)=>event[key] || event.code === key
            );
            if (isHotkeyPressed) (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
        };
        document.addEventListener('keydown', handleKeyDown);
        return ()=>document.removeEventListener('keydown', handleKeyDown)
        ;
    }, [
        hotkey
    ]);
    useEffect$1(()=>{
        const wrapper = wrapperRef.current;
        const viewport = ref.current;
        if (wrapper && viewport) {
            const handlePause = ()=>{
                const pauseEvent = new CustomEvent($054eb8030ebde76e$var$VIEWPORT_PAUSE);
                viewport.dispatchEvent(pauseEvent);
                context.isClosePausedRef.current = true;
            };
            const handleResume = ()=>{
                const resumeEvent = new CustomEvent($054eb8030ebde76e$var$VIEWPORT_RESUME);
                viewport.dispatchEvent(resumeEvent);
                context.isClosePausedRef.current = false;
            }; // Toasts are not in the viewport React tree so we need to bind DOM events
            wrapper.addEventListener('focusin', handlePause);
            wrapper.addEventListener('focusout', handleResume);
            wrapper.addEventListener('pointerenter', handlePause);
            wrapper.addEventListener('pointerleave', handleResume);
            window.addEventListener('blur', handlePause);
            window.addEventListener('focus', handleResume);
            return ()=>{
                wrapper.removeEventListener('focusin', handlePause);
                wrapper.removeEventListener('focusout', handleResume);
                wrapper.removeEventListener('pointerenter', handlePause);
                wrapper.removeEventListener('pointerleave', handleResume);
                window.removeEventListener('blur', handlePause);
                window.removeEventListener('focus', handleResume);
            };
        }
    }, [
        context.isClosePausedRef
    ]);
    const getSortedTabbableCandidates = useCallback(({ tabbingDirection: tabbingDirection  })=>{
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem)=>{
            const toastNode = toastItem.ref.current;
            const toastTabbableCandidates = [
                toastNode,
                ...$054eb8030ebde76e$var$getTabbableCandidates(toastNode)
            ];
            return tabbingDirection === 'forwards' ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates).flat();
    }, [
        getItems
    ]);
    useEffect$1(()=>{
        const viewport = ref.current; // We programmatically manage tabbing as we are unable to influence
        // the source order with portals, this allows us to reverse the
        // tab order so that it runs from most recent toast to least
        if (viewport) {
            const handleKeyDown = (event)=>{
                const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
                const isTabKey = event.key === 'Tab' && !isMetaKey;
                if (isTabKey) {
                    const focusedElement = document.activeElement;
                    const isTabbingBackwards = event.shiftKey;
                    const targetIsViewport = event.target === viewport; // If we're back tabbing after jumping to the viewport then we simply
                    // proxy focus out to the preceding document
                    if (targetIsViewport && isTabbingBackwards) {
                        var _headFocusProxyRef$cu;
                        (_headFocusProxyRef$cu = headFocusProxyRef.current) === null || _headFocusProxyRef$cu === void 0 || _headFocusProxyRef$cu.focus();
                        return;
                    }
                    const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';
                    const sortedCandidates = getSortedTabbableCandidates({
                        tabbingDirection: tabbingDirection
                    });
                    const index = sortedCandidates.findIndex((candidate)=>candidate === focusedElement
                    );
                    if ($054eb8030ebde76e$var$focusFirst(sortedCandidates.slice(index + 1))) event.preventDefault();
                    else {
                        var _headFocusProxyRef$cu2, _tailFocusProxyRef$cu;
                        // If we can't focus that means we're at the edges so we
                        // proxy to the corresponding exit point and let the browser handle
                        // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document
                        isTabbingBackwards ? (_headFocusProxyRef$cu2 = headFocusProxyRef.current) === null || _headFocusProxyRef$cu2 === void 0 || _headFocusProxyRef$cu2.focus() : (_tailFocusProxyRef$cu = tailFocusProxyRef.current) === null || _tailFocusProxyRef$cu === void 0 || _tailFocusProxyRef$cu.focus();
                    }
                }
            }; // Toasts are not in the viewport React tree so we need to bind DOM events
            viewport.addEventListener('keydown', handleKeyDown);
            return ()=>viewport.removeEventListener('keydown', handleKeyDown)
            ;
        }
    }, [
        getItems,
        getSortedTabbableCandidates
    ]);
    return /*#__PURE__*/ createElement($5cb92bef7577960e$export$aecb2ddcb55c95be, {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace('{hotkey}', hotkeyLabel) // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume
        ,
        tabIndex: -1 // incase list has size when empty (e.g. padding), we remove pointer events so
        ,
        style: {
            pointerEvents: hasToasts ? undefined : 'none'
        }
    }, hasToasts && /*#__PURE__*/ createElement($054eb8030ebde76e$var$FocusProxy, {
        ref: headFocusProxyRef,
        onFocusFromOutsideViewport: ()=>{
            const tabbableCandidates = getSortedTabbableCandidates({
                tabbingDirection: 'forwards'
            });
            $054eb8030ebde76e$var$focusFirst(tabbableCandidates);
        }
    }), /*#__PURE__*/ createElement($054eb8030ebde76e$var$Collection.Slot, {
        scope: __scopeToast
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.ol, _extends$2({
        tabIndex: -1
    }, viewportProps, {
        ref: composedRefs
    }))), hasToasts && /*#__PURE__*/ createElement($054eb8030ebde76e$var$FocusProxy, {
        ref: tailFocusProxyRef,
        onFocusFromOutsideViewport: ()=>{
            const tabbableCandidates = getSortedTabbableCandidates({
                tabbingDirection: 'backwards'
            });
            $054eb8030ebde76e$var$focusFirst(tabbableCandidates);
        }
    }));
});
/* -----------------------------------------------------------------------------------------------*/ const $054eb8030ebde76e$var$FOCUS_PROXY_NAME = 'ToastFocusProxy';
const $054eb8030ebde76e$var$FocusProxy = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeToast: __scopeToast , onFocusFromOutsideViewport: onFocusFromOutsideViewport , ...proxyProps } = props;
    const context = $054eb8030ebde76e$var$useToastProviderContext($054eb8030ebde76e$var$FOCUS_PROXY_NAME, __scopeToast);
    return /*#__PURE__*/ createElement($ea1ef594cf570d83$export$439d29a4e110a164, _extends$2({
        "aria-hidden": true,
        tabIndex: 0
    }, proxyProps, {
        ref: forwardedRef // Avoid page scrolling when focus is on the focus proxy
        ,
        style: {
            position: 'fixed'
        },
        onFocus: (event)=>{
            var _context$viewport;
            const prevFocusedElement = event.relatedTarget;
            const isFocusFromOutsideViewport = !((_context$viewport = context.viewport) !== null && _context$viewport !== void 0 && _context$viewport.contains(prevFocusedElement));
            if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
    }));
});
/* -------------------------------------------------------------------------------------------------
 * Toast
 * -----------------------------------------------------------------------------------------------*/ const $054eb8030ebde76e$var$TOAST_NAME = 'Toast';
const $054eb8030ebde76e$var$TOAST_SWIPE_START = 'toast.swipeStart';
const $054eb8030ebde76e$var$TOAST_SWIPE_MOVE = 'toast.swipeMove';
const $054eb8030ebde76e$var$TOAST_SWIPE_CANCEL = 'toast.swipeCancel';
const $054eb8030ebde76e$var$TOAST_SWIPE_END = 'toast.swipeEnd';
const $054eb8030ebde76e$export$8d8dc7d5f743331b = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { forceMount: forceMount , open: openProp , defaultOpen: defaultOpen , onOpenChange: onOpenChange , ...toastProps } = props;
    const [open = true, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: onOpenChange
    });
    return /*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || open
    }, /*#__PURE__*/ createElement($054eb8030ebde76e$var$ToastImpl, _extends$2({
        open: open
    }, toastProps, {
        ref: forwardedRef,
        onClose: ()=>setOpen(false)
        ,
        onSwipeStart: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeStart, (event)=>{
            event.currentTarget.setAttribute('data-swipe', 'start');
        }),
        onSwipeMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeMove, (event)=>{
            const { x: x , y: y  } = event.detail.delta;
            event.currentTarget.setAttribute('data-swipe', 'move');
            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);
            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);
        }),
        onSwipeCancel: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeCancel, (event)=>{
            event.currentTarget.setAttribute('data-swipe', 'cancel');
            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');
            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');
            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');
            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');
        }),
        onSwipeEnd: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeEnd, (event)=>{
            const { x: x , y: y  } = event.detail.delta;
            event.currentTarget.setAttribute('data-swipe', 'end');
            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');
            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');
            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);
            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);
            setOpen(false);
        })
    })));
});
/* -----------------------------------------------------------------------------------------------*/ const [$054eb8030ebde76e$var$ToastInteractiveProvider, $054eb8030ebde76e$var$useToastInteractiveContext] = $054eb8030ebde76e$var$createToastContext($054eb8030ebde76e$var$TOAST_NAME, {
    isInteractive: false,
    onClose () {}
});
const $054eb8030ebde76e$var$ToastImpl = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeToast: __scopeToast , type: type = 'foreground' , duration: durationProp , open: open , onClose: onClose , onEscapeKeyDown: onEscapeKeyDown , onSwipeStart: onSwipeStart , onSwipeMove: onSwipeMove , onSwipeCancel: onSwipeCancel , onSwipeEnd: onSwipeEnd , ...toastProps } = props;
    const context = $054eb8030ebde76e$var$useToastProviderContext($054eb8030ebde76e$var$TOAST_NAME, __scopeToast);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const pointerStartRef = useRef(null);
    const swipeDeltaRef = useRef(null);
    const duration1 = durationProp || context.duration;
    const closeTimerStartTimeRef = useRef(0);
    const closeTimerRemainingTimeRef = useRef(duration1);
    const closeTimerRef = useRef(0);
    const { onToastAdd: onToastAdd , onToastRemove: onToastRemove  } = context;
    const handleClose = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(()=>{
        var _ref$current2, _context$viewport2;
        // focus viewport if focus is within toast to read the remaining toast
        // count to SR users and ensure focus isn't lost
        const isFocusInToast = (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.contains(document.activeElement);
        if (isFocusInToast) (_context$viewport2 = context.viewport) === null || _context$viewport2 === void 0 || _context$viewport2.focus();
        onClose();
    });
    const startTimer = useCallback((duration)=>{
        if (!duration || duration === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = new Date().getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration);
    }, [
        handleClose
    ]);
    useEffect$1(()=>{
        const viewport = context.viewport;
        if (viewport) {
            const handleResume = ()=>{
                startTimer(closeTimerRemainingTimeRef.current);
            };
            const handlePause = ()=>{
                const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;
                closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
                window.clearTimeout(closeTimerRef.current);
            };
            viewport.addEventListener($054eb8030ebde76e$var$VIEWPORT_PAUSE, handlePause);
            viewport.addEventListener($054eb8030ebde76e$var$VIEWPORT_RESUME, handleResume);
            return ()=>{
                viewport.removeEventListener($054eb8030ebde76e$var$VIEWPORT_PAUSE, handlePause);
                viewport.removeEventListener($054eb8030ebde76e$var$VIEWPORT_RESUME, handleResume);
            };
        }
    }, [
        context.viewport,
        duration1,
        startTimer
    ]); // start timer when toast opens or duration changes.
    // we include `open` in deps because closed !== unmounted when animating
    // so it could reopen before being completely unmounted
    useEffect$1(()=>{
        if (open && !context.isClosePausedRef.current) startTimer(duration1);
    }, [
        open,
        duration1,
        context.isClosePausedRef,
        startTimer
    ]);
    useEffect$1(()=>{
        onToastAdd();
        return ()=>onToastRemove()
        ;
    }, [
        onToastAdd,
        onToastRemove
    ]);
    if (!context.viewport) return null;
    return /*#__PURE__*/ createElement(Fragment$1, null, /*#__PURE__*/ createElement($054eb8030ebde76e$var$ToastAnnounce, {
        __scopeToast: __scopeToast // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.
        ,
        role: "status",
        "aria-live": type === 'foreground' ? 'assertive' : 'polite',
        "aria-atomic": true
    }, props.children), /*#__PURE__*/ createElement($054eb8030ebde76e$var$ToastInteractiveProvider, {
        scope: __scopeToast,
        isInteractive: true,
        onClose: handleClose
    }, /*#__PURE__*/ createPortal(/*#__PURE__*/ createElement($054eb8030ebde76e$var$Collection.ItemSlot, {
        scope: __scopeToast
    }, /*#__PURE__*/ createElement($5cb92bef7577960e$export$be92b6f5f03c0fe9, {
        asChild: true,
        onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEscapeKeyDown, ()=>{
            if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
            context.isFocusedToastEscapeKeyDownRef.current = false;
        })
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.li, _extends$2({
        tabIndex: 0,
        "data-state": open ? 'open' : 'closed',
        "data-swipe-direction": context.swipeDirection
    }, toastProps, {
        ref: composedRefs,
        style: {
            userSelect: 'none',
            touchAction: 'none',
            ...props.style
        },
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event)=>{
            if (event.key !== 'Escape') return;
            onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event.nativeEvent);
            if (!event.nativeEvent.defaultPrevented) {
                context.isFocusedToastEscapeKeyDownRef.current = true;
                handleClose();
            }
        }),
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event)=>{
            if (event.button !== 0) return;
            pointerStartRef.current = {
                x: event.clientX,
                y: event.clientY
            };
        }),
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event)=>{
            if (!pointerStartRef.current) return;
            const x = event.clientX - pointerStartRef.current.x;
            const y = event.clientY - pointerStartRef.current.y;
            const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
            const isHorizontalSwipe = [
                'left',
                'right'
            ].includes(context.swipeDirection);
            const clamp = [
                'left',
                'up'
            ].includes(context.swipeDirection) ? Math.min : Math.max;
            const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
            const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
            const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;
            const delta = {
                x: clampedX,
                y: clampedY
            };
            const eventDetail = {
                originalEvent: event,
                delta: delta
            };
            if (hasSwipeMoveStarted) {
                swipeDeltaRef.current = delta;
                $054eb8030ebde76e$var$handleAndDispatchCustomEvent($054eb8030ebde76e$var$TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                    discrete: false
                });
            } else if ($054eb8030ebde76e$var$isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                swipeDeltaRef.current = delta;
                $054eb8030ebde76e$var$handleAndDispatchCustomEvent($054eb8030ebde76e$var$TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                    discrete: false
                });
                event.target.setPointerCapture(event.pointerId);
            } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) // User is swiping in wrong direction so we disable swipe gesture
            // for the current pointer down interaction
            pointerStartRef.current = null;
        }),
        onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event1)=>{
            const delta = swipeDeltaRef.current;
            event1.target.releasePointerCapture(event1.pointerId);
            swipeDeltaRef.current = null;
            pointerStartRef.current = null;
            if (delta) {
                const toast = event1.currentTarget;
                const eventDetail = {
                    originalEvent: event1,
                    delta: delta
                };
                if ($054eb8030ebde76e$var$isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) $054eb8030ebde76e$var$handleAndDispatchCustomEvent($054eb8030ebde76e$var$TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                    discrete: true
                });
                else $054eb8030ebde76e$var$handleAndDispatchCustomEvent($054eb8030ebde76e$var$TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {
                    discrete: true
                });
                 // Prevent click event from triggering on items within the toast when
                // pointer up is part of a swipe gesture
                toast.addEventListener('click', (event)=>event.preventDefault()
                , {
                    once: true
                });
            }
        })
    })))), context.viewport)));
});
$054eb8030ebde76e$var$ToastImpl.propTypes = {
    type (props) {
        if (props.type && ![
            'foreground',
            'background'
        ].includes(props.type)) {
            const error = `Invalid prop \`type\` supplied to \`${$054eb8030ebde76e$var$TOAST_NAME}\`. Expected \`foreground | background\`.`;
            return new Error(error);
        }
        return null;
    }
};
/* -----------------------------------------------------------------------------------------------*/ const $054eb8030ebde76e$var$ToastAnnounce = (props)=>{
    const { __scopeToast: __scopeToast , children: children , ...announceProps } = props;
    const context = $054eb8030ebde76e$var$useToastProviderContext($054eb8030ebde76e$var$TOAST_NAME, __scopeToast);
    const [renderAnnounceText, setRenderAnnounceText] = useState$1(false);
    const [isAnnounced, setIsAnnounced] = useState$1(false);
    const [fragment, setFragment] = useState$1();
    const [rootFragmentNode, setRootFragmentNode] = useState$1(null); // We portal children into a document fragment so that we can extract the bare text nodes
    // before rendering to the DOM. This avoids issues with duplicate `children`
    // and animation libraries when composing via `asChild`.
    const announceTextContent = useMemo(()=>{
        return rootFragmentNode ? $054eb8030ebde76e$var$getAnnounceTextContent(rootFragmentNode) : null;
    }, [
        rootFragmentNode
    ]); // setting the fragment in `useLayoutEffect` as `DocumentFragment` doesn't exist on the server
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        setFragment(new DocumentFragment());
    }, []); // render text content in the next frame to ensure toast is announced in NVDA
    $054eb8030ebde76e$var$useNextFrame(()=>setRenderAnnounceText(true)
    );
    useEffect$1(()=>{
        const timer = window.setTimeout(()=>setIsAnnounced(true)
        , 1000);
        return ()=>window.clearTimeout(timer)
        ;
    }, []);
    return isAnnounced ? null : /*#__PURE__*/ createElement(Fragment$1, null, fragment && /*#__PURE__*/ createElement($f1701beae083dbae$export$602eac185826482c, {
        container: fragment,
        ref: setRootFragmentNode
    }, context.label, " ", children), /*#__PURE__*/ createElement($f1701beae083dbae$export$602eac185826482c, {
        asChild: true
    }, /*#__PURE__*/ createElement($ea1ef594cf570d83$export$439d29a4e110a164, announceProps, renderAnnounceText && announceTextContent)));
};
const $054eb8030ebde76e$export$16d42d7c29b95a4 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeToast: __scopeToast , ...titleProps } = props;
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, titleProps, {
        ref: forwardedRef
    }));
});
const $054eb8030ebde76e$export$ecddd96c53621d9a = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeToast: __scopeToast , ...descriptionProps } = props;
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, descriptionProps, {
        ref: forwardedRef
    }));
});
/* -------------------------------------------------------------------------------------------------
 * ToastAction
 * -----------------------------------------------------------------------------------------------*/ const $054eb8030ebde76e$var$ACTION_NAME = 'ToastAction';
const $054eb8030ebde76e$export$3019feecfda683d2 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { altText: altText , ...actionProps } = props;
    const context = $054eb8030ebde76e$var$useToastInteractiveContext($054eb8030ebde76e$var$ACTION_NAME, props.__scopeToast);
    if (!altText) return null;
    return context.isInteractive ? /*#__PURE__*/ createElement($054eb8030ebde76e$export$811e70f61c205839, _extends$2({}, actionProps, {
        ref: forwardedRef
    })) : /*#__PURE__*/ createElement("span", null, altText);
});
$054eb8030ebde76e$export$3019feecfda683d2.propTypes = {
    altText (props) {
        if (!props.altText) return new Error(`Missing prop \`altText\` expected on \`${$054eb8030ebde76e$var$ACTION_NAME}\``);
        return null;
    }
};
/* -------------------------------------------------------------------------------------------------
 * ToastClose
 * -----------------------------------------------------------------------------------------------*/ const $054eb8030ebde76e$var$CLOSE_NAME = 'ToastClose';
const $054eb8030ebde76e$export$811e70f61c205839 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeToast: __scopeToast , ...closeProps } = props;
    const interactiveContext = $054eb8030ebde76e$var$useToastInteractiveContext($054eb8030ebde76e$var$CLOSE_NAME, __scopeToast);
    return interactiveContext.isInteractive ? /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
        type: "button"
    }, closeProps, {
        ref: forwardedRef,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, interactiveContext.onClose)
    })) : null;
});
/* ---------------------------------------------------------------------------------------------- */ function $054eb8030ebde76e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete: discrete  }) {
    const currentTarget = detail.originalEvent.currentTarget;
    const event = new CustomEvent(name, {
        bubbles: true,
        cancelable: true,
        detail: detail
    });
    if (handler) currentTarget.addEventListener(name, handler, {
        once: true
    });
    if (discrete) $8927f6f2acc4f386$export$6d1a0317bde7de7f(currentTarget, event);
    else currentTarget.dispatchEvent(event);
}
const $054eb8030ebde76e$var$isDeltaInDirection = (delta, direction, threshold = 0)=>{
    const deltaX = Math.abs(delta.x);
    const deltaY = Math.abs(delta.y);
    const isDeltaX = deltaX > deltaY;
    if (direction === 'left' || direction === 'right') return isDeltaX && deltaX > threshold;
    else return !isDeltaX && deltaY > threshold;
};
function $054eb8030ebde76e$var$useNextFrame(callback = ()=>{}) {
    const fn = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback);
    $9f79659886946c16$export$e5c5a5f917a5871c(()=>{
        let raf1 = 0;
        let raf2 = 0;
        raf1 = window.requestAnimationFrame(()=>raf2 = window.requestAnimationFrame(fn)
        );
        return ()=>{
            window.cancelAnimationFrame(raf1);
            window.cancelAnimationFrame(raf2);
        };
    }, [
        fn
    ]);
}
function $054eb8030ebde76e$var$getAnnounceTextContent(container) {
    const textContent = [];
    const childNodes = Array.from(container.childNodes);
    childNodes.forEach((node)=>{
        if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
        if ($054eb8030ebde76e$var$isHTMLElement(node)) {
            const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';
            if (!isHidden) textContent.push(...$054eb8030ebde76e$var$getAnnounceTextContent(node));
        }
    }); // We return a collection of text rather than a single concatenated string.
    // This allows SR VO to naturally pause break between nodes while announcing.
    return textContent;
}
function $054eb8030ebde76e$var$isHTMLElement(node) {
    return node.nodeType === node.ELEMENT_NODE;
}
/**
 * Returns a list of potential tabbable candidates.
 *
 * NOTE: This is only a close approximation. For example it doesn't take into account cases like when
 * elements are not visible. This cannot be worked out easily by just reading a property, but rather
 * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker
 * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1
 */ function $054eb8030ebde76e$var$getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node)=>{
            const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';
            if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the
            // runtime's understanding of tabbability, so this automatically accounts
            // for any kind of element that could be tabbed to.
            return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
    });
    while(walker.nextNode())nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it
    // hinders accessibility to have tab order different from visual order.
    return nodes;
}
function $054eb8030ebde76e$var$focusFirst(candidates) {
    const previouslyFocusedElement = document.activeElement;
    return candidates.some((candidate)=>{
        // if focus is already where we want to go, we don't want to keep going through the candidates
        if (candidate === previouslyFocusedElement) return true;
        candidate.focus();
        return document.activeElement !== previouslyFocusedElement;
    });
}
const $054eb8030ebde76e$export$2881499e37b75b9a = $054eb8030ebde76e$export$f5d03d415824e0e;
const $054eb8030ebde76e$export$d5c6c08dc2d3ca7 = $054eb8030ebde76e$export$6192c2425ecfd989;
const $054eb8030ebde76e$export$be92b6f5f03c0fe9 = $054eb8030ebde76e$export$8d8dc7d5f743331b;
const $054eb8030ebde76e$export$f99233281efd08a0 = $054eb8030ebde76e$export$16d42d7c29b95a4;
const $054eb8030ebde76e$export$393edc798c47379d = $054eb8030ebde76e$export$ecddd96c53621d9a;
const $054eb8030ebde76e$export$e19cd5f9376f8cee = $054eb8030ebde76e$export$3019feecfda683d2;
const $054eb8030ebde76e$export$f39c2d165cd861fe = $054eb8030ebde76e$export$811e70f61c205839;

const ToastProvider = $054eb8030ebde76e$export$2881499e37b75b9a;
const ToastTitle = $054eb8030ebde76e$export$f99233281efd08a0;
const ToastDescription = $054eb8030ebde76e$export$393edc798c47379d;
const ToastClose = $054eb8030ebde76e$export$f39c2d165cd861fe;
const VIEWPORT_PADDING = 25;
const hide = keyframes`
0% { opacity: 1 };
  100% { opacity: 0 };
  `;
const slideIn = keyframes`
from { transform: translateX(calc(100% + ${VIEWPORT_PADDING}px)) };
to { transform: 'translateX(0)' };
`;
const swipeOut = keyframes({
  from: { transform: "translateX(var(--radix-toast-swipe-end-x))" },
  to: { transform: `translateX(calc(100% + ${VIEWPORT_PADDING}px))` }
});
const ToastViewport = styled($054eb8030ebde76e$export$d5c6c08dc2d3ca7)`
  position: fixed;
  bottom: 0;
  right: 0;
  display: flex;
  flex-direction: column;
  padding: 20px;
  gap: 10px;
  width: 395px;
  max-width: 90vw;
  margin: 0;
  list-style: none;
  z-index: 2147483647;
  outline: none;
`;
const ToastRoot = styled($054eb8030ebde76e$export$be92b6f5f03c0fe9)`
  display: flex;
  flex-direction: column;
  background-color: ${({ theme }) => theme.toast.bg};
  border: 1px solid ${({ theme }) => theme.toast.border};
  border-radius: 0.8rem;
  height: auto;
  padding: 2rem;
  width: auto;

  &.success {
    background-color: ${({ theme }) => theme.toast.successBg};
    border: 0.1rem solid
      ${({ theme }) => theme.toast.successBorder};
  }

  &.warning {
    background-color: ${({ theme }) => theme.toast.warningBg};
    border: 0.1rem solid
      ${({ theme }) => theme.toast.warningBorder};
  }

  &.error {
    background-color: ${({ theme }) => theme.toast.errorBg};
    border: 0.1rem solid
      ${({ theme }) => theme.toast.errorBorder};
  }

  @media (prefers-reduced-motion: no-preference) {
    &[data-state='open'] {
      animation: ${slideIn} 150ms cubic-bezier(0.16, 1, 0.3, 1);
    }
    &[data-state='closed'] {
      animation: ${hide} 100ms ease-in forwards;
    }
    &[data-swipe='move'] {
      transform: 'translateX(var(--radix-toast-swipe-move-x))';
    }
    &[data-swipe='cancel'] {
      transform: 'translateX(0)';
      transition: 'transform 200ms ease-out';
    }
    &[data-swipe='end'] {
      animation: ${swipeOut} 100ms ease-out forwards;
    }
  } ;
`;
const ToastHeaderContainer = styled.div`
  display: flex;
`;
const ToastIcon = styled.span`
  color: ${(props) => props.theme.toast.icon[props.iconType]};
  font-size: 24px;
  margin-right: 1rem;
`;
const ToastCopyContainer = styled.div`
  display: block;
  width: 100%;
`;
const ToastAction = styled($054eb8030ebde76e$export$e19cd5f9376f8cee)`
  display: flex;
  justify-content: space-between;
  margin-top: 20px;
`;
const CloseIcon$1 = styled.div`
  cursor: pointer;
  font-size: 17px;
`;

const HausThemeContext = createContext({
  theme: defaultDarkTheme,
  setTheme: () => null,
  toggleLightDark: () => void 0,
  setToast: () => void 0
});
const DEFAULT_TOAST_DURATION = 6e3;
const HausThemeProvider = ({
  children,
  defaultDark = defaultDarkTheme,
  defaultLight = defaultLightTheme,
  startDark = true
}) => {
  const [theme, setTheme] = useState$1(startDark ? defaultDark : defaultLight);
  const [toast, setToast] = useState$1(null);
  useEffect$1(() => {
    setTheme(startDark ? defaultDark : defaultLight);
  }, [startDark, defaultDark, defaultLight]);
  const toggleLightDark = () => {
    setTheme((prevState) => prevState.themeName === defaultDark.themeName ? defaultLight : defaultDark);
  };
  const handleOpenChange = (open) => {
    if (!open) {
      setToast(null);
    }
  };
  return /* @__PURE__ */ jsx(HausThemeContext.Provider, {
    value: {
      theme,
      setTheme,
      toggleLightDark,
      setToast
    },
    children: /* @__PURE__ */ jsx(ThemeProvider, {
      theme,
      children: /* @__PURE__ */ jsx(ToastProvider, {
        duration: toast?.duration || DEFAULT_TOAST_DURATION,
        children: /* @__PURE__ */ jsxs(Fragment, {
          children: [toast && /* @__PURE__ */ jsx(Toast, {
            ...toast,
            onOpenChange: handleOpenChange
          }), children, /* @__PURE__ */ jsx(GlobalStyles, {
            theme
          })]
        })
      })
    })
  });
};

const useToast = () => {
  const {
    setToast
  } = useContext(HausThemeContext);
  const defaultToast = ({
    title,
    description
  }) => {
    setToast({
      title,
      description,
      toastType: "default"
    });
  };
  const successToast = ({
    title,
    description
  }) => {
    setToast({
      title,
      description,
      toastType: "success"
    });
  };
  const warningToast = ({
    title,
    description
  }) => {
    setToast({
      title,
      description,
      toastType: "warning"
    });
  };
  const errorToast = ({
    title,
    description
  }) => {
    setToast({
      title,
      description,
      toastType: "error"
    });
  };
  return {
    setToast,
    defaultToast,
    successToast,
    warningToast,
    errorToast
  };
};

const useCopyToClipboard = () => {
  const [, setCopiedText] = useState$1(null);
  const {
    successToast,
    errorToast
  } = useToast();
  const copy = async (text, toastTitle = "Success", toastDescription = "was copied to your clipboard.") => {
    if (!navigator?.clipboard) {
      console.warn("Clipboard not supported");
      return false;
    }
    let toastText = text;
    if (text.startsWith("0x")) {
      toastText = truncateAddress(text);
    }
    try {
      await navigator.clipboard.writeText(text);
      setCopiedText(text);
      successToast({
        title: toastTitle,
        description: `${toastText} ${toastDescription}`
      });
      return true;
    } catch (error) {
      errorToast({
        title: "Copy failed:",
        description: `${error}`
      });
      setCopiedText(null);
      return false;
    }
  };
  return copy;
};

const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState$1(value);
  useEffect$1(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay || 500);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  return debouncedValue;
};

const AddressDisplay = ({
  address,
  explorerNetworkId,
  copy,
  truncate,
  txHash,
  textOverride,
  className,
  ...props
}) => {
  const theme = useTheme();
  const copyToClipboard = useCopyToClipboard();
  const explorerLink = useMemo(() => {
    if (explorerNetworkId) {
      return generateExplorerLink({
        chainId: explorerNetworkId,
        address,
        type: txHash ? "tx" : "address"
      });
    }
  }, [address, txHash, explorerNetworkId]);
  const handleCopy = () => {
    copyToClipboard(address, `Success ${txHash ? "Transaction Hash:" : "Address:"}`);
  };
  const displayAddress = truncate ? truncateAddress(address) : address;
  return /* @__PURE__ */ jsxs(AddressContainer, {
    className,
    children: [/* @__PURE__ */ jsx(AddressDataSm, {
      children: textOverride ? textOverride : displayAddress
    }), copy && /* @__PURE__ */ jsx(AddressCopyIcon, {
      children: /* @__PURE__ */ jsx(Icon, {
        children: /* @__PURE__ */ jsx(RiFileCopyLine, {
          size: "1.5rem",
          color: theme.link.color,
          onClick: handleCopy
        })
      })
    }), explorerLink && /* @__PURE__ */ jsx(Link, {
      href: explorerLink,
      linkType: "external"
    })]
  });
};

const StyledBanner = styled.div`
  align-items: center;
  display: flex;
  background-color: ${({ theme }) => theme.info};
  border: 1px solid ${({ theme }) => theme.info};
  color: ${({ theme }) => theme.fontColor};
  flex-wrap: wrap;
  height: auto;
  justify-content: space-between;
  min-height: 8rem;
  padding: 2rem 4rem;
  width: 100%;

  .banner--text-container {
    align-items: center;
    display: flex;
    margin-bottom: 1.6rem;
    @media (min-width: ${breakpoints.xs}) {
      margin-bottom: 0;
    }

    svg {
      font-size: 10.8rem;
      margin-right: 1.4rem;
      @media (min-width: ${breakpoints.xs}) {
        font-size: 2.8rem;
      }
    }
  }

  .banner--link-container {
    align-items: center;
    display: flex;
    justify-content: space-between;
    width: 100%;
    @media (min-width: ${breakpoints.xs}) {
      justify-content: flex-start;
      width: auto;
    }

    svg {
      font-size: 2.4rem;
      margin-right: 1rem;
    }
  }

  .banner--link-item {
    @media (min-width: ${breakpoints.xs}) {
      margin: 0 6rem;
    }
  }
`;

const Banner = ({
  className,
  bannerText = "DAOhaus v3 is currently in beta. Please report bugs, request features or provide feedback."
}) => {
  return /* @__PURE__ */ jsxs(StyledBanner, {
    className,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "banner--text-container",
      children: [/* @__PURE__ */ jsx(RiToolsLine, {}), /* @__PURE__ */ jsx(ParMd, {
        children: bannerText
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "banner--link-container",
      children: [/* @__PURE__ */ jsx(Link, {
        href: "https://github.com/HausDAO/daohaus-monorepo/issues/new/choose",
        linkType: "no-icon-external",
        className: "banner--link-item",
        children: "Give Feedback"
      }), /* @__PURE__ */ jsxs(Link, {
        linkType: "no-icon-external",
        href: "https://discord.gg/daohaus",
        children: [/* @__PURE__ */ jsx(RiDiscordFill, {}), "Support"]
      })]
    })]
  });
};

var isCheckBoxInput = (element) => element.type === 'checkbox';

var isDateObject = (value) => value instanceof Date;

var isNullOrUndefined = (value) => value == null;

const isObjectType = (value) => typeof value === 'object';
var isObject = (value) => !isNullOrUndefined(value) &&
    !Array.isArray(value) &&
    isObjectType(value) &&
    !isDateObject(value);

var getEventValue = (event) => isObject(event) && event.target
    ? isCheckBoxInput(event.target)
        ? event.target.checked
        : event.target.value
    : event;

var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;

var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));

var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];

var isUndefined = (val) => val === undefined;

var get = (obj, path, defaultValue) => {
    if (!path || !isObject(obj)) {
        return defaultValue;
    }
    const result = compact(path.split(/[,[\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);
    return isUndefined(result) || result === obj
        ? isUndefined(obj[path])
            ? defaultValue
            : obj[path]
        : result;
};

const EVENTS = {
    BLUR: 'blur',
    FOCUS_OUT: 'focusout',
    CHANGE: 'change',
};
const VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
    onTouched: 'onTouched',
    all: 'all',
};
const INPUT_VALIDATION_RULES = {
    max: 'max',
    min: 'min',
    maxLength: 'maxLength',
    minLength: 'minLength',
    pattern: 'pattern',
    required: 'required',
    validate: 'validate',
};

const HookFormContext = React__default.createContext(null);
/**
 * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.
 *
 * @remarks
 * [API](https://react-hook-form.com/api/useformcontext) â€¢ [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @returns return all useForm methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
const useFormContext = () => React__default.useContext(HookFormContext);
/**
 * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.
 *
 * @remarks
 * [API](https://react-hook-form.com/api/useformcontext) â€¢ [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)
 *
 * @param props - all useFrom methods
 *
 * @example
 * ```tsx
 * function App() {
 *   const methods = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   return (
 *     <FormProvider {...methods} >
 *       <form onSubmit={methods.handleSubmit(onSubmit)}>
 *         <NestedInput />
 *         <input type="submit" />
 *       </form>
 *     </FormProvider>
 *   );
 * }
 *
 *  function NestedInput() {
 *   const { register } = useFormContext(); // retrieve all hook methods
 *   return <input {...register("test")} />;
 * }
 * ```
 */
const FormProvider = (props) => {
    const { children, ...data } = props;
    return (React__default.createElement(HookFormContext.Provider, { value: data }, children));
};

var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
    const result = {
        defaultValues: control._defaultValues,
    };
    for (const key in formState) {
        Object.defineProperty(result, key, {
            get: () => {
                const _key = key;
                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
                }
                localProxyFormState && (localProxyFormState[_key] = true);
                return formState[_key];
            },
        });
    }
    return result;
};

var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;

var shouldRenderFormState = (formStateData, _proxyFormState, isRoot) => {
    const { name, ...formState } = formStateData;
    return (isEmptyObject(formState) ||
        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||
        Object.keys(formState).find((key) => _proxyFormState[key] ===
            (!isRoot || VALIDATION_MODE.all)));
};

var convertToArrayPayload = (value) => (Array.isArray(value) ? value : [value]);

var shouldSubscribeByName = (name, signalName, exact) => exact && signalName
    ? name === signalName
    : !name ||
        !signalName ||
        name === signalName ||
        convertToArrayPayload(name).some((currentName) => currentName &&
            (currentName.startsWith(signalName) ||
                signalName.startsWith(currentName)));

function useSubscribe(props) {
    const _props = React__default.useRef(props);
    _props.current = props;
    React__default.useEffect(() => {
        const subscription = !props.disabled &&
            _props.current.subject.subscribe({
                next: _props.current.callback,
            });
        return () => {
            subscription && subscription.unsubscribe();
        };
    }, [props.disabled]);
}

/**
 * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.
 *
 * @remarks
 * [API](https://react-hook-form.com/api/useformstate) â€¢ [Demo](https://codesandbox.io/s/useformstate-75xly)
 *
 * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, control } = useForm({
 *     defaultValues: {
 *     firstName: "firstName"
 *   }});
 *   const { dirtyFields } = useFormState({
 *     control
 *   });
 *   const onSubmit = (data) => console.log(data);
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input {...register("firstName")} placeholder="First Name" />
 *       {dirtyFields.firstName && <p>Field is dirty.</p>}
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useFormState(props) {
    const methods = useFormContext();
    const { control = methods.control, disabled, name, exact } = props || {};
    const [formState, updateFormState] = React__default.useState(control._formState);
    const _mounted = React__default.useRef(true);
    const _localProxyFormState = React__default.useRef({
        isDirty: false,
        dirtyFields: false,
        touchedFields: false,
        isValidating: false,
        isValid: false,
        errors: false,
    });
    const _name = React__default.useRef(name);
    _name.current = name;
    useSubscribe({
        disabled,
        callback: React__default.useCallback((value) => _mounted.current &&
            shouldSubscribeByName(_name.current, value.name, exact) &&
            shouldRenderFormState(value, _localProxyFormState.current) &&
            updateFormState({
                ...control._formState,
                ...value,
            }), [control, exact]),
        subject: control._subjects.state,
    });
    React__default.useEffect(() => {
        _mounted.current = true;
        return () => {
            _mounted.current = false;
        };
    }, []);
    return getProxyFormState(formState, control, _localProxyFormState.current, false);
}

var isString = (value) => typeof value === 'string';

var generateWatchOutput = (names, _names, formValues, isGlobal) => {
    const isArray = Array.isArray(names);
    if (isString(names)) {
        isGlobal && _names.watch.add(names);
        return get(formValues, names);
    }
    if (isArray) {
        return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName),
            get(formValues, fieldName)));
    }
    isGlobal && (_names.watchAll = true);
    return formValues;
};

var isFunction = (value) => typeof value === 'function';

var objectHasFunction = (data) => {
    for (const key in data) {
        if (isFunction(data[key])) {
            return true;
        }
    }
    return false;
};

/**
 * Custom hook to subscribe to field change and isolate re-rendering at the component level.
 *
 * @remarks
 *
 * [API](https://react-hook-form.com/api/usewatch) â€¢ [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)
 *
 * @example
 * ```tsx
 * const { watch } = useForm();
 * const values = useWatch({
 *   name: "fieldName"
 *   control,
 * })
 * ```
 */
function useWatch(props) {
    const methods = useFormContext();
    const { control = methods.control, name, defaultValue, disabled, exact, } = props || {};
    const _name = React__default.useRef(name);
    _name.current = name;
    useSubscribe({
        disabled,
        subject: control._subjects.watch,
        callback: React__default.useCallback((formState) => {
            if (shouldSubscribeByName(_name.current, formState.name, exact)) {
                const fieldValues = generateWatchOutput(_name.current, control._names, formState.values || control._formValues);
                updateValue(isUndefined(_name.current) ||
                    (isObject(fieldValues) && !objectHasFunction(fieldValues))
                    ? { ...fieldValues }
                    : Array.isArray(fieldValues)
                        ? [...fieldValues]
                        : isUndefined(fieldValues)
                            ? defaultValue
                            : fieldValues);
            }
        }, [control, exact, defaultValue]),
    });
    const [value, updateValue] = React__default.useState(isUndefined(defaultValue)
        ? control._getWatch(name)
        : defaultValue);
    React__default.useEffect(() => control._removeUnmounted());
    return value;
}

/**
 * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.
 *
 * @remarks
 * [API](https://react-hook-form.com/api/usecontroller) â€¢ [Demo](https://codesandbox.io/s/usecontroller-0o8px)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns field properties, field and form state. {@link UseControllerReturn}
 *
 * @example
 * ```tsx
 * function Input(props) {
 *   const { field, fieldState, formState } = useController(props);
 *   return (
 *     <div>
 *       <input {...field} placeholder={props.name} />
 *       <p>{fieldState.isTouched && "Touched"}</p>
 *       <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *     </div>
 *   );
 * }
 * ```
 */
function useController(props) {
    const methods = useFormContext();
    const { name, control = methods.control, shouldUnregister } = props;
    const isArrayField = isNameInFieldArray(control._names.array, name);
    const value = useWatch({
        control,
        name,
        defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
        exact: true,
    });
    const formState = useFormState({
        control,
        name,
    });
    const _registerProps = React__default.useRef(control.register(name, {
        ...props.rules,
        value,
    }));
    React__default.useEffect(() => {
        const updateMounted = (name, value) => {
            const field = get(control._fields, name);
            if (field) {
                field._f.mount = value;
            }
        };
        updateMounted(name, true);
        return () => {
            const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
            (isArrayField
                ? _shouldUnregisterField && !control._stateFlags.action
                : _shouldUnregisterField)
                ? control.unregister(name)
                : updateMounted(name, false);
        };
    }, [name, control, isArrayField, shouldUnregister]);
    return {
        field: {
            name,
            value,
            onChange: React__default.useCallback((event) => _registerProps.current.onChange({
                target: {
                    value: getEventValue(event),
                    name: name,
                },
                type: EVENTS.CHANGE,
            }), [name]),
            onBlur: React__default.useCallback(() => _registerProps.current.onBlur({
                target: {
                    value: get(control._formValues, name),
                    name: name,
                },
                type: EVENTS.BLUR,
            }), [name, control]),
            ref: (elm) => {
                const field = get(control._fields, name);
                if (field && elm) {
                    field._f.ref = {
                        focus: () => elm.focus(),
                        select: () => elm.select(),
                        setCustomValidity: (message) => elm.setCustomValidity(message),
                        reportValidity: () => elm.reportValidity(),
                    };
                }
            },
        },
        formState,
        fieldState: Object.defineProperties({}, {
            invalid: {
                enumerable: true,
                get: () => !!get(formState.errors, name),
            },
            isDirty: {
                enumerable: true,
                get: () => !!get(formState.dirtyFields, name),
            },
            isTouched: {
                enumerable: true,
                get: () => !!get(formState.touchedFields, name),
            },
            error: {
                enumerable: true,
                get: () => get(formState.errors, name),
            },
        }),
    };
}

/**
 * Component based on `useController` hook to work with controlled component.
 *
 * @remarks
 * [API](https://react-hook-form.com/api/usecontroller/controller) â€¢ [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) â€¢ [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)
 *
 * @param props - the path name to the form field value, and validation rules.
 *
 * @returns provide field handler functions, field and form state.
 *
 * @example
 * ```tsx
 * function App() {
 *   const { control } = useForm<FormValues>({
 *     defaultValues: {
 *       test: ""
 *     }
 *   });
 *
 *   return (
 *     <form>
 *       <Controller
 *         control={control}
 *         name="test"
 *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (
 *           <>
 *             <input
 *               onChange={onChange} // send value to hook form
 *               onBlur={onBlur} // notify when input is touched
 *               value={value} // return updated value
 *               ref={ref} // set ref for focus management
 *             />
 *             <p>{formState.isSubmitted ? "submitted" : ""}</p>
 *             <p>{fieldState.isTouched ? "touched" : ""}</p>
 *           </>
 *         )}
 *       />
 *     </form>
 *   );
 * }
 * ```
 */
const Controller = (props) => props.render(useController(props));

var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria
    ? {
        ...errors[name],
        types: {
            ...(errors[name] && errors[name].types ? errors[name].types : {}),
            [type]: message || true,
        },
    }
    : {};

var isKey = (value) => /^\w*$/.test(value);

var stringToPath = (input) => compact(input.replace(/["|']|\]/g, '').split(/\.|\[/));

function set(object, path, value) {
    let index = -1;
    const tempPath = isKey(path) ? [path] : stringToPath(path);
    const length = tempPath.length;
    const lastIndex = length - 1;
    while (++index < length) {
        const key = tempPath[index];
        let newValue = value;
        if (index !== lastIndex) {
            const objValue = object[key];
            newValue =
                isObject(objValue) || Array.isArray(objValue)
                    ? objValue
                    : !isNaN(+tempPath[index + 1])
                        ? []
                        : {};
        }
        object[key] = newValue;
        object = object[key];
    }
    return object;
}

const focusFieldBy = (fields, callback, fieldsNames) => {
    for (const key of fieldsNames || Object.keys(fields)) {
        const field = get(fields, key);
        if (field) {
            const { _f, ...currentField } = field;
            if (_f && callback(_f.name)) {
                if (_f.ref.focus) {
                    _f.ref.focus();
                    break;
                }
                else if (_f.refs && _f.refs[0].focus) {
                    _f.refs[0].focus();
                    break;
                }
            }
            else if (isObject(currentField)) {
                focusFieldBy(currentField, callback);
            }
        }
    }
};

var isWatched = (name, _names, isBlurEvent) => !isBlurEvent &&
    (_names.watchAll ||
        _names.watch.has(name) ||
        [..._names.watch].some((watchName) => name.startsWith(watchName) &&
            /^\.\w+/.test(name.slice(watchName.length))));

var updateFieldArrayRootError = (errors, error, name) => {
    const fieldArrayErrors = compact(get(errors, name));
    set(fieldArrayErrors, 'root', error[name]);
    set(errors, name, fieldArrayErrors);
    return errors;
};

var isBoolean = (value) => typeof value === 'boolean';

var isFileInput = (element) => element.type === 'file';

var isMessage = (value) => isString(value) || React__default.isValidElement(value);

var isRadioInput = (element) => element.type === 'radio';

var isRegex = (value) => value instanceof RegExp;

const defaultResult = {
    value: false,
    isValid: false,
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
    if (Array.isArray(options)) {
        if (options.length > 1) {
            const values = options
                .filter((option) => option && option.checked && !option.disabled)
                .map((option) => option.value);
            return { value: values, isValid: !!values.length };
        }
        return options[0].checked && !options[0].disabled
            ? // @ts-expect-error expected to work in the browser
                options[0].attributes && !isUndefined(options[0].attributes.value)
                    ? isUndefined(options[0].value) || options[0].value === ''
                        ? validResult
                        : { value: options[0].value, isValid: true }
                    : validResult
            : defaultResult;
    }
    return defaultResult;
};

const defaultReturn = {
    isValid: false,
    value: null,
};
var getRadioValue = (options) => Array.isArray(options)
    ? options.reduce((previous, option) => option && option.checked && !option.disabled
        ? {
            isValid: true,
            value: option.value,
        }
        : previous, defaultReturn)
    : defaultReturn;

function getValidateError(result, ref, type = 'validate') {
    if (isMessage(result) ||
        (Array.isArray(result) && result.every(isMessage)) ||
        (isBoolean(result) && !result)) {
        return {
            type,
            message: isMessage(result) ? result : '',
            ref,
        };
    }
}

var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)
    ? validationData
    : {
        value: validationData,
        message: '',
    };

var validateField = async (field, inputValue, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled, } = field._f;
    if (!mount || disabled) {
        return {};
    }
    const inputRef = refs ? refs[0] : ref;
    const setCustomValidity = (message) => {
        if (shouldUseNativeValidation && inputRef.reportValidity) {
            inputRef.setCustomValidity(isBoolean(message) ? '' : message || ' ');
            inputRef.reportValidity();
        }
    };
    const error = {};
    const isRadio = isRadioInput(ref);
    const isCheckBox = isCheckBoxInput(ref);
    const isRadioOrCheckbox = isRadio || isCheckBox;
    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||
        inputValue === '' ||
        (Array.isArray(inputValue) && !inputValue.length);
    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
        const message = exceedMax ? maxLengthMessage : minLengthMessage;
        error[name] = {
            type: exceedMax ? maxType : minType,
            message,
            ref,
            ...appendErrorsCurry(exceedMax ? maxType : minType, message),
        };
    };
    if (isFieldArray
        ? !Array.isArray(inputValue) || !inputValue.length
        : required &&
            ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||
                (isBoolean(inputValue) && !inputValue) ||
                (isCheckBox && !getCheckboxValue(refs).isValid) ||
                (isRadio && !getRadioValue(refs).isValid))) {
        const { value, message } = isMessage(required)
            ? { value: !!required, message: required }
            : getValueAndMessage(required);
        if (value) {
            error[name] = {
                type: INPUT_VALIDATION_RULES.required,
                message,
                ref: inputRef,
                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),
            };
            if (!validateAllFieldCriteria) {
                setCustomValidity(message);
                return error;
            }
        }
    }
    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
        let exceedMax;
        let exceedMin;
        const maxOutput = getValueAndMessage(max);
        const minOutput = getValueAndMessage(min);
        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
            const valueNumber = ref.valueAsNumber ||
                (inputValue ? +inputValue : inputValue);
            if (!isNullOrUndefined(maxOutput.value)) {
                exceedMax = valueNumber > maxOutput.value;
            }
            if (!isNullOrUndefined(minOutput.value)) {
                exceedMin = valueNumber < minOutput.value;
            }
        }
        else {
            const valueDate = ref.valueAsDate || new Date(inputValue);
            if (isString(maxOutput.value)) {
                exceedMax = valueDate > new Date(maxOutput.value);
            }
            if (isString(minOutput.value)) {
                exceedMin = valueDate < new Date(minOutput.value);
            }
        }
        if (exceedMax || exceedMin) {
            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
            if (!validateAllFieldCriteria) {
                setCustomValidity(error[name].message);
                return error;
            }
        }
    }
    if ((maxLength || minLength) &&
        !isEmpty &&
        (isString(inputValue) || (isFieldArray && Array.isArray(inputValue)))) {
        const maxLengthOutput = getValueAndMessage(maxLength);
        const minLengthOutput = getValueAndMessage(minLength);
        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&
            inputValue.length > maxLengthOutput.value;
        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&
            inputValue.length < minLengthOutput.value;
        if (exceedMax || exceedMin) {
            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
            if (!validateAllFieldCriteria) {
                setCustomValidity(error[name].message);
                return error;
            }
        }
    }
    if (pattern && !isEmpty && isString(inputValue)) {
        const { value: patternValue, message } = getValueAndMessage(pattern);
        if (isRegex(patternValue) && !inputValue.match(patternValue)) {
            error[name] = {
                type: INPUT_VALIDATION_RULES.pattern,
                message,
                ref,
                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),
            };
            if (!validateAllFieldCriteria) {
                setCustomValidity(message);
                return error;
            }
        }
    }
    if (validate) {
        if (isFunction(validate)) {
            const result = await validate(inputValue);
            const validateError = getValidateError(result, inputRef);
            if (validateError) {
                error[name] = {
                    ...validateError,
                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message),
                };
                if (!validateAllFieldCriteria) {
                    setCustomValidity(validateError.message);
                    return error;
                }
            }
        }
        else if (isObject(validate)) {
            let validationResult = {};
            for (const key in validate) {
                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
                    break;
                }
                const validateError = getValidateError(await validate[key](inputValue), inputRef, key);
                if (validateError) {
                    validationResult = {
                        ...validateError,
                        ...appendErrorsCurry(key, validateError.message),
                    };
                    setCustomValidity(validateError.message);
                    if (validateAllFieldCriteria) {
                        error[name] = validationResult;
                    }
                }
            }
            if (!isEmptyObject(validationResult)) {
                error[name] = {
                    ref: inputRef,
                    ...validationResult,
                };
                if (!validateAllFieldCriteria) {
                    return error;
                }
            }
        }
    }
    setCustomValidity(true);
    return error;
};

var isPlainObject = (tempObject) => {
    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
    return (isObject(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf'));
};

var isWeb = typeof window !== 'undefined' &&
    typeof window.HTMLElement !== 'undefined' &&
    typeof document !== 'undefined';

function cloneObject(data) {
    let copy;
    const isArray = Array.isArray(data);
    if (data instanceof Date) {
        copy = new Date(data);
    }
    else if (data instanceof Set) {
        copy = new Set(data);
    }
    else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) &&
        (isArray || isObject(data))) {
        copy = isArray ? [] : {};
        if (!Array.isArray(data) && !isPlainObject(data)) {
            copy = data;
        }
        else {
            for (const key in data) {
                copy[key] = cloneObject(data[key]);
            }
        }
    }
    else {
        return data;
    }
    return copy;
}

var getValidationModes = (mode) => ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
    isOnAll: mode === VALIDATION_MODE.all,
    isOnTouch: mode === VALIDATION_MODE.onTouched,
});

function baseGet(object, updatePath) {
    const length = updatePath.slice(0, -1).length;
    let index = 0;
    while (index < length) {
        object = isUndefined(object) ? index++ : object[updatePath[index++]];
    }
    return object;
}
function isEmptyArray(obj) {
    for (const key in obj) {
        if (!isUndefined(obj[key])) {
            return false;
        }
    }
    return true;
}
function unset(object, path) {
    const updatePath = isKey(path) ? [path] : stringToPath(path);
    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);
    const key = updatePath[updatePath.length - 1];
    let previousObjRef;
    if (childObject) {
        delete childObject[key];
    }
    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {
        let index = -1;
        let objectRef;
        const currentPaths = updatePath.slice(0, -(k + 1));
        const currentPathsLength = currentPaths.length - 1;
        if (k > 0) {
            previousObjRef = object;
        }
        while (++index < currentPaths.length) {
            const item = currentPaths[index];
            objectRef = objectRef ? objectRef[item] : object[item];
            if (currentPathsLength === index &&
                ((isObject(objectRef) && isEmptyObject(objectRef)) ||
                    (Array.isArray(objectRef) && isEmptyArray(objectRef)))) {
                previousObjRef ? delete previousObjRef[item] : delete object[item];
            }
            previousObjRef = objectRef;
        }
    }
    return object;
}

function createSubject() {
    let _observers = [];
    const next = (value) => {
        for (const observer of _observers) {
            observer.next(value);
        }
    };
    const subscribe = (observer) => {
        _observers.push(observer);
        return {
            unsubscribe: () => {
                _observers = _observers.filter((o) => o !== observer);
            },
        };
    };
    const unsubscribe = () => {
        _observers = [];
    };
    return {
        get observers() {
            return _observers;
        },
        next,
        subscribe,
        unsubscribe,
    };
}

var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);

function deepEqual(object1, object2) {
    if (isPrimitive(object1) || isPrimitive(object2)) {
        return object1 === object2;
    }
    if (isDateObject(object1) && isDateObject(object2)) {
        return object1.getTime() === object2.getTime();
    }
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (const key of keys1) {
        const val1 = object1[key];
        if (!keys2.includes(key)) {
            return false;
        }
        if (key !== 'ref') {
            const val2 = object2[key];
            if ((isDateObject(val1) && isDateObject(val2)) ||
                (isObject(val1) && isObject(val2)) ||
                (Array.isArray(val1) && Array.isArray(val2))
                ? !deepEqual(val1, val2)
                : val1 !== val2) {
                return false;
            }
        }
    }
    return true;
}

var isHTMLElement = (value) => {
    const owner = value ? value.ownerDocument : 0;
    const ElementClass = owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement;
    return value instanceof ElementClass;
};

var isMultipleSelect = (element) => element.type === `select-multiple`;

var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);

var live = (ref) => isHTMLElement(ref) && ref.isConnected;

function markFieldsDirty(data, fields = {}) {
    const isParentNodeArray = Array.isArray(data);
    if (isObject(data) || isParentNodeArray) {
        for (const key in data) {
            if (Array.isArray(data[key]) ||
                (isObject(data[key]) && !objectHasFunction(data[key]))) {
                fields[key] = Array.isArray(data[key]) ? [] : {};
                markFieldsDirty(data[key], fields[key]);
            }
            else if (!isNullOrUndefined(data[key])) {
                fields[key] = true;
            }
        }
    }
    return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
    const isParentNodeArray = Array.isArray(data);
    if (isObject(data) || isParentNodeArray) {
        for (const key in data) {
            if (Array.isArray(data[key]) ||
                (isObject(data[key]) && !objectHasFunction(data[key]))) {
                if (isUndefined(formValues) ||
                    isPrimitive(dirtyFieldsFromValues[key])) {
                    dirtyFieldsFromValues[key] = Array.isArray(data[key])
                        ? markFieldsDirty(data[key], [])
                        : { ...markFieldsDirty(data[key]) };
                }
                else {
                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
                }
            }
            else {
                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
            }
        }
    }
    return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));

var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)
    ? value
    : valueAsNumber
        ? value === ''
            ? NaN
            : value
                ? +value
                : value
        : valueAsDate && isString(value)
            ? new Date(value)
            : setValueAs
                ? setValueAs(value)
                : value;

function getFieldValue(_f) {
    const ref = _f.ref;
    if (_f.refs ? _f.refs.every((ref) => ref.disabled) : ref.disabled) {
        return;
    }
    if (isFileInput(ref)) {
        return ref.files;
    }
    if (isRadioInput(ref)) {
        return getRadioValue(_f.refs).value;
    }
    if (isMultipleSelect(ref)) {
        return [...ref.selectedOptions].map(({ value }) => value);
    }
    if (isCheckBoxInput(ref)) {
        return getCheckboxValue(_f.refs).value;
    }
    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}

var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
    const fields = {};
    for (const name of fieldsNames) {
        const field = get(_fields, name);
        field && set(fields, name, field._f);
    }
    return {
        criteriaMode,
        names: [...fieldsNames],
        fields,
        shouldUseNativeValidation,
    };
};

var getRuleValue = (rule) => isUndefined(rule)
    ? undefined
    : isRegex(rule)
        ? rule.source
        : isObject(rule)
            ? isRegex(rule.value)
                ? rule.value.source
                : rule.value
            : rule;

var hasValidation = (options) => options.mount &&
    (options.required ||
        options.min ||
        options.max ||
        options.maxLength ||
        options.minLength ||
        options.pattern ||
        options.validate);

function schemaErrorLookup(errors, _fields, name) {
    const error = get(errors, name);
    if (error || isKey(name)) {
        return {
            error,
            name,
        };
    }
    const names = name.split('.');
    while (names.length) {
        const fieldName = names.join('.');
        const field = get(_fields, fieldName);
        const foundError = get(errors, fieldName);
        if (field && !Array.isArray(field) && name !== fieldName) {
            return { name };
        }
        if (foundError && foundError.type) {
            return {
                name: fieldName,
                error: foundError,
            };
        }
        names.pop();
    }
    return {
        name,
    };
}

var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
    if (mode.isOnAll) {
        return false;
    }
    else if (!isSubmitted && mode.isOnTouch) {
        return !(isTouched || isBlurEvent);
    }
    else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
        return !isBlurEvent;
    }
    else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
        return isBlurEvent;
    }
    return true;
};

var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);

const defaultOptions$1 = {
    mode: VALIDATION_MODE.onSubmit,
    reValidateMode: VALIDATION_MODE.onChange,
    shouldFocusError: true,
};
function createFormControl(props = {}) {
    let _options = {
        ...defaultOptions$1,
        ...props,
    };
    let _formState = {
        submitCount: 0,
        isDirty: false,
        isValidating: false,
        isSubmitted: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
        touchedFields: {},
        dirtyFields: {},
        errors: {},
    };
    let _fields = {};
    let _defaultValues = cloneObject(_options.defaultValues) || {};
    let _formValues = _options.shouldUnregister
        ? {}
        : cloneObject(_defaultValues);
    let _stateFlags = {
        action: false,
        mount: false,
        watch: false,
    };
    let _names = {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(),
    };
    let delayErrorCallback;
    let timer = 0;
    let validateFields = {};
    const _proxyFormState = {
        isDirty: false,
        dirtyFields: false,
        touchedFields: false,
        isValidating: false,
        isValid: false,
        errors: false,
    };
    const _subjects = {
        watch: createSubject(),
        array: createSubject(),
        state: createSubject(),
    };
    const validationModeBeforeSubmit = getValidationModes(_options.mode);
    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
    const debounce = (callback) => (wait) => {
        clearTimeout(timer);
        timer = window.setTimeout(callback, wait);
    };
    const _updateValid = async (shouldSkipRender) => {
        let isValid = false;
        if (_proxyFormState.isValid) {
            isValid = _options.resolver
                ? isEmptyObject((await _executeSchema()).errors)
                : await executeBuiltInValidation(_fields, true);
            if (!shouldSkipRender && isValid !== _formState.isValid) {
                _formState.isValid = isValid;
                _subjects.state.next({
                    isValid,
                });
            }
        }
        return isValid;
    };
    const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
        if (args && method) {
            _stateFlags.action = true;
            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
                const fieldValues = method(get(_fields, name), args.argA, args.argB);
                shouldSetValues && set(_fields, name, fieldValues);
            }
            if (_proxyFormState.errors &&
                shouldUpdateFieldsAndState &&
                Array.isArray(get(_formState.errors, name))) {
                const errors = method(get(_formState.errors, name), args.argA, args.argB);
                shouldSetValues && set(_formState.errors, name, errors);
                unsetEmptyArray(_formState.errors, name);
            }
            if (_proxyFormState.touchedFields &&
                shouldUpdateFieldsAndState &&
                Array.isArray(get(_formState.touchedFields, name))) {
                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
                shouldSetValues && set(_formState.touchedFields, name, touchedFields);
            }
            if (_proxyFormState.dirtyFields) {
                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
            }
            _subjects.state.next({
                isDirty: _getDirty(name, values),
                dirtyFields: _formState.dirtyFields,
                errors: _formState.errors,
                isValid: _formState.isValid,
            });
        }
        else {
            set(_formValues, name, values);
        }
    };
    const updateErrors = (name, error) => {
        set(_formState.errors, name, error);
        _subjects.state.next({
            errors: _formState.errors,
        });
    };
    const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
        const field = get(_fields, name);
        if (field) {
            const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
            isUndefined(defaultValue) ||
                (ref && ref.defaultChecked) ||
                shouldSkipSetValueAs
                ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f))
                : setFieldValue(name, defaultValue);
            _stateFlags.mount && _updateValid();
        }
    };
    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
        let isFieldDirty = false;
        const output = {
            name,
        };
        const isPreviousFieldTouched = get(_formState.touchedFields, name);
        if (_proxyFormState.isDirty) {
            const isPreviousFormDirty = _formState.isDirty;
            _formState.isDirty = output.isDirty = _getDirty();
            isFieldDirty = isPreviousFormDirty !== output.isDirty;
        }
        if (_proxyFormState.dirtyFields && (!isBlurEvent || shouldDirty)) {
            const isPreviousFieldDirty = get(_formState.dirtyFields, name);
            const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
            isCurrentFieldPristine
                ? unset(_formState.dirtyFields, name)
                : set(_formState.dirtyFields, name, true);
            output.dirtyFields = _formState.dirtyFields;
            isFieldDirty =
                isFieldDirty ||
                    isPreviousFieldDirty !== get(_formState.dirtyFields, name);
        }
        if (isBlurEvent && !isPreviousFieldTouched) {
            set(_formState.touchedFields, name, isBlurEvent);
            output.touchedFields = _formState.touchedFields;
            isFieldDirty =
                isFieldDirty ||
                    (_proxyFormState.touchedFields &&
                        isPreviousFieldTouched !== isBlurEvent);
        }
        isFieldDirty && shouldRender && _subjects.state.next(output);
        return isFieldDirty ? output : {};
    };
    const shouldRenderByError = async (name, isValid, error, fieldState) => {
        const previousFieldError = get(_formState.errors, name);
        const shouldUpdateValid = _proxyFormState.isValid && _formState.isValid !== isValid;
        if (props.delayError && error) {
            delayErrorCallback = debounce(() => updateErrors(name, error));
            delayErrorCallback(props.delayError);
        }
        else {
            clearTimeout(timer);
            delayErrorCallback = null;
            error
                ? set(_formState.errors, name, error)
                : unset(_formState.errors, name);
        }
        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) ||
            !isEmptyObject(fieldState) ||
            shouldUpdateValid) {
            const updatedFormState = {
                ...fieldState,
                ...(shouldUpdateValid ? { isValid } : {}),
                errors: _formState.errors,
                name,
            };
            _formState = {
                ..._formState,
                ...updatedFormState,
            };
            _subjects.state.next(updatedFormState);
        }
        validateFields[name]--;
        if (_proxyFormState.isValidating &&
            !Object.values(validateFields).some((v) => v)) {
            _subjects.state.next({
                isValidating: false,
            });
            validateFields = {};
        }
    };
    const _executeSchema = async (name) => _options.resolver
        ? await _options.resolver({ ..._formValues }, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation))
        : {};
    const executeSchemaAndUpdateState = async (names) => {
        const { errors } = await _executeSchema();
        if (names) {
            for (const name of names) {
                const error = get(errors, name);
                error
                    ? set(_formState.errors, name, error)
                    : unset(_formState.errors, name);
            }
        }
        else {
            _formState.errors = errors;
        }
        return errors;
    };
    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
        valid: true,
    }) => {
        for (const name in fields) {
            const field = fields[name];
            if (field) {
                const { _f, ...fieldValue } = field;
                if (_f) {
                    const isFieldArrayRoot = _names.array.has(_f.name);
                    const fieldError = await validateField(field, get(_formValues, _f.name), shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation, isFieldArrayRoot);
                    if (fieldError[_f.name]) {
                        context.valid = false;
                        if (shouldOnlyCheckValid) {
                            break;
                        }
                    }
                    !shouldOnlyCheckValid &&
                        (get(fieldError, _f.name)
                            ? isFieldArrayRoot
                                ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name)
                                : set(_formState.errors, _f.name, fieldError[_f.name])
                            : unset(_formState.errors, _f.name));
                }
                fieldValue &&
                    (await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));
            }
        }
        return context.valid;
    };
    const _removeUnmounted = () => {
        for (const name of _names.unMount) {
            const field = get(_fields, name);
            field &&
                (field._f.refs
                    ? field._f.refs.every((ref) => !live(ref))
                    : !live(field._f.ref)) &&
                unregister(name);
        }
        _names.unMount = new Set();
    };
    const _getDirty = (name, data) => (name && data && set(_formValues, name, data),
        !deepEqual(getValues(), _defaultValues));
    const _getWatch = (names, defaultValue, isGlobal) => {
        const fieldValues = {
            ...(_stateFlags.mount
                ? _formValues
                : isUndefined(defaultValue)
                    ? _defaultValues
                    : isString(names)
                        ? { [names]: defaultValue }
                        : defaultValue),
        };
        return generateWatchOutput(names, _names, fieldValues, isGlobal);
    };
    const _getFieldArray = (name) => compact(get(_stateFlags.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));
    const setFieldValue = (name, value, options = {}) => {
        const field = get(_fields, name);
        let fieldValue = value;
        if (field) {
            const fieldReference = field._f;
            if (fieldReference) {
                !fieldReference.disabled &&
                    set(_formValues, name, getFieldValueAs(value, fieldReference));
                fieldValue =
                    isWeb && isHTMLElement(fieldReference.ref) && isNullOrUndefined(value)
                        ? ''
                        : value;
                if (isMultipleSelect(fieldReference.ref)) {
                    [...fieldReference.ref.options].forEach((optionRef) => (optionRef.selected = fieldValue.includes(optionRef.value)));
                }
                else if (fieldReference.refs) {
                    if (isCheckBoxInput(fieldReference.ref)) {
                        fieldReference.refs.length > 1
                            ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) &&
                                (checkboxRef.checked = Array.isArray(fieldValue)
                                    ? !!fieldValue.find((data) => data === checkboxRef.value)
                                    : fieldValue === checkboxRef.value))
                            : fieldReference.refs[0] &&
                                (fieldReference.refs[0].checked = !!fieldValue);
                    }
                    else {
                        fieldReference.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));
                    }
                }
                else if (isFileInput(fieldReference.ref)) {
                    fieldReference.ref.value = '';
                }
                else {
                    fieldReference.ref.value = fieldValue;
                    if (!fieldReference.ref.type) {
                        _subjects.watch.next({
                            name,
                        });
                    }
                }
            }
        }
        (options.shouldDirty || options.shouldTouch) &&
            updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
        options.shouldValidate && trigger(name);
    };
    const setValues = (name, value, options) => {
        for (const fieldKey in value) {
            const fieldValue = value[fieldKey];
            const fieldName = `${name}.${fieldKey}`;
            const field = get(_fields, fieldName);
            (_names.array.has(name) ||
                !isPrimitive(fieldValue) ||
                (field && !field._f)) &&
                !isDateObject(fieldValue)
                ? setValues(fieldName, fieldValue, options)
                : setFieldValue(fieldName, fieldValue, options);
        }
    };
    const setValue = (name, value, options = {}) => {
        const field = get(_fields, name);
        const isFieldArray = _names.array.has(name);
        const cloneValue = cloneObject(value);
        set(_formValues, name, cloneValue);
        if (isFieldArray) {
            _subjects.array.next({
                name,
                values: _formValues,
            });
            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&
                options.shouldDirty) {
                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
                _subjects.state.next({
                    name,
                    dirtyFields: _formState.dirtyFields,
                    isDirty: _getDirty(name, cloneValue),
                });
            }
        }
        else {
            field && !field._f && !isNullOrUndefined(cloneValue)
                ? setValues(name, cloneValue, options)
                : setFieldValue(name, cloneValue, options);
        }
        isWatched(name, _names) && _subjects.state.next({});
        _subjects.watch.next({
            name,
        });
    };
    const onChange = async (event) => {
        const target = event.target;
        let name = target.name;
        const field = get(_fields, name);
        if (field) {
            let error;
            let isValid;
            const fieldValue = target.type
                ? getFieldValue(field._f)
                : getEventValue(event);
            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
            const shouldSkipValidation = (!hasValidation(field._f) &&
                !_options.resolver &&
                !get(_formState.errors, name) &&
                !field._f.deps) ||
                skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
            const watched = isWatched(name, _names, isBlurEvent);
            set(_formValues, name, fieldValue);
            if (isBlurEvent) {
                field._f.onBlur && field._f.onBlur(event);
                delayErrorCallback && delayErrorCallback(0);
            }
            else if (field._f.onChange) {
                field._f.onChange(event);
            }
            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
            const shouldRender = !isEmptyObject(fieldState) || watched;
            !isBlurEvent &&
                _subjects.watch.next({
                    name,
                    type: event.type,
                });
            if (shouldSkipValidation) {
                return (shouldRender &&
                    _subjects.state.next({ name, ...(watched ? {} : fieldState) }));
            }
            !isBlurEvent && watched && _subjects.state.next({});
            validateFields[name] = validateFields[name] ? +1 : 1;
            _subjects.state.next({
                isValidating: true,
            });
            if (_options.resolver) {
                const { errors } = await _executeSchema([name]);
                const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
                const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
                error = errorLookupResult.error;
                name = errorLookupResult.name;
                isValid = isEmptyObject(errors);
            }
            else {
                error = (await validateField(field, get(_formValues, name), shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
                isValid = await _updateValid(true);
            }
            field._f.deps &&
                trigger(field._f.deps);
            shouldRenderByError(name, isValid, error, fieldState);
        }
    };
    const trigger = async (name, options = {}) => {
        let isValid;
        let validationResult;
        const fieldNames = convertToArrayPayload(name);
        _subjects.state.next({
            isValidating: true,
        });
        if (_options.resolver) {
            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
            isValid = isEmptyObject(errors);
            validationResult = name
                ? !fieldNames.some((name) => get(errors, name))
                : isValid;
        }
        else if (name) {
            validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
                const field = get(_fields, fieldName);
                return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
            }))).every(Boolean);
            !(!validationResult && !_formState.isValid) && _updateValid();
        }
        else {
            validationResult = isValid = await executeBuiltInValidation(_fields);
        }
        _subjects.state.next({
            ...(!isString(name) ||
                (_proxyFormState.isValid && isValid !== _formState.isValid)
                ? {}
                : { name }),
            ...(_options.resolver ? { isValid } : {}),
            errors: _formState.errors,
            isValidating: false,
        });
        options.shouldFocus &&
            !validationResult &&
            focusFieldBy(_fields, (key) => get(_formState.errors, key), name ? fieldNames : _names.mount);
        return validationResult;
    };
    const getValues = (fieldNames) => {
        const values = {
            ..._defaultValues,
            ...(_stateFlags.mount ? _formValues : {}),
        };
        return isUndefined(fieldNames)
            ? values
            : isString(fieldNames)
                ? get(values, fieldNames)
                : fieldNames.map((name) => get(values, name));
    };
    const getFieldState = (name, formState) => ({
        invalid: !!get((formState || _formState).errors, name),
        isDirty: !!get((formState || _formState).dirtyFields, name),
        isTouched: !!get((formState || _formState).touchedFields, name),
        error: get((formState || _formState).errors, name),
    });
    const clearErrors = (name) => {
        name
            ? convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName))
            : (_formState.errors = {});
        _subjects.state.next({
            errors: _formState.errors,
        });
    };
    const setError = (name, error, options) => {
        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
        set(_formState.errors, name, {
            ...error,
            ref,
        });
        _subjects.state.next({
            name,
            errors: _formState.errors,
            isValid: false,
        });
        options && options.shouldFocus && ref && ref.focus && ref.focus();
    };
    const watch = (name, defaultValue) => isFunction(name)
        ? _subjects.watch.subscribe({
            next: (info) => name(_getWatch(undefined, defaultValue), info),
        })
        : _getWatch(name, defaultValue, true);
    const unregister = (name, options = {}) => {
        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
            _names.mount.delete(fieldName);
            _names.array.delete(fieldName);
            if (get(_fields, fieldName)) {
                if (!options.keepValue) {
                    unset(_fields, fieldName);
                    unset(_formValues, fieldName);
                }
                !options.keepError && unset(_formState.errors, fieldName);
                !options.keepDirty && unset(_formState.dirtyFields, fieldName);
                !options.keepTouched && unset(_formState.touchedFields, fieldName);
                !_options.shouldUnregister &&
                    !options.keepDefaultValue &&
                    unset(_defaultValues, fieldName);
            }
        }
        _subjects.watch.next({});
        _subjects.state.next({
            ..._formState,
            ...(!options.keepDirty ? {} : { isDirty: _getDirty() }),
        });
        !options.keepIsValid && _updateValid();
    };
    const register = (name, options = {}) => {
        let field = get(_fields, name);
        const disabledIsDefined = isBoolean(options.disabled);
        set(_fields, name, {
            ...(field || {}),
            _f: {
                ...(field && field._f ? field._f : { ref: { name } }),
                name,
                mount: true,
                ...options,
            },
        });
        _names.mount.add(name);
        field
            ? disabledIsDefined &&
                set(_formValues, name, options.disabled
                    ? undefined
                    : get(_formValues, name, getFieldValue(field._f)))
            : updateValidAndValue(name, true, options.value);
        return {
            ...(disabledIsDefined ? { disabled: options.disabled } : {}),
            ...(_options.shouldUseNativeValidation
                ? {
                    required: !!options.required,
                    min: getRuleValue(options.min),
                    max: getRuleValue(options.max),
                    minLength: getRuleValue(options.minLength),
                    maxLength: getRuleValue(options.maxLength),
                    pattern: getRuleValue(options.pattern),
                }
                : {}),
            name,
            onChange,
            onBlur: onChange,
            ref: (ref) => {
                if (ref) {
                    register(name, options);
                    field = get(_fields, name);
                    const fieldRef = isUndefined(ref.value)
                        ? ref.querySelectorAll
                            ? ref.querySelectorAll('input,select,textarea')[0] || ref
                            : ref
                        : ref;
                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
                    const refs = field._f.refs || [];
                    if (radioOrCheckbox
                        ? refs.find((option) => option === fieldRef)
                        : fieldRef === field._f.ref) {
                        return;
                    }
                    set(_fields, name, {
                        _f: {
                            ...field._f,
                            ...(radioOrCheckbox
                                ? {
                                    refs: [
                                        ...refs.filter(live),
                                        fieldRef,
                                        ...(!!Array.isArray(get(_defaultValues, name))
                                            ? [{}]
                                            : []),
                                    ],
                                    ref: { type: fieldRef.type, name },
                                }
                                : { ref: fieldRef }),
                        },
                    });
                    updateValidAndValue(name, false, undefined, fieldRef);
                }
                else {
                    field = get(_fields, name, {});
                    if (field._f) {
                        field._f.mount = false;
                    }
                    (_options.shouldUnregister || options.shouldUnregister) &&
                        !(isNameInFieldArray(_names.array, name) && _stateFlags.action) &&
                        _names.unMount.add(name);
                }
            },
        };
    };
    const handleSubmit = (onValid, onInvalid) => async (e) => {
        if (e) {
            e.preventDefault && e.preventDefault();
            e.persist && e.persist();
        }
        let hasNoPromiseError = true;
        let fieldValues = cloneObject(_formValues);
        _subjects.state.next({
            isSubmitting: true,
        });
        try {
            if (_options.resolver) {
                const { errors, values } = await _executeSchema();
                _formState.errors = errors;
                fieldValues = values;
            }
            else {
                await executeBuiltInValidation(_fields);
            }
            if (isEmptyObject(_formState.errors)) {
                _subjects.state.next({
                    errors: {},
                    isSubmitting: true,
                });
                await onValid(fieldValues, e);
            }
            else {
                if (onInvalid) {
                    await onInvalid({ ..._formState.errors }, e);
                }
                _options.shouldFocusError &&
                    focusFieldBy(_fields, (key) => get(_formState.errors, key), _names.mount);
            }
        }
        catch (err) {
            hasNoPromiseError = false;
            throw err;
        }
        finally {
            _formState.isSubmitted = true;
            _subjects.state.next({
                isSubmitted: true,
                isSubmitting: false,
                isSubmitSuccessful: isEmptyObject(_formState.errors) && hasNoPromiseError,
                submitCount: _formState.submitCount + 1,
                errors: _formState.errors,
            });
        }
    };
    const resetField = (name, options = {}) => {
        if (get(_fields, name)) {
            if (isUndefined(options.defaultValue)) {
                setValue(name, get(_defaultValues, name));
            }
            else {
                setValue(name, options.defaultValue);
                set(_defaultValues, name, options.defaultValue);
            }
            if (!options.keepTouched) {
                unset(_formState.touchedFields, name);
            }
            if (!options.keepDirty) {
                unset(_formState.dirtyFields, name);
                _formState.isDirty = options.defaultValue
                    ? _getDirty(name, get(_defaultValues, name))
                    : _getDirty();
            }
            if (!options.keepError) {
                unset(_formState.errors, name);
                _proxyFormState.isValid && _updateValid();
            }
            _subjects.state.next({ ..._formState });
        }
    };
    const _reset = (formValues, keepStateOptions = {}) => {
        const updatedValues = formValues || _defaultValues;
        const cloneUpdatedValues = cloneObject(updatedValues);
        const values = formValues && !isEmptyObject(formValues)
            ? cloneUpdatedValues
            : _defaultValues;
        if (!keepStateOptions.keepDefaultValues) {
            _defaultValues = updatedValues;
        }
        if (!keepStateOptions.keepValues) {
            if (keepStateOptions.keepDirtyValues) {
                for (const fieldName of _names.mount) {
                    get(_formState.dirtyFields, fieldName)
                        ? set(values, fieldName, get(_formValues, fieldName))
                        : setValue(fieldName, get(values, fieldName));
                }
            }
            else {
                if (isWeb && isUndefined(formValues)) {
                    for (const name of _names.mount) {
                        const field = get(_fields, name);
                        if (field && field._f) {
                            const fieldReference = Array.isArray(field._f.refs)
                                ? field._f.refs[0]
                                : field._f.ref;
                            try {
                                if (isHTMLElement(fieldReference)) {
                                    fieldReference.closest('form').reset();
                                    break;
                                }
                            }
                            catch (_a) { }
                        }
                    }
                }
                _fields = {};
            }
            _formValues = props.shouldUnregister
                ? keepStateOptions.keepDefaultValues
                    ? cloneObject(_defaultValues)
                    : {}
                : cloneUpdatedValues;
            _subjects.array.next({
                values,
            });
            _subjects.watch.next({
                values,
            });
        }
        _names = {
            mount: new Set(),
            unMount: new Set(),
            array: new Set(),
            watch: new Set(),
            watchAll: false,
            focus: '',
        };
        _stateFlags.mount =
            !_proxyFormState.isValid || !!keepStateOptions.keepIsValid;
        _stateFlags.watch = !!props.shouldUnregister;
        _subjects.state.next({
            submitCount: keepStateOptions.keepSubmitCount
                ? _formState.submitCount
                : 0,
            isDirty: keepStateOptions.keepDirty || keepStateOptions.keepDirtyValues
                ? _formState.isDirty
                : !!(keepStateOptions.keepDefaultValues &&
                    !deepEqual(formValues, _defaultValues)),
            isSubmitted: keepStateOptions.keepIsSubmitted
                ? _formState.isSubmitted
                : false,
            dirtyFields: keepStateOptions.keepDirty || keepStateOptions.keepDirtyValues
                ? _formState.dirtyFields
                : keepStateOptions.keepDefaultValues && formValues
                    ? getDirtyFields(_defaultValues, formValues)
                    : {},
            touchedFields: keepStateOptions.keepTouched
                ? _formState.touchedFields
                : {},
            errors: keepStateOptions.keepErrors ? _formState.errors : {},
            isSubmitting: false,
            isSubmitSuccessful: false,
        });
    };
    const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues)
        ? formValues(_formValues)
        : formValues, keepStateOptions);
    const setFocus = (name, options = {}) => {
        const field = get(_fields, name);
        const fieldReference = field && field._f;
        if (fieldReference) {
            const fieldRef = fieldReference.refs
                ? fieldReference.refs[0]
                : fieldReference.ref;
            if (fieldRef.focus) {
                fieldRef.focus();
                options.shouldSelect && fieldRef.select();
            }
        }
    };
    return {
        control: {
            register,
            unregister,
            getFieldState,
            _executeSchema,
            _getWatch,
            _getDirty,
            _updateValid,
            _removeUnmounted,
            _updateFieldArray,
            _getFieldArray,
            _subjects,
            _proxyFormState,
            get _fields() {
                return _fields;
            },
            get _formValues() {
                return _formValues;
            },
            get _stateFlags() {
                return _stateFlags;
            },
            set _stateFlags(value) {
                _stateFlags = value;
            },
            get _defaultValues() {
                return _defaultValues;
            },
            get _names() {
                return _names;
            },
            set _names(value) {
                _names = value;
            },
            get _formState() {
                return _formState;
            },
            set _formState(value) {
                _formState = value;
            },
            get _options() {
                return _options;
            },
            set _options(value) {
                _options = {
                    ..._options,
                    ...value,
                };
            },
        },
        trigger,
        register,
        handleSubmit,
        watch,
        setValue,
        getValues,
        reset,
        resetField,
        clearErrors,
        unregister,
        setError,
        setFocus,
        getFieldState,
    };
}

/**
 * Custom hook to manage the entire form.
 *
 * @remarks
 * [API](https://react-hook-form.com/api/useform) â€¢ [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) â€¢ [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)
 *
 * @param props - form configuration and validation parameters.
 *
 * @returns methods - individual functions to manage the form state. {@link UseFormReturn}
 *
 * @example
 * ```tsx
 * function App() {
 *   const { register, handleSubmit, watch, formState: { errors } } = useForm();
 *   const onSubmit = data => console.log(data);
 *
 *   console.log(watch("example"));
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <input defaultValue="test" {...register("example")} />
 *       <input {...register("exampleRequired", { required: true })} />
 *       {errors.exampleRequired && <span>This field is required</span>}
 *       <input type="submit" />
 *     </form>
 *   );
 * }
 * ```
 */
function useForm(props = {}) {
    const _formControl = React__default.useRef();
    const [formState, updateFormState] = React__default.useState({
        isDirty: false,
        isValidating: false,
        isSubmitted: false,
        isSubmitting: false,
        isSubmitSuccessful: false,
        isValid: false,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        errors: {},
        defaultValues: props.defaultValues,
    });
    if (!_formControl.current) {
        _formControl.current = {
            ...createFormControl(props),
            formState,
        };
    }
    const control = _formControl.current.control;
    control._options = props;
    useSubscribe({
        subject: control._subjects.state,
        callback: React__default.useCallback((value) => {
            if (shouldRenderFormState(value, control._proxyFormState, true)) {
                control._formState = {
                    ...control._formState,
                    ...value,
                };
                updateFormState({ ...control._formState });
            }
        }, [control]),
    });
    React__default.useEffect(() => {
        if (!control._stateFlags.mount) {
            control._proxyFormState.isValid && control._updateValid();
            control._stateFlags.mount = true;
        }
        if (control._stateFlags.watch) {
            control._stateFlags.watch = false;
            control._subjects.state.next({});
        }
        control._removeUnmounted();
    });
    _formControl.current.formState = getProxyFormState(formState, control);
    return _formControl.current;
}

const FieldWrapperBase = styled.div`
  width: 100%;
  max-width: ${field.size.lg};
  .field-slot {
    margin-bottom: 1.2rem;
  }
  &.long {
    max-width: ${field.size.lg};
  }
  &.full {
    max-width: ${field.size.full};
  }
  &.hidden {
    display: none;
  }
`;
const LabelContainer$1 = styled.label`
  display: flex;
  align-items: center;
  margin-bottom: 12px;
  label {
    margin-right: 10px;
  }
  svg {
    transform: translateY(0.1rem);
  }
`;
const BottomContainer = styled.div`
  display: flex;
  margin-bottom: 12px;
  width: 100%;
  max-width: ${field.size.md};
  &.long {
    max-width: ${field.size.lg};
  }
  &.full {
    max-width: ${field.size.full};
  }
`;
const LeftAddonContainer = styled.div`
  display: flex;
  align-items: end;
  min-width: 70%;
`;
const RightAddonContainer = styled.div`
  display: flex;
  justify-content: flex-end;
  min-width: 30%;
`;
const RequiredAsterisk = styled.span`
  margin-right: 8px;
  font-weight: ${font.weight.bold};
  color: ${({ theme }) => theme.warning};
  transform: translateY(-0.25rem);
`;

const FieldWrapper = ({
  children,
  label,
  loading,
  info,
  error,
  success,
  warning,
  helperText,
  hidden,
  long,
  full,
  address,
  id,
  rules,
  rightAddon
}) => {
  const classes = classNames({
    long: long || address,
    full,
    hidden
  });
  const {
    getFieldState
  } = useFormContext();
  const fieldError = getFieldState(id).error;
  return /* @__PURE__ */ jsxs(FieldWrapperBase, {
    className: classes,
    children: [/* @__PURE__ */ jsxs(LabelContainer$1, {
      children: [rules?.required && /* @__PURE__ */ jsx(RequiredAsterisk, {
        children: /* @__PURE__ */ jsx(Icon, {
          label: "Required",
          children: /* @__PURE__ */ jsx(RiAsterisk, {})
        })
      }), label && /* @__PURE__ */ jsx(Label$1, {
        id,
        children: label
      }), info && /* @__PURE__ */ jsx(Tooltip, {
        content: info
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "field-slot",
      children
    }), /* @__PURE__ */ jsxs(BottomContainer, {
      className: classes,
      children: [/* @__PURE__ */ jsxs(LeftAddonContainer, {
        children: [loading && /* @__PURE__ */ jsx(Spinner, {
          size: "2rem"
        }), /* @__PURE__ */ jsx(HelperTextFactory, {
          error: error || fieldError,
          success,
          warning,
          helperText
        })]
      }), rightAddon && /* @__PURE__ */ jsx(RightAddonContainer, {
        children: rightAddon
      })]
    })]
  });
};
const HelperTextFactory = ({
  error,
  success,
  warning,
  helperText
}) => {
  if (!error && !success && !warning && !helperText)
    return null;
  if (error)
    return /* @__PURE__ */ jsx(ErrorText, {
      children: error.message
    });
  if (warning)
    return /* @__PURE__ */ jsx(WarningText, {
      children: warning.message
    });
  if (success)
    return /* @__PURE__ */ jsx(SuccessText, {
      children: success.message
    });
  return /* @__PURE__ */ jsx(HelperText, {
    children: helperText
  });
};

const WrappedInput = ({
  id,
  rules,
  ...props
}) => {
  const {
    register
  } = useFormContext();
  return /* @__PURE__ */ jsx(FieldWrapper, {
    ...props,
    id,
    rules,
    children: /* @__PURE__ */ jsx(Input, {
      ...props,
      ...register(id, rules),
      id
    })
  });
};

const CSInput = (props) => {
  const {
    rules,
    id,
    itemNoun = {
      singular: "item",
      plural: "items"
    }
  } = props;
  const {
    watch
  } = useFormContext();
  const value = watch(id);
  const amtItems = Array.isArray(value) ? value.length : 0;
  const helperText = `${amtItems} ${handlePluralNoun(itemNoun, amtItems)} typed`;
  const newRules = {
    ...rules,
    setValueAs: (value2) => value2.trim().split(",").filter(Boolean)
  };
  return /* @__PURE__ */ jsx(WrappedInput, {
    ...props,
    rules: newRules,
    helperText
  });
};

const DataIndicatorContainer = styled.div`
  display: flex;
  flex-direction: column;
`;
const DataIndicatorLabelMd = styled(ParMd)`
  margin-bottom: 0.5rem;
  opacity: 0.9;
`;
const DataIndicatorLabelSm = styled(ParSm)`
  opacity: 0.9;
`;

const DataIndicator = ({
  label,
  data,
  size = "lg",
  info
}) => {
  if (size === "sm") {
    return /* @__PURE__ */ jsxs(DataIndicatorContainer, {
      children: [/* @__PURE__ */ jsxs(DataIndicatorLabelMd, {
        style: {
          marginBottom: "0.5rem"
        },
        children: [label, " ", info && /* @__PURE__ */ jsx(Tooltip, {
          content: info
        })]
      }), /* @__PURE__ */ jsx(DataMd, {
        children: data
      })]
    });
  }
  return /* @__PURE__ */ jsxs(DataIndicatorContainer, {
    children: [/* @__PURE__ */ jsxs(DataIndicatorLabelSm, {
      children: [label, " ", info && /* @__PURE__ */ jsx(Tooltip, {
        content: info
      })]
    }), /* @__PURE__ */ jsx(DataXl, {
      children: data
    })]
  });
};

const $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';
const $d3863c46a17e8a28$var$EVENT_OPTIONS = {
    bubbles: false,
    cancelable: true
};
const $d3863c46a17e8a28$export$20e40289641fbbb6 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { loop: loop = false , trapped: trapped = false , onMountAutoFocus: onMountAutoFocusProp , onUnmountAutoFocus: onUnmountAutoFocusProp , ...scopeProps } = props;
    const [container1, setContainer] = useState$1(null);
    const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
    const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
    const lastFocusedElementRef = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node)=>setContainer(node)
    );
    const focusScope = useRef({
        paused: false,
        pause () {
            this.paused = true;
        },
        resume () {
            this.paused = false;
        }
    }).current; // Takes care of trapping focus if focus is moved outside programmatically for example
    useEffect$1(()=>{
        if (trapped) {
            function handleFocusIn(event) {
                if (focusScope.paused || !container1) return;
                const target = event.target;
                if (container1.contains(target)) lastFocusedElementRef.current = target;
                else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
                    select: true
                });
            }
            function handleFocusOut(event) {
                if (focusScope.paused || !container1) return;
                if (!container1.contains(event.relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
                    select: true
                });
            }
            document.addEventListener('focusin', handleFocusIn);
            document.addEventListener('focusout', handleFocusOut);
            return ()=>{
                document.removeEventListener('focusin', handleFocusIn);
                document.removeEventListener('focusout', handleFocusOut);
            };
        }
    }, [
        trapped,
        container1,
        focusScope.paused
    ]);
    useEffect$1(()=>{
        if (container1) {
            $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
            const previouslyFocusedElement = document.activeElement;
            const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
            if (!hasFocusedCandidate) {
                const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
                container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
                container1.dispatchEvent(mountEvent);
                if (!mountEvent.defaultPrevented) {
                    $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
                        select: true
                    });
                    if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);
                }
            }
            return ()=>{
                container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.
                // We need to delay the focus a little to get around it for now.
                // See: https://github.com/facebook/react/issues/17894
                setTimeout(()=>{
                    const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
                    container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
                    container1.dispatchEvent(unmountEvent);
                    if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
                        select: true
                    });
                     // we need to remove the listener after we `dispatchEvent`
                    container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
                    $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
                }, 0);
            };
        }
    }, [
        container1,
        onMountAutoFocus,
        onUnmountAutoFocus,
        focusScope
    ]); // Takes care of looping focus (when tabbing whilst at the edges)
    const handleKeyDown = useCallback((event)=>{
        if (!loop && !trapped) return;
        if (focusScope.paused) return;
        const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
            const container = event.currentTarget;
            const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);
            const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges
            if (!hasTabbableElementsInside) {
                if (focusedElement === container) event.preventDefault();
            } else {
                if (!event.shiftKey && focusedElement === last) {
                    event.preventDefault();
                    if (loop) $d3863c46a17e8a28$var$focus(first, {
                        select: true
                    });
                } else if (event.shiftKey && focusedElement === first) {
                    event.preventDefault();
                    if (loop) $d3863c46a17e8a28$var$focus(last, {
                        select: true
                    });
                }
            }
        }
    }, [
        loop,
        trapped,
        focusScope.paused
    ]);
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
        tabIndex: -1
    }, scopeProps, {
        ref: composedRefs,
        onKeyDown: handleKeyDown
    }));
});
/* -------------------------------------------------------------------------------------------------
 * Utils
 * -----------------------------------------------------------------------------------------------*/ /**
 * Attempts focusing the first element in a list of candidates.
 * Stops when focus has actually moved.
 */ function $d3863c46a17e8a28$var$focusFirst(candidates, { select: select = false  } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates){
        $d3863c46a17e8a28$var$focus(candidate, {
            select: select
        });
        if (document.activeElement !== previouslyFocusedElement) return;
    }
}
/**
 * Returns the first and last tabbable elements inside a container.
 */ function $d3863c46a17e8a28$var$getTabbableEdges(container) {
    const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
    const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
    const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
    return [
        first,
        last
    ];
}
/**
 * Returns a list of potential tabbable candidates.
 *
 * NOTE: This is only a close approximation. For example it doesn't take into account cases like when
 * elements are not visible. This cannot be worked out easily by just reading a property, but rather
 * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker
 * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1
 */ function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node)=>{
            const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';
            if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the
            // runtime's understanding of tabbability, so this automatically accounts
            // for any kind of element that could be tabbed to.
            return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
    });
    while(walker.nextNode())nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it
    // hinders accessibility to have tab order different from visual order.
    return nodes;
}
/**
 * Returns the first visible element in a list.
 * NOTE: Only checks visibility up to the `container`.
 */ function $d3863c46a17e8a28$var$findVisible(elements, container) {
    for (const element of elements){
        // we stop checking if it's hidden at the `container` level (excluding)
        if (!$d3863c46a17e8a28$var$isHidden(element, {
            upTo: container
        })) return element;
    }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo: upTo  }) {
    if (getComputedStyle(node).visibility === 'hidden') return true;
    while(node){
        // we stop at `upTo` (excluding it)
        if (upTo !== undefined && node === upTo) return false;
        if (getComputedStyle(node).display === 'none') return true;
        node = node.parentElement;
    }
    return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
    return element instanceof HTMLInputElement && 'select' in element;
}
function $d3863c46a17e8a28$var$focus(element, { select: select = false  } = {}) {
    // only focus if that element is focusable
    if (element && element.focus) {
        const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users
        element.focus({
            preventScroll: true
        }); // only select if its not the same element, it supports selection and we need to select
        if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();
    }
}
/* -------------------------------------------------------------------------------------------------
 * FocusScope stack
 * -----------------------------------------------------------------------------------------------*/ const $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
    /** A stack of focus scopes, with the active one at the top */ let stack = [];
    return {
        add (focusScope) {
            // pause the currently active focus scope (at the top of the stack)
            const activeFocusScope = stack[0];
            if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
             // remove in case it already exists (because we'll re-add it at the top of the stack)
            stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
            stack.unshift(focusScope);
        },
        remove (focusScope) {
            var _stack$;
            stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
            (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
        }
    };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
    const updatedArray = [
        ...array
    ];
    const index = updatedArray.indexOf(item);
    if (index !== -1) updatedArray.splice(index, 1);
    return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
    return items.filter((item)=>item.tagName !== 'A'
    );
}

/** Number of components which have requested interest to have focus guards */ let $3db38b7d1fb3fe6a$var$count = 0;
/**
 * Injects a pair of focus guards at the edges of the whole DOM tree
 * to ensure `focusin` & `focusout` events can be caught consistently.
 */ function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
    useEffect$1(()=>{
        var _edgeGuards$, _edgeGuards$2;
        const edgeGuards = document.querySelectorAll('[data-radix-focus-guard]');
        document.body.insertAdjacentElement('afterbegin', (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
        document.body.insertAdjacentElement('beforeend', (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
        $3db38b7d1fb3fe6a$var$count++;
        return ()=>{
            if ($3db38b7d1fb3fe6a$var$count === 1) document.querySelectorAll('[data-radix-focus-guard]').forEach((node)=>node.remove()
            );
            $3db38b7d1fb3fe6a$var$count--;
        };
    }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
    const element = document.createElement('span');
    element.setAttribute('data-radix-focus-guard', '');
    element.tabIndex = 0;
    element.style.cssText = 'outline: none; opacity: 0; position: fixed; pointer-events: none';
    return element;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var zeroRightClassName = 'right-scroll-bar-position';
var fullWidthClassName = 'width-before-scroll-bar';
var noScrollbarsClassName = 'with-scroll-bars-hidden';
/**
 * Name of a CSS variable containing the amount of "hidden" scrollbar
 * ! might be undefined ! use will fallback!
 */
var removedBarSizeVariable = '--removed-body-scroll-bar-size';

/**
 * Assigns a value for a given ref, no matter of the ref format
 * @param {RefObject} ref - a callback function or ref object
 * @param value - a new value
 *
 * @see https://github.com/theKashey/use-callback-ref#assignref
 * @example
 * const refObject = useRef();
 * const refFn = (ref) => {....}
 *
 * assignRef(refObject, "refValue");
 * assignRef(refFn, "refValue");
 */
function assignRef(ref, value) {
    if (typeof ref === 'function') {
        ref(value);
    }
    else if (ref) {
        ref.current = value;
    }
    return ref;
}

/**
 * creates a MutableRef with ref change callback
 * @param initialValue - initial ref value
 * @param {Function} callback - a callback to run when value changes
 *
 * @example
 * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
 * ref.current = 1;
 * // prints 0 -> 1
 *
 * @see https://reactjs.org/docs/hooks-reference.html#useref
 * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
 * @returns {MutableRefObject}
 */
function useCallbackRef(initialValue, callback) {
    var ref = useState$1(function () { return ({
        // value
        value: initialValue,
        // last callback
        callback: callback,
        // "memoized" public interface
        facade: {
            get current() {
                return ref.value;
            },
            set current(value) {
                var last = ref.value;
                if (last !== value) {
                    ref.value = value;
                    ref.callback(value, last);
                }
            },
        },
    }); })[0];
    // update callback
    ref.callback = callback;
    return ref.facade;
}

/**
 * Merges two or more refs together providing a single interface to set their value
 * @param {RefObject|Ref} refs
 * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
 *
 * @see {@link mergeRefs} a version without buit-in memoization
 * @see https://github.com/theKashey/use-callback-ref#usemergerefs
 * @example
 * const Component = React.forwardRef((props, ref) => {
 *   const ownRef = useRef();
 *   const domRef = useMergeRefs([ref, ownRef]); // ðŸ‘ˆ merge together
 *   return <div ref={domRef}>...</div>
 * }
 */
function useMergeRefs(refs, defaultValue) {
    return useCallbackRef(defaultValue || null, function (newValue) { return refs.forEach(function (ref) { return assignRef(ref, newValue); }); });
}

function ItoI(a) {
    return a;
}
function innerCreateMedium(defaults, middleware) {
    if (middleware === void 0) { middleware = ItoI; }
    var buffer = [];
    var assigned = false;
    var medium = {
        read: function () {
            if (assigned) {
                throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');
            }
            if (buffer.length) {
                return buffer[buffer.length - 1];
            }
            return defaults;
        },
        useMedium: function (data) {
            var item = middleware(data, assigned);
            buffer.push(item);
            return function () {
                buffer = buffer.filter(function (x) { return x !== item; });
            };
        },
        assignSyncMedium: function (cb) {
            assigned = true;
            while (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
            }
            buffer = {
                push: function (x) { return cb(x); },
                filter: function () { return buffer; },
            };
        },
        assignMedium: function (cb) {
            assigned = true;
            var pendingQueue = [];
            if (buffer.length) {
                var cbs = buffer;
                buffer = [];
                cbs.forEach(cb);
                pendingQueue = buffer;
            }
            var executeQueue = function () {
                var cbs = pendingQueue;
                pendingQueue = [];
                cbs.forEach(cb);
            };
            var cycle = function () { return Promise.resolve().then(executeQueue); };
            cycle();
            buffer = {
                push: function (x) {
                    pendingQueue.push(x);
                    cycle();
                },
                filter: function (filter) {
                    pendingQueue = pendingQueue.filter(filter);
                    return buffer;
                },
            };
        },
    };
    return medium;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function createSidecarMedium(options) {
    if (options === void 0) { options = {}; }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options);
    return medium;
}

var SideCar$1 = function (_a) {
    var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
    if (!sideCar) {
        throw new Error('Sidecar: please provide `sideCar` property to import the right car');
    }
    var Target = sideCar.read();
    if (!Target) {
        throw new Error('Sidecar medium not found');
    }
    return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar$1;
}

var effectCar = createSidecarMedium();

var nothing = function () {
    return;
};
/**
 * Removes scrollbar from the page and contain the scroll within the Lock
 */
var RemoveScroll = React.forwardRef(function (props, parentRef) {
    var ref = React.useRef(null);
    var _a = React.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing,
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? 'div' : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
    var SideCar = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return (React.createElement(React.Fragment, null,
        enabled && (React.createElement(SideCar, { sideCar: effectCar, removeScrollBar: removeScrollBar, shards: shards, noIsolation: noIsolation, inert: inert, setCallbacks: setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref })),
        forwardProps ? (React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef }))) : (React.createElement(Container, __assign({}, containerProps, { className: className, ref: containerRef }), children))));
});
RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false,
};
RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName,
};

var getNonce = function () {
    if (typeof __webpack_nonce__ !== 'undefined') {
        return __webpack_nonce__;
    }
    return undefined;
};

function makeStyleTag() {
    if (!document)
        return null;
    var tag = document.createElement('style');
    tag.type = 'text/css';
    var nonce = getNonce();
    if (nonce) {
        tag.setAttribute('nonce', nonce);
    }
    return tag;
}
function injectStyles(tag, css) {
    // @ts-ignore
    if (tag.styleSheet) {
        // @ts-ignore
        tag.styleSheet.cssText = css;
    }
    else {
        tag.appendChild(document.createTextNode(css));
    }
}
function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(tag);
}
var stylesheetSingleton = function () {
    var counter = 0;
    var stylesheet = null;
    return {
        add: function (style) {
            if (counter == 0) {
                if ((stylesheet = makeStyleTag())) {
                    injectStyles(stylesheet, style);
                    insertStyleTag(stylesheet);
                }
            }
            counter++;
        },
        remove: function () {
            counter--;
            if (!counter && stylesheet) {
                stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
                stylesheet = null;
            }
        },
    };
};

/**
 * creates a hook to control style singleton
 * @see {@link styleSingleton} for a safer component version
 * @example
 * ```tsx
 * const useStyle = styleHookSingleton();
 * ///
 * useStyle('body { overflow: hidden}');
 */
var styleHookSingleton = function () {
    var sheet = stylesheetSingleton();
    return function (styles, isDynamic) {
        React.useEffect(function () {
            sheet.add(styles);
            return function () {
                sheet.remove();
            };
        }, [styles && isDynamic]);
    };
};

/**
 * create a Component to add styles on demand
 * - styles are added when first instance is mounted
 * - styles are removed when the last instance is unmounted
 * - changing styles in runtime does nothing unless dynamic is set. But with multiple components that can lead to the undefined behavior
 */
var styleSingleton = function () {
    var useStyle = styleHookSingleton();
    var Sheet = function (_a) {
        var styles = _a.styles, dynamic = _a.dynamic;
        useStyle(styles, dynamic);
        return null;
    };
    return Sheet;
};

var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0,
};
var parse = function (x) { return parseInt(x || '', 10) || 0; };
var getOffset = function (gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];
    var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];
    var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];
    return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function (gapMode) {
    if (gapMode === void 0) { gapMode = 'margin'; }
    if (typeof window === 'undefined') {
        return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
        left: offsets[0],
        top: offsets[1],
        right: offsets[2],
        gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0]),
    };
};

var Style = styleSingleton();
// important tip - once we measure scrollBar width and remove them
// we could not repeat this operation
// thus we are using style-singleton - only the first "yet correct" style will be applied.
var getStyles = function (_a, allowRelative, gapMode, important) {
    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
    if (gapMode === void 0) { gapMode = 'margin'; }
    return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
        allowRelative && "position: relative ".concat(important, ";"),
        gapMode === 'margin' &&
            "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
        gapMode === 'padding' && "padding-right: ".concat(gap, "px ").concat(important, ";"),
    ]
        .filter(Boolean)
        .join(''), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
/**
 * Removes page scrollbar and blocks page scroll when mounted
 */
var RemoveScrollBar = function (props) {
    var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? 'margin' : _a;
    var gap = React.useMemo(function () { return getGapWidth(gapMode); }, [gapMode]);
    return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : '') });
};

var passiveSupported = false;
if (typeof window !== 'undefined') {
    try {
        var options = Object.defineProperty({}, 'passive', {
            get: function () {
                passiveSupported = true;
                return true;
            },
        });
        // @ts-ignore
        window.addEventListener('test', options, options);
        // @ts-ignore
        window.removeEventListener('test', options, options);
    }
    catch (err) {
        passiveSupported = false;
    }
}
var nonPassive = passiveSupported ? { passive: false } : false;

var elementCouldBeVScrolled = function (node) {
    var styles = window.getComputedStyle(node);
    return (styles.overflowY !== 'hidden' && // not-not-scrollable
        !(styles.overflowY === styles.overflowX && styles.overflowY === 'visible') // scrollable
    );
};
var elementCouldBeHScrolled = function (node) {
    var styles = window.getComputedStyle(node);
    return (styles.overflowX !== 'hidden' && // not-not-scrollable
        !(styles.overflowY === styles.overflowX && styles.overflowX === 'visible') // scrollable
    );
};
var locationCouldBeScrolled = function (axis, node) {
    var current = node;
    do {
        // Skip over shadow root
        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {
            current = current.host;
        }
        var isScrollable = elementCouldBeScrolled(axis, current);
        if (isScrollable) {
            var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
            if (s > d) {
                return true;
            }
        }
        current = current.parentNode;
    } while (current && current !== document.body);
    return false;
};
var getVScrollVariables = function (_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
        scrollTop,
        scrollHeight,
        clientHeight,
    ];
};
var getHScrollVariables = function (_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
        scrollLeft,
        scrollWidth,
        clientWidth,
    ];
};
var elementCouldBeScrolled = function (axis, node) {
    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function (axis, node) {
    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function (axis, direction) {
    /**
     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,
     * and then increasingly negative as you scroll towards the end of the content.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft
     */
    return axis === 'h' && direction === 'rtl' ? -1 : 1;
};
var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    // find scrollable target
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
        var elementScroll = scroll_1 - capacity - directionFactor * position;
        if (position || elementScroll) {
            if (elementCouldBeScrolled(axis, target)) {
                availableScroll += elementScroll;
                availableScrollTop += position;
            }
        }
        target = target.parentNode;
    } while (
    // portaled content
    (!targetInLock && target !== document.body) ||
        // self content
        (targetInLock && (endTarget.contains(target) || endTarget === target)));
    if (isDeltaPositive && ((noOverscroll && availableScroll === 0) || (!noOverscroll && delta > availableScroll))) {
        shouldCancelScroll = true;
    }
    else if (!isDeltaPositive &&
        ((noOverscroll && availableScrollTop === 0) || (!noOverscroll && -delta > availableScrollTop))) {
        shouldCancelScroll = true;
    }
    return shouldCancelScroll;
};

var getTouchXY = function (event) {
    return 'changedTouches' in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function (event) { return [event.deltaX, event.deltaY]; };
var extractRef = function (ref) {
    return ref && 'current' in ref ? ref.current : ref;
};
var deltaCompare = function (x, y) { return x[0] === y[0] && x[1] === y[1]; };
var generateStyle = function (id) { return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n"); };
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
    var shouldPreventQueue = React.useRef([]);
    var touchStartRef = React.useRef([0, 0]);
    var activeAxis = React.useRef();
    var id = React.useState(idCounter++)[0];
    var Style = React.useState(function () { return styleSingleton(); })[0];
    var lastProps = React.useRef(props);
    React.useEffect(function () {
        lastProps.current = props;
    }, [props]);
    React.useEffect(function () {
        if (props.inert) {
            document.body.classList.add("block-interactivity-".concat(id));
            var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
            allow_1.forEach(function (el) { return el.classList.add("allow-interactivity-".concat(id)); });
            return function () {
                document.body.classList.remove("block-interactivity-".concat(id));
                allow_1.forEach(function (el) { return el.classList.remove("allow-interactivity-".concat(id)); });
            };
        }
        return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React.useCallback(function (event, parent) {
        if ('touches' in event && event.touches.length === 2) {
            return !lastProps.current.allowPinchZoom;
        }
        var touch = getTouchXY(event);
        var touchStart = touchStartRef.current;
        var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];
        var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];
        var currentAxis;
        var target = event.target;
        var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';
        // allow horizontal touch move on Range inputs. They will not cause any scroll
        if ('touches' in event && moveDirection === 'h' && target.type === 'range') {
            return false;
        }
        var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
        if (!canBeScrolledInMainDirection) {
            return true;
        }
        if (canBeScrolledInMainDirection) {
            currentAxis = moveDirection;
        }
        else {
            currentAxis = moveDirection === 'v' ? 'h' : 'v';
            canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
            // other axis might be not scrollable
        }
        if (!canBeScrolledInMainDirection) {
            return false;
        }
        if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {
            activeAxis.current = currentAxis;
        }
        if (!currentAxis) {
            return true;
        }
        var cancelingAxis = activeAxis.current || currentAxis;
        return handleScroll(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = React.useCallback(function (_event) {
        var event = _event;
        if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {
            // not the last active
            return;
        }
        var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);
        var sourceEvent = shouldPreventQueue.current.filter(function (e) { return e.name === event.type && e.target === event.target && deltaCompare(e.delta, delta); })[0];
        // self event, and should be canceled
        if (sourceEvent && sourceEvent.should) {
            event.preventDefault();
            return;
        }
        // outside or shard event
        if (!sourceEvent) {
            var shardNodes = (lastProps.current.shards || [])
                .map(extractRef)
                .filter(Boolean)
                .filter(function (node) { return node.contains(event.target); });
            var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
            if (shouldStop) {
                event.preventDefault();
            }
        }
    }, []);
    var shouldCancel = React.useCallback(function (name, delta, target, should) {
        var event = { name: name, delta: delta, target: target, should: should };
        shouldPreventQueue.current.push(event);
        setTimeout(function () {
            shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) { return e !== event; });
        }, 1);
    }, []);
    var scrollTouchStart = React.useCallback(function (event) {
        touchStartRef.current = getTouchXY(event);
        activeAxis.current = undefined;
    }, []);
    var scrollWheel = React.useCallback(function (event) {
        shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React.useCallback(function (event) {
        shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React.useEffect(function () {
        lockStack.push(Style);
        props.setCallbacks({
            onScrollCapture: scrollWheel,
            onWheelCapture: scrollWheel,
            onTouchMoveCapture: scrollTouchMove,
        });
        document.addEventListener('wheel', shouldPrevent, nonPassive);
        document.addEventListener('touchmove', shouldPrevent, nonPassive);
        document.addEventListener('touchstart', scrollTouchStart, nonPassive);
        return function () {
            lockStack = lockStack.filter(function (inst) { return inst !== Style; });
            document.removeEventListener('wheel', shouldPrevent, nonPassive);
            document.removeEventListener('touchmove', shouldPrevent, nonPassive);
            document.removeEventListener('touchstart', scrollTouchStart, nonPassive);
        };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return (React.createElement(React.Fragment, null,
        inert ? React.createElement(Style, { styles: generateStyle(id) }) : null,
        removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: "margin" }) : null));
}

var SideCar = exportSidecar(effectCar, RemoveScrollSideCar);

var ReactRemoveScroll = React.forwardRef(function (props, ref) { return (React.createElement(RemoveScroll, __assign({}, props, { ref: ref, sideCar: SideCar }))); });
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var $epM9y$RemoveScroll = ReactRemoveScroll;

var getDefaultParent = function (originalTarget) {
    if (typeof document === 'undefined') {
        return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @param {String} [controlAttribute] - html Attribute to control
 * @return {Undo} undo command
 */
var applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {
    var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
    if (!markerMap[markerName]) {
        markerMap[markerName] = new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = new Set();
    var elementsToStop = new Set(targets);
    var keep = function (el) {
        if (!el || elementsToKeep.has(el)) {
            return;
        }
        elementsToKeep.add(el);
        keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function (parent) {
        if (!parent || elementsToStop.has(parent)) {
            return;
        }
        Array.prototype.forEach.call(parent.children, function (node) {
            if (elementsToKeep.has(node)) {
                deep(node);
            }
            else {
                var attr = node.getAttribute(controlAttribute);
                var alreadyHidden = attr !== null && attr !== 'false';
                var counterValue = (counterMap.get(node) || 0) + 1;
                var markerValue = (markerCounter.get(node) || 0) + 1;
                counterMap.set(node, counterValue);
                markerCounter.set(node, markerValue);
                hiddenNodes.push(node);
                if (counterValue === 1 && alreadyHidden) {
                    uncontrolledNodes.set(node, true);
                }
                if (markerValue === 1) {
                    node.setAttribute(markerName, 'true');
                }
                if (!alreadyHidden) {
                    node.setAttribute(controlAttribute, 'true');
                }
            }
        });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function () {
        hiddenNodes.forEach(function (node) {
            var counterValue = counterMap.get(node) - 1;
            var markerValue = markerCounter.get(node) - 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                    node.removeAttribute(controlAttribute);
                }
                uncontrolledNodes.delete(node);
            }
            if (!markerValue) {
                node.removeAttribute(markerName);
            }
        });
        lockCount--;
        if (!lockCount) {
            // clear
            counterMap = new WeakMap();
            counterMap = new WeakMap();
            uncontrolledNodes = new WeakMap();
            markerMap = {};
        }
    };
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var hideOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) { markerName = 'data-aria-hidden'; }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function () { return null; };
    }
    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));
    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
};

/* -------------------------------------------------------------------------------------------------
 * Dialog
 * -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$DIALOG_NAME = 'Dialog';
const [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);
const [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);
const $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props)=>{
    const { __scopeDialog: __scopeDialog , children: children , open: openProp , defaultOpen: defaultOpen , onOpenChange: onOpenChange , modal: modal = true  } = props;
    const triggerRef = useRef(null);
    const contentRef = useRef(null);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: onOpenChange
    });
    return /*#__PURE__*/ createElement($5d3850c4d0b4e6c7$var$DialogProvider, {
        scope: __scopeDialog,
        triggerRef: triggerRef,
        contentRef: contentRef,
        contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
        titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
        descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
        open: open,
        onOpenChange: setOpen,
        onOpenToggle: useCallback(()=>setOpen((prevOpen)=>!prevOpen
            )
        , [
            setOpen
        ]),
        modal: modal
    }, children);
};
/* -------------------------------------------------------------------------------------------------
 * DialogTrigger
 * -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$TRIGGER_NAME = 'DialogTrigger';
const $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDialog: __scopeDialog , ...triggerProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, triggerProps, {
        ref: composedTriggerRef,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
    }));
});
/* -------------------------------------------------------------------------------------------------
 * DialogPortal
 * -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$PORTAL_NAME = 'DialogPortal';
const [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
    forceMount: undefined
});
const $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props)=>{
    const { __scopeDialog: __scopeDialog , forceMount: forceMount , children: children , container: container  } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);
    return /*#__PURE__*/ createElement($5d3850c4d0b4e6c7$var$PortalProvider, {
        scope: __scopeDialog,
        forceMount: forceMount
    }, Children.map(children, (child)=>/*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
            present: forceMount || context.open
        }, /*#__PURE__*/ createElement($f1701beae083dbae$export$602eac185826482c, {
            asChild: true,
            container: container
        }, child))
    ));
};
/* -------------------------------------------------------------------------------------------------
 * DialogOverlay
 * -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$OVERLAY_NAME = 'DialogOverlay';
const $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
    const { forceMount: forceMount = portalContext.forceMount , ...overlayProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
    }, /*#__PURE__*/ createElement($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends$2({}, overlayProps, {
        ref: forwardedRef
    }))) : null;
});
const $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDialog: __scopeDialog , ...overlayProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);
    return(/*#__PURE__*/ // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    createElement($epM9y$RemoveScroll, {
        as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
        allowPinchZoom: true,
        shards: [
            context.contentRef
        ]
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
        "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, overlayProps, {
        ref: forwardedRef // We re-enable pointer-events prevented by `Dialog.Content` to allow scrolling the overlay.
        ,
        style: {
            pointerEvents: 'auto',
            ...overlayProps.style
        }
    }))));
});
/* -------------------------------------------------------------------------------------------------
 * DialogContent
 * -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$CONTENT_NAME = 'DialogContent';
const $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const { forceMount: forceMount = portalContext.forceMount , ...contentProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    return /*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
    }, context.modal ? /*#__PURE__*/ createElement($5d3850c4d0b4e6c7$var$DialogContentModal, _extends$2({}, contentProps, {
        ref: forwardedRef
    })) : /*#__PURE__*/ createElement($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends$2({}, contentProps, {
        ref: forwardedRef
    })));
});
/* -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$DialogContentModal = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const contentRef = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef); // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    useEffect$1(()=>{
        const content = contentRef.current;
        if (content) return hideOthers(content);
    }, []);
    return /*#__PURE__*/ createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends$2({}, props, {
        ref: composedRefs // we make sure focus isn't trapped once `DialogContent` has been closed
        ,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event)=>{
            var _context$triggerRef$c;
            event.preventDefault();
            (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
        }),
        onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event)=>{
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick; // If the event is a right-click, we shouldn't close because
            // it is effectively as if we right-clicked the `Overlay`.
            if (isRightClick) event.preventDefault();
        }) // When focus is trapped, a `focusout` event may still happen.
        ,
        onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event)=>event.preventDefault()
        )
    }));
});
/* -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$DialogContentNonModal = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = useRef(false);
    return /*#__PURE__*/ createElement($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends$2({}, props, {
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event)=>{
            var _props$onCloseAutoFoc;
            (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
            if (!event.defaultPrevented) {
                var _context$triggerRef$c2;
                if (!hasInteractedOutsideRef.current) (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus(); // Always prevent auto focus because we either focus manually or want user agent focus
                event.preventDefault();
            }
            hasInteractedOutsideRef.current = false;
        },
        onInteractOutside: (event)=>{
            var _props$onInteractOuts, _context$triggerRef$c3;
            (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
            if (!event.defaultPrevented) hasInteractedOutsideRef.current = true; // Prevent dismissing when clicking the trigger.
            // As the trigger is already setup to close, without doing so would
            // cause it to close and immediately open.
            //
            // We use `onInteractOutside` as some browsers also
            // focus on pointer down, creating the same issue.
            const target = event.target;
            const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
            if (targetIsTrigger) event.preventDefault();
        }
    }));
});
/* -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$DialogContentImpl = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDialog: __scopeDialog , trapFocus: trapFocus , onOpenAutoFocus: onOpenAutoFocus , onCloseAutoFocus: onCloseAutoFocus , ...contentProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);
    const contentRef = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef); // Make sure the whole tree has focus guards as our `Dialog` will be
    // the last element in the DOM (beacuse of the `Portal`)
    $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
    return /*#__PURE__*/ createElement(Fragment$1, null, /*#__PURE__*/ createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus
    }, /*#__PURE__*/ createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends$2({
        role: "dialog",
        id: context.contentId,
        "aria-describedby": context.descriptionId,
        "aria-labelledby": context.titleId,
        "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, contentProps, {
        ref: composedRefs,
        onDismiss: ()=>context.onOpenChange(false)
    }))), false);
});
/* -------------------------------------------------------------------------------------------------
 * DialogTitle
 * -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$TITLE_NAME = 'DialogTitle';
const $5d3850c4d0b4e6c7$export$16f7638e4a34b909 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDialog: __scopeDialog , ...titleProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TITLE_NAME, __scopeDialog);
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.h2, _extends$2({
        id: context.titleId
    }, titleProps, {
        ref: forwardedRef
    }));
});
/* -------------------------------------------------------------------------------------------------
 * DialogDescription
 * -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$DESCRIPTION_NAME = 'DialogDescription';
const $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDialog: __scopeDialog , ...descriptionProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$DESCRIPTION_NAME, __scopeDialog);
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.p, _extends$2({
        id: context.descriptionId
    }, descriptionProps, {
        ref: forwardedRef
    }));
});
/* -------------------------------------------------------------------------------------------------
 * DialogClose
 * -----------------------------------------------------------------------------------------------*/ const $5d3850c4d0b4e6c7$var$CLOSE_NAME = 'DialogClose';
const $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDialog: __scopeDialog , ...closeProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
        type: "button"
    }, closeProps, {
        ref: forwardedRef,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, ()=>context.onOpenChange(false)
        )
    }));
});
/* -----------------------------------------------------------------------------------------------*/ function $5d3850c4d0b4e6c7$var$getState(open) {
    return open ? 'open' : 'closed';
}
const $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME = 'DialogTitleWarning';
$c512c27ab02ef895$export$fd42f52fd3ae1109($5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, {
    contentName: $5d3850c4d0b4e6c7$var$CONTENT_NAME,
    titleName: $5d3850c4d0b4e6c7$var$TITLE_NAME,
    docsSlug: 'dialog'
});
const $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;
const $5d3850c4d0b4e6c7$export$41fb9f06171c75f4 = $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88;
const $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;
const $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;
const $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;
const $5d3850c4d0b4e6c7$export$f99233281efd08a0 = $5d3850c4d0b4e6c7$export$16f7638e4a34b909;
const $5d3850c4d0b4e6c7$export$393edc798c47379d = $5d3850c4d0b4e6c7$export$94e94c2ec2c954d5;
const $5d3850c4d0b4e6c7$export$f39c2d165cd861fe = $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac;

const DialogRoot = $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9;
const DialogPrimitaveTrigger = $5d3850c4d0b4e6c7$export$41fb9f06171c75f4;
const DialogClose = $5d3850c4d0b4e6c7$export$f39c2d165cd861fe;
const DialogPortal = $5d3850c4d0b4e6c7$export$602eac185826482c;
const DialogTitle = $5d3850c4d0b4e6c7$export$f99233281efd08a0;
const DialogDescription = $5d3850c4d0b4e6c7$export$393edc798c47379d;
const overlayShow = keyframes`
  0% { opacity: 0 };
  100% { opacity: 1 };
`;
const StyledDialogOverlay = styled($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff)`
  background-color: ${() => indigoA$1.indigoA4};
  position: fixed;
  inset: 0;
  @media (prefers-reduced-motion: no-preference) {
    animation: ${overlayShow} 150ms cubic-bezier(0.16, 1, 0.3, 1);
  } ;
`;
const contentShow = keyframes`
  0% { opacity: 0; transform: translate(-50%, -48%) scale(.96) };
  100% { opacity: 1; transform: translate(-50%, -50%) scale(1) };
`;
const StyledDialogContent = styled($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2)`
  background-color: ${({ theme }) => theme.dialog.bg};
  border-radius: 8px;
  box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
    hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
  color: ${({ theme }) => theme.dialog.color};
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  left: 50%;
  max-height: 85vh;
  max-width: 80%;
  min-height: 23rem;
  padding: 3rem;
  position: fixed;
  top: 50%;
  transform: translate(-50%, -50%);
  overflow-y: auto;
  @media (prefers-reduced-motion: no-preference) {
    animation: ${contentShow} 150ms cubic-bezier(0.16, 1, 0.3, 1);
  }
  &:focus {
    outline: none;
  }
`;
const DialogBody = styled.div`
  display: flex;
  height: auto;
  width: 100%;
`;
const HeaderContainer = styled.div`
  align-items: baseline;
  display: flex;
  justify-content: space-between;
  margin-bottom: 1rem;
`;
const CloseIcon = styled.div`
  margin-left: auto;
  cursor: pointer;
  font-size: 24px;
`;
const ButtonContainer = styled.div`
  align-self: ${(props) => `flex-${props.align}`};
  display: flex;
  gap: 1rem;
`;

const Dialog = DialogRoot;
const DialogTrigger = DialogPrimitaveTrigger;
const DialogContent = React__default.forwardRef(({
  title,
  children,
  description,
  alignButtons = "end",
  leftButton,
  rightButton,
  ...props
}, ref) => {
  return /* @__PURE__ */ jsxs(DialogPortal, {
    children: [/* @__PURE__ */ jsx(StyledDialogOverlay, {}), /* @__PURE__ */ jsxs(StyledDialogContent, {
      ...props,
      ref,
      children: [/* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsxs(HeaderContainer, {
          children: [/* @__PURE__ */ jsx(DialogTitle, {
            asChild: true,
            children: /* @__PURE__ */ jsx(H5, {
              children: title
            })
          }), /* @__PURE__ */ jsx(DialogClose, {
            asChild: true,
            children: /* @__PURE__ */ jsx(CloseIcon, {
              children: /* @__PURE__ */ jsx(RiCloseFill, {
                "aria-hidden": true
              })
            })
          })]
        }), /* @__PURE__ */ jsx(DialogBody, {
          children: /* @__PURE__ */ jsx(DialogDescription, {
            children: description
          })
        }), children]
      }), (leftButton || rightButton) && /* @__PURE__ */ jsxs(ButtonContainer, {
        align: alignButtons,
        children: [leftButton && /* @__PURE__ */ jsx(Button, {
          secondary: true,
          sm: true,
          ...leftButton,
          children: leftButton?.children
        }), rightButton && /* @__PURE__ */ jsx(Button, {
          secondary: true,
          sm: true,
          ...rightButton,
          children: rightButton?.children
        })]
      })]
    })]
  });
});

const $f631663db3294ace$var$DirectionContext = /*#__PURE__*/ createContext(undefined);
/* -----------------------------------------------------------------------------------------------*/ function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
    const globalDir = useContext($f631663db3294ace$var$DirectionContext);
    return localDir || globalDir || 'ltr';
}

const $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';
const $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
    bubbles: false,
    cancelable: true
};
/* -------------------------------------------------------------------------------------------------
 * RovingFocusGroup
 * -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$GROUP_NAME = 'RovingFocusGroup';
const [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
const [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
    $d7bdfb9eb0fdf311$var$createCollectionScope
]);
const [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
const $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    return /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$var$Collection.Provider, {
        scope: props.__scopeRovingFocusGroup
    }, /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$var$Collection.Slot, {
        scope: props.__scopeRovingFocusGroup
    }, /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends$2({}, props, {
        ref: forwardedRef
    }))));
});
/* -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeRovingFocusGroup: __scopeRovingFocusGroup , orientation: orientation , loop: loop = false , dir: dir , currentTabStopId: currentTabStopIdProp , defaultCurrentTabStopId: defaultCurrentTabStopId , onCurrentTabStopIdChange: onCurrentTabStopIdChange , onEntryFocus: onEntryFocus , ...groupProps } = props;
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: currentTabStopIdProp,
        defaultProp: defaultCurrentTabStopId,
        onChange: onCurrentTabStopIdChange
    });
    const [isTabbingBackOut, setIsTabbingBackOut] = useState$1(false);
    const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
    const isClickFocusRef = useRef(false);
    useEffect$1(()=>{
        const node = ref.current;
        if (node) {
            node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
            return ()=>node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus)
            ;
        }
    }, [
        handleEntryFocus
    ]);
    return /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
        scope: __scopeRovingFocusGroup,
        orientation: orientation,
        dir: direction,
        loop: loop,
        currentTabStopId: currentTabStopId,
        onItemFocus: useCallback((tabStopId)=>setCurrentTabStopId(tabStopId)
        , [
            setCurrentTabStopId
        ]),
        onItemShiftTab: useCallback(()=>setIsTabbingBackOut(true)
        , [])
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
        tabIndex: isTabbingBackOut ? -1 : 0,
        "data-orientation": orientation
    }, groupProps, {
        ref: composedRefs,
        style: {
            outline: 'none',
            ...props.style
        },
        onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, ()=>{
            isClickFocusRef.current = true;
        }),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event)=>{
            // We normally wouldn't need this check, because we already check
            // that the focus is on the current target and not bubbling to it.
            // We do this because Safari doesn't focus buttons when clicked, and
            // instead, the wrapper will get focused and not through a bubbling event.
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
                const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
                event.currentTarget.dispatchEvent(entryFocusEvent);
                if (!entryFocusEvent.defaultPrevented) {
                    const items = getItems().filter((item)=>item.focusable
                    );
                    const activeItem = items.find((item)=>item.active
                    );
                    const currentItem = items.find((item)=>item.id === currentTabStopId
                    );
                    const candidateItems = [
                        activeItem,
                        currentItem,
                        ...items
                    ].filter(Boolean);
                    const candidateNodes = candidateItems.map((item)=>item.ref.current
                    );
                    $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
                }
            }
            isClickFocusRef.current = false;
        }),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, ()=>setIsTabbingBackOut(false)
        )
    })));
});
/* -------------------------------------------------------------------------------------------------
 * RovingFocusGroupItem
 * -----------------------------------------------------------------------------------------------*/ const $d7bdfb9eb0fdf311$var$ITEM_NAME = 'RovingFocusGroupItem';
const $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeRovingFocusGroup: __scopeRovingFocusGroup , focusable: focusable = true , active: active = false , ...itemProps } = props;
    const id = $1746a345f3d73bb7$export$f680877a34711e37();
    const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
    return /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
        scope: __scopeRovingFocusGroup,
        id: id,
        focusable: focusable,
        active: active
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({
        tabIndex: isCurrentTabStop ? 0 : -1,
        "data-orientation": context.orientation
    }, itemProps, {
        ref: forwardedRef,
        onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event)=>{
            // We prevent focusing non-focusable items on `mousedown`.
            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.
            if (!focusable) event.preventDefault(); // Safari doesn't focus a button when clicked so we run our logic on mousedown also
            else context.onItemFocus(id);
        }),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, ()=>context.onItemFocus(id)
        ),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event)=>{
            if (event.key === 'Tab' && event.shiftKey) {
                context.onItemShiftTab();
                return;
            }
            if (event.target !== event.currentTarget) return;
            const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
            if (focusIntent !== undefined) {
                event.preventDefault();
                const items = getItems().filter((item)=>item.focusable
                );
                let candidateNodes = items.map((item)=>item.ref.current
                );
                if (focusIntent === 'last') candidateNodes.reverse();
                else if (focusIntent === 'prev' || focusIntent === 'next') {
                    if (focusIntent === 'prev') candidateNodes.reverse();
                    const currentIndex = candidateNodes.indexOf(event.currentTarget);
                    candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                /**
         * Imperative focus during keydown is risky so we prevent React's batching updates
         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332
         */ setTimeout(()=>$d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
                );
            }
        })
    })));
});
/* -----------------------------------------------------------------------------------------------*/ // prettier-ignore
const $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
    ArrowLeft: 'prev',
    ArrowUp: 'prev',
    ArrowRight: 'next',
    ArrowDown: 'next',
    PageUp: 'first',
    Home: 'first',
    PageDown: 'last',
    End: 'last'
};
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
    if (dir !== 'rtl') return key;
    return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
    const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
    if (orientation === 'vertical' && [
        'ArrowLeft',
        'ArrowRight'
    ].includes(key)) return undefined;
    if (orientation === 'horizontal' && [
        'ArrowUp',
        'ArrowDown'
    ].includes(key)) return undefined;
    return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates){
        // if focus is already where we want to go, we don't want to keep going through the candidates
        if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
        candidate.focus();
        if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
    }
}
/**
 * Wraps an array around itself at a given start index
 * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`
 */ function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
    return array.map((_, index)=>array[(startIndex + index) % array.length]
    );
}
const $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
const $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;

const $6cc32821e9371a1c$var$SELECTION_KEYS = [
    'Enter',
    ' '
];
const $6cc32821e9371a1c$var$FIRST_KEYS = [
    'ArrowDown',
    'PageUp',
    'Home'
];
const $6cc32821e9371a1c$var$LAST_KEYS = [
    'ArrowUp',
    'PageDown',
    'End'
];
const $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [
    ...$6cc32821e9371a1c$var$FIRST_KEYS,
    ...$6cc32821e9371a1c$var$LAST_KEYS
];
/* -------------------------------------------------------------------------------------------------
 * Menu
 * -----------------------------------------------------------------------------------------------*/ const $6cc32821e9371a1c$var$MENU_NAME = 'Menu';
const [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);
const [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [
    $6cc32821e9371a1c$var$createCollectionScope,
    $cf1ac5d9fe0e8206$export$722aac194ae923,
    $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
const $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
const $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
const [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
const [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
const $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props)=>{
    const { __scopeMenu: __scopeMenu , open: open = false , children: children , dir: dir , onOpenChange: onOpenChange , modal: modal = true  } = props;
    const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
    const [content, setContent] = useState$1(null);
    const isUsingKeyboardRef = useRef(false);
    const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    useEffect$1(()=>{
        // Capture phase ensures we set the boolean before any side effects execute
        // in response to the key or pointer event as they might depend on this value.
        const handleKeyDown = ()=>{
            isUsingKeyboardRef.current = true;
            document.addEventListener('pointerdown', handlePointer, {
                capture: true,
                once: true
            });
            document.addEventListener('pointermove', handlePointer, {
                capture: true,
                once: true
            });
        };
        const handlePointer = ()=>isUsingKeyboardRef.current = false
        ;
        document.addEventListener('keydown', handleKeyDown, {
            capture: true
        });
        return ()=>{
            document.removeEventListener('keydown', handleKeyDown, {
                capture: true
            });
            document.removeEventListener('pointerdown', handlePointer, {
                capture: true
            });
            document.removeEventListener('pointermove', handlePointer, {
                capture: true
            });
        };
    }, []);
    return /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /*#__PURE__*/ createElement($6cc32821e9371a1c$var$MenuProvider, {
        scope: __scopeMenu,
        open: open,
        onOpenChange: handleOpenChange,
        content: content,
        onContentChange: setContent
    }, /*#__PURE__*/ createElement($6cc32821e9371a1c$var$MenuRootProvider, {
        scope: __scopeMenu,
        onClose: useCallback(()=>handleOpenChange(false)
        , [
            handleOpenChange
        ]),
        isUsingKeyboardRef: isUsingKeyboardRef,
        dir: direction,
        modal: modal
    }, children)));
};
const $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeMenu: __scopeMenu , ...anchorProps } = props;
    const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
    return /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends$2({}, popperScope, anchorProps, {
        ref: forwardedRef
    }));
});
/* -------------------------------------------------------------------------------------------------
 * MenuPortal
 * -----------------------------------------------------------------------------------------------*/ const $6cc32821e9371a1c$var$PORTAL_NAME = 'MenuPortal';
const [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {
    forceMount: undefined
});
/* -------------------------------------------------------------------------------------------------
 * MenuContent
 * -----------------------------------------------------------------------------------------------*/ const $6cc32821e9371a1c$var$CONTENT_NAME = 'MenuContent';
const [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);
const $6cc32821e9371a1c$export$479f0f2f71193efe = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const { forceMount: forceMount = portalContext.forceMount , ...contentProps } = props;
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$var$Collection.Provider, {
        scope: props.__scopeMenu
    }, /*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
    }, /*#__PURE__*/ createElement($6cc32821e9371a1c$var$Collection.Slot, {
        scope: props.__scopeMenu
    }, rootContext.modal ? /*#__PURE__*/ createElement($6cc32821e9371a1c$var$MenuRootContentModal, _extends$2({}, contentProps, {
        ref: forwardedRef
    })) : /*#__PURE__*/ createElement($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends$2({}, contentProps, {
        ref: forwardedRef
    })))));
});
/* ---------------------------------------------------------------------------------------------- */ const $6cc32821e9371a1c$var$MenuRootContentModal = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref); // Hide everything from ARIA except the `MenuContent`
    useEffect$1(()=>{
        const content = ref.current;
        if (content) return hideOthers(content);
    }, []);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends$2({}, props, {
        ref: composedRefs // we make sure we're not trapping once it's been closed
        ,
        trapFocus: context.open // make sure to only disable pointer events when open
        ,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true // When focus is trapped, a `focusout` event may still happen.
        ,
        onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event)=>event.preventDefault()
        , {
            checkForDefaultPrevented: false
        }),
        onDismiss: ()=>context.onOpenChange(false)
    }));
});
const $6cc32821e9371a1c$var$MenuRootContentNonModal = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends$2({}, props, {
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        onDismiss: ()=>context.onOpenChange(false)
    }));
});
/* ---------------------------------------------------------------------------------------------- */ const $6cc32821e9371a1c$var$MenuContentImpl = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeMenu: __scopeMenu , loop: loop = false , trapFocus: trapFocus , onOpenAutoFocus: onOpenAutoFocus , onCloseAutoFocus: onCloseAutoFocus , disableOutsidePointerEvents: disableOutsidePointerEvents , onEscapeKeyDown: onEscapeKeyDown , onPointerDownOutside: onPointerDownOutside , onFocusOutside: onFocusOutside , onInteractOutside: onInteractOutside , onDismiss: onDismiss , disableOutsideScroll: disableOutsideScroll , ...contentProps } = props;
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
    const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
    const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
    const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
    const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);
    const [currentItemId, setCurrentItemId] = useState$1(null);
    const contentRef = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef, context.onContentChange);
    const timerRef = useRef(0);
    const searchRef = useRef('');
    const pointerGraceTimerRef = useRef(0);
    const pointerGraceIntentRef = useRef(null);
    const pointerDirRef = useRef('right');
    const lastPointerXRef = useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? $epM9y$RemoveScroll : Fragment$1;
    const scrollLockWrapperProps = disableOutsideScroll ? {
        as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
        allowPinchZoom: true
    } : undefined;
    const handleTypeaheadSearch = (key)=>{
        var _items$find, _items$find2;
        const search = searchRef.current + key;
        const items = getItems().filter((item)=>!item.disabled
        );
        const currentItem = document.activeElement;
        const currentMatch = (_items$find = items.find((item)=>item.ref.current === currentItem
        )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;
        const values = items.map((item)=>item.textValue
        );
        const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch);
        const newItem = (_items$find2 = items.find((item)=>item.textValue === nextMatch
        )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current; // Reset `searchRef` 1 second after it was last updated
        (function updateSearch(value) {
            searchRef.current = value;
            window.clearTimeout(timerRef.current);
            if (value !== '') timerRef.current = window.setTimeout(()=>updateSearch('')
            , 1000);
        })(search);
        if (newItem) /**
       * Imperative focus during keydown is risky so we prevent React's batching updates
       * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332
       */ setTimeout(()=>newItem.focus()
        );
    };
    useEffect$1(()=>{
        return ()=>window.clearTimeout(timerRef.current)
        ;
    }, []); // Make sure the whole tree has focus guards as our `MenuContent` may be
    // the last element in the DOM (beacuse of the `Portal`)
    $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
    const isPointerMovingToSubmenu = useCallback((event)=>{
        var _pointerGraceIntentRe, _pointerGraceIntentRe2;
        const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);
        return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);
    }, []);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$var$MenuContentProvider, {
        scope: __scopeMenu,
        searchRef: searchRef,
        onItemEnter: useCallback((event)=>{
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
        }, [
            isPointerMovingToSubmenu
        ]),
        onItemLeave: useCallback((event)=>{
            var _contentRef$current;
            if (isPointerMovingToSubmenu(event)) return;
            (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
            setCurrentItemId(null);
        }, [
            isPointerMovingToSubmenu
        ]),
        onTriggerLeave: useCallback((event)=>{
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
        }, [
            isPointerMovingToSubmenu
        ]),
        pointerGraceTimerRef: pointerGraceTimerRef,
        onPointerGraceIntentChange: useCallback((intent)=>{
            pointerGraceIntentRef.current = intent;
        }, [])
    }, /*#__PURE__*/ createElement(ScrollLockWrapper, scrollLockWrapperProps, /*#__PURE__*/ createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
        asChild: true,
        trapped: trapFocus,
        onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event)=>{
            var _contentRef$current2;
            // when opening, explicitly focus the content area only and leave
            // `onEntryFocus` in  control of focusing first item
            event.preventDefault();
            (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();
        }),
        onUnmountAutoFocus: onCloseAutoFocus
    }, /*#__PURE__*/ createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
        asChild: true,
        disableOutsidePointerEvents: disableOutsidePointerEvents,
        onEscapeKeyDown: onEscapeKeyDown,
        onPointerDownOutside: onPointerDownOutside,
        onFocusOutside: onFocusOutside,
        onInteractOutside: onInteractOutside,
        onDismiss: onDismiss
    }, /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends$2({
        asChild: true
    }, rovingFocusGroupScope, {
        dir: rootContext.dir,
        orientation: "vertical",
        loop: loop,
        currentTabStopId: currentItemId,
        onCurrentTabStopIdChange: setCurrentItemId,
        onEntryFocus: (event)=>{
            // only focus first item when using keyboard
            if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
        }
    }), /*#__PURE__*/ createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends$2({
        role: "menu",
        "aria-orientation": "vertical",
        "data-state": $6cc32821e9371a1c$var$getOpenState(context.open),
        dir: rootContext.dir
    }, popperScope, contentProps, {
        ref: composedRefs,
        style: {
            outline: 'none',
            ...contentProps.style
        },
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event)=>{
            // submenu key events bubble through portals. We only care about keys in this menu.
            const target = event.target;
            const isKeyDownInside = target.closest('[role="menu"]') === event.currentTarget;
            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
            const isCharacterKey = event.key.length === 1;
            if (isKeyDownInside) {
                // menus should not be navigated using tab key so we prevent it
                if (event.key === 'Tab') event.preventDefault();
                if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
            } // focus first/last item based on key pressed
            const content = contentRef.current;
            if (event.target !== content) return;
            if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key)) return;
            event.preventDefault();
            const items = getItems().filter((item)=>!item.disabled
            );
            const candidateNodes = items.map((item)=>item.ref.current
            );
            if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key)) candidateNodes.reverse();
            $6cc32821e9371a1c$var$focusFirst(candidateNodes);
        }),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event)=>{
            // clear search buffer when leaving the menu
            if (!event.currentTarget.contains(event.target)) {
                window.clearTimeout(timerRef.current);
                searchRef.current = '';
            }
        }),
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event)=>{
            const target = event.target;
            const pointerXHasChanged = lastPointerXRef.current !== event.clientX; // We don't use `event.movementX` for this check because Safari will
            // always return `0` on a pointer event.
            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';
                pointerDirRef.current = newDir;
                lastPointerXRef.current = event.clientX;
            }
        }))
    })))))));
});
const $6cc32821e9371a1c$export$dd37bec0e8a99143 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeMenu: __scopeMenu , ...labelProps } = props;
    return /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({}, labelProps, {
        ref: forwardedRef
    }));
});
/* -------------------------------------------------------------------------------------------------
 * MenuItem
 * -----------------------------------------------------------------------------------------------*/ const $6cc32821e9371a1c$var$ITEM_NAME = 'MenuItem';
const $6cc32821e9371a1c$var$ITEM_SELECT = 'menu.itemSelect';
const $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { disabled: disabled = false , onSelect: onSelect , ...itemProps } = props;
    const ref = useRef(null);
    const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
    const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const isPointerDownRef = useRef(false);
    const handleSelect = ()=>{
        const menuItem = ref.current;
        if (!disabled && menuItem) {
            const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {
                bubbles: true,
                cancelable: true
            });
            menuItem.addEventListener($6cc32821e9371a1c$var$ITEM_SELECT, (event)=>onSelect === null || onSelect === void 0 ? void 0 : onSelect(event)
            , {
                once: true
            });
            $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem, itemSelectEvent);
            if (itemSelectEvent.defaultPrevented) isPointerDownRef.current = false;
            else rootContext.onClose();
        }
    };
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$var$MenuItemImpl, _extends$2({}, itemProps, {
        ref: composedRefs,
        disabled: disabled,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),
        onPointerDown: (event)=>{
            var _props$onPointerDown;
            (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);
            isPointerDownRef.current = true;
        },
        onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event)=>{
            var _event$currentTarget;
            // Pointer down can move to a different menu item which should activate it on pointer up.
            // We dispatch a click for selection to allow composition with click based triggers and to
            // prevent Firefox from getting stuck in text selection mode when the menu closes.
            if (!isPointerDownRef.current) (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();
        }),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event)=>{
            const isTypingAhead = contentContext.searchRef.current !== '';
            if (disabled || isTypingAhead && event.key === ' ') return;
            if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {
                event.currentTarget.click();
                /**
         * We prevent default browser behaviour for selection keys as they should trigger
         * a selection only:
         * - prevents space from scrolling the page.
         * - if keydown causes focus to move, prevents keydown from firing on the new target.
         */ event.preventDefault();
            }
        })
    }));
});
/* ---------------------------------------------------------------------------------------------- */ const $6cc32821e9371a1c$var$MenuItemImpl = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeMenu: __scopeMenu , disabled: disabled = false , textValue: textValue , ...itemProps } = props;
    const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);
    const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const [isFocused, setIsFocused] = useState$1(false); // get the item's `.textContent` as default strategy for typeahead `textValue`
    const [textContent, setTextContent] = useState$1('');
    useEffect$1(()=>{
        const menuItem = ref.current;
        if (menuItem) {
            var _menuItem$textContent;
            setTextContent(((_menuItem$textContent = menuItem.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : '').trim());
        }
    }, [
        itemProps.children
    ]);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$var$Collection.ItemSlot, {
        scope: __scopeMenu,
        disabled: disabled,
        textValue: textValue !== null && textValue !== void 0 ? textValue : textContent
    }, /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends$2({
        asChild: true
    }, rovingFocusGroupScope, {
        focusable: !disabled
    }), /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
        role: "menuitem",
        "data-highlighted": isFocused ? '' : undefined,
        "aria-disabled": disabled || undefined,
        "data-disabled": disabled ? '' : undefined
    }, itemProps, {
        ref: composedRefs,
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event)=>{
            if (disabled) contentContext.onItemLeave(event);
            else {
                contentContext.onItemEnter(event);
                if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus();
                }
            }
        })),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse((event)=>contentContext.onItemLeave(event)
        )),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, ()=>setIsFocused(true)
        ),
        onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, ()=>setIsFocused(false)
        )
    }))));
});
/* -------------------------------------------------------------------------------------------------
 * MenuRadioGroup
 * -----------------------------------------------------------------------------------------------*/ const $6cc32821e9371a1c$var$RADIO_GROUP_NAME = 'MenuRadioGroup';
$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {
    value: undefined,
    onValueChange: ()=>{}
});
/* -------------------------------------------------------------------------------------------------
 * MenuItemIndicator
 * -----------------------------------------------------------------------------------------------*/ const $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = 'MenuItemIndicator';
$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {
    checked: false
});
/* -------------------------------------------------------------------------------------------------
 * MenuSub
 * -----------------------------------------------------------------------------------------------*/ const $6cc32821e9371a1c$var$SUB_NAME = 'MenuSub';
$6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);
/* -----------------------------------------------------------------------------------------------*/ function $6cc32821e9371a1c$var$getOpenState(open) {
    return open ? 'open' : 'closed';
}
function $6cc32821e9371a1c$var$focusFirst(candidates) {
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates){
        // if focus is already where we want to go, we don't want to keep going through the candidates
        if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
        candidate.focus();
        if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
    }
}
/**
 * Wraps an array around itself at a given start index
 * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`
 */ function $6cc32821e9371a1c$var$wrapArray(array, startIndex) {
    return array.map((_, index)=>array[(startIndex + index) % array.length]
    );
}
/**
 * This is the "meat" of the typeahead matching logic. It takes in all the values,
 * the search and the current match, and returns the next match (or `undefined`).
 *
 * We normalize the search because if a user has repeatedly pressed a character,
 * we want the exact same behavior as if we only had that one character
 * (ie. cycle through options starting with that character)
 *
 * We also reorder the values by wrapping the array around the current match.
 * This is so we always look forward from the current match, and picking the first
 * match will always be the correct one.
 *
 * Finally, if the normalized search is exactly one character, we exclude the
 * current match from the values because otherwise it would be the first to match always
 * and focus would never move. This is as opposed to the regular case, where we
 * don't want focus to move if the current match still matches.
 */ function $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {
    const isRepeated = search.length > 1 && Array.from(search).every((char)=>char === search[0]
    );
    const normalizedSearch = isRepeated ? search[0] : search;
    const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
    let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));
    const excludeCurrentMatch = normalizedSearch.length === 1;
    if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v)=>v !== currentMatch
    );
    const nextMatch = wrappedValues.find((value)=>value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
    );
    return nextMatch !== currentMatch ? nextMatch : undefined;
}
// Determine if a point is inside of a polygon.
// Based on https://github.com/substack/point-in-polygon
function $6cc32821e9371a1c$var$isPointInPolygon(point, polygon) {
    const { x: x , y: y  } = point;
    let inside = false;
    for(let i = 0, j = polygon.length - 1; i < polygon.length; j = i++){
        const xi = polygon[i].x;
        const yi = polygon[i].y;
        const xj = polygon[j].x;
        const yj = polygon[j].y; // prettier-ignore
        const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
    }
    return inside;
}
function $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {
    if (!area) return false;
    const cursorPos = {
        x: event.clientX,
        y: event.clientY
    };
    return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);
}
function $6cc32821e9371a1c$var$whenMouse(handler) {
    return (event)=>event.pointerType === 'mouse' ? handler(event) : undefined
    ;
}
const $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f;
const $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43;
const $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;
const $6cc32821e9371a1c$export$b04be29aa201d4f5 = $6cc32821e9371a1c$export$dd37bec0e8a99143;
const $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;

/* -------------------------------------------------------------------------------------------------
 * DropdownMenu
 * -----------------------------------------------------------------------------------------------*/ const $d08ef79370b62062$var$DROPDOWN_MENU_NAME = 'DropdownMenu';
const [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [
    $6cc32821e9371a1c$export$4027731b685e72eb
]);
const $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
const [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);
const $d08ef79370b62062$export$e44a253a59704894 = (props)=>{
    const { __scopeDropdownMenu: __scopeDropdownMenu , children: children , dir: dir , open: openProp , defaultOpen: defaultOpen , onOpenChange: onOpenChange , modal: modal = true  } = props;
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    const triggerRef = useRef(null);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: onOpenChange
    });
    return /*#__PURE__*/ createElement($d08ef79370b62062$var$DropdownMenuProvider, {
        scope: __scopeDropdownMenu,
        triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
        triggerRef: triggerRef,
        contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
        open: open,
        onOpenChange: setOpen,
        onOpenToggle: useCallback(()=>setOpen((prevOpen)=>!prevOpen
            )
        , [
            setOpen
        ]),
        modal: modal
    }, /*#__PURE__*/ createElement($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends$2({}, menuScope, {
        open: open,
        onOpenChange: setOpen,
        dir: dir,
        modal: modal
    }), children));
};
/* -------------------------------------------------------------------------------------------------
 * DropdownMenuTrigger
 * -----------------------------------------------------------------------------------------------*/ const $d08ef79370b62062$var$TRIGGER_NAME = 'DropdownMenuTrigger';
const $d08ef79370b62062$export$d2469213b3befba9 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDropdownMenu: __scopeDropdownMenu , disabled: disabled = false , ...triggerProps } = props;
    const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$TRIGGER_NAME, __scopeDropdownMenu);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$export$b688253958b8dfe7, _extends$2({
        asChild: true
    }, menuScope), /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open ? true : undefined,
        "aria-controls": context.open ? context.contentId : undefined,
        "data-state": context.open ? 'open' : 'closed',
        "data-disabled": disabled ? '' : undefined,
        disabled: disabled
    }, triggerProps, {
        ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event)=>{
            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)
            // but not when the control key is pressed (avoiding MacOS right click)
            if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onOpenToggle(); // prevent trigger focusing when opening
                // this allows the content to be given focus without competition
                if (!context.open) event.preventDefault();
            }
        }),
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event)=>{
            if (disabled) return;
            if ([
                'Enter',
                ' '
            ].includes(event.key)) context.onOpenToggle();
            if (event.key === 'ArrowDown') context.onOpenChange(true); // prevent keypresses from scrolling window
            if ([
                ' ',
                'ArrowDown'
            ].includes(event.key)) event.preventDefault();
        })
    })));
});
/* -------------------------------------------------------------------------------------------------
 * DropdownMenuContent
 * -----------------------------------------------------------------------------------------------*/ const $d08ef79370b62062$var$CONTENT_NAME = 'DropdownMenuContent';
const $d08ef79370b62062$export$6e76d93a37c01248 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDropdownMenu: __scopeDropdownMenu , ...contentProps } = props;
    const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = useRef(false);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends$2({
        id: context.contentId,
        "aria-labelledby": context.triggerId
    }, menuScope, contentProps, {
        ref: forwardedRef,
        onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event)=>{
            var _context$triggerRef$c;
            if (!hasInteractedOutsideRef.current) (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
            hasInteractedOutsideRef.current = false; // Always prevent auto focus because we either focus manually or want user agent focus
            event.preventDefault();
        }),
        onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event)=>{
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
            ...props.style,
            // re-namespace exposed content custom property
            ['--radix-dropdown-menu-content-transform-origin']: 'var(--radix-popper-transform-origin)'
        }
    }));
});
const $d08ef79370b62062$export$76e48c5b57f24495 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDropdownMenu: __scopeDropdownMenu , ...labelProps } = props;
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$export$b04be29aa201d4f5, _extends$2({}, menuScope, labelProps, {
        ref: forwardedRef
    }));
});
const $d08ef79370b62062$export$ed97964d1871885d = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeDropdownMenu: __scopeDropdownMenu , ...itemProps } = props;
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /*#__PURE__*/ createElement($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends$2({}, menuScope, itemProps, {
        ref: forwardedRef
    }));
});
/* -----------------------------------------------------------------------------------------------*/ const $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894;
const $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9;
const $d08ef79370b62062$export$b04be29aa201d4f5 = $d08ef79370b62062$export$76e48c5b57f24495;
const $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;

const DropdownMenu = $d08ef79370b62062$export$be92b6f5f03c0fe9;
const DropdownMenuTrigger = styled($d08ef79370b62062$export$41fb9f06171c75f4)``;
const DropdownMenuContent = styled($d08ef79370b62062$export$6e76d93a37c01248)`
  background-color: ${(props) => props.bgmenu ? props.bgmenu : props.theme.dropdown.bgMenu};
  padding: 0.4rem;
  min-width: ${(props) => props.minwidth};
  z-index: 10;
`;
const DropdownMenuItem = styled($d08ef79370b62062$export$6d08773d2e66f8f2)`
  margin-bottom: ${(props) => props.spacing};
`;
const DropdownMenuLabel = styled($d08ef79370b62062$export$b04be29aa201d4f5)`
  display: flex;
  align-items: flex-start;
  padding: 1.2rem;
  min-height: 4.8rem;
`;
const DropdownButton = styled(Button)`
  background-color: ${({ theme }) => theme.dropdown.bgItem};
  border: 0.1rem solid ${({ theme }) => theme.dropdown.bgItem};
  color: ${({ theme }) => theme.dropdown.text};

  :hover {
    background-color: ${({ theme }) => theme.dropdown.hoverItem};
    border: 0.1rem solid
      ${({ theme }) => theme.dropdown.hoverItem};
  }

  :focus {
    background-color: ${({ theme }) => theme.dropdown.focusItem};
    border: 0.1rem solid
      ${({ theme }) => theme.dropdown.focusItem};
  }

  :disabled {
    background-color: ${({ theme }) => theme.dropdown.bgItem};
    border: 0.1rem solid
      ${({ theme }) => theme.dropdown.bgItem};
    color: ${({ theme }) => theme.dropdown.textDisabled};
    cursor: not-allowed;
  }
  &.selected {
    background-color: ${({ theme }) => theme.secondary};
  }
`;
const DropdownTriggerLink = styled.button`
  background-color: transparent;
  border: none;
  border-bottom: 2px transparent solid;
  color: ${(props) => props.theme.dropdown.text};
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  letter-spacing: 1.5px;
  padding-bottom: 1rem;
  transition: 0.2s all;

  svg {
    margin-left: 0.3rem;
  }

  :hover {
    color: ${(props) => props.theme.navTabs.navLinkHoverColor};
    text-decoration: none;
  }

  &.selected {
    color: white;
    border-bottom: 2px ${(props) => props.theme.navTabs.navLinkColor} solid;
  }

  &.navTabs {
    padding-bottom: 1rem;
  }
`;
const DropdownLink$1 = styled(Link)`
  border-radius: 2px;
  color: ${(props) => props.theme.dropdown.text};
  cursor: pointer;
  display: flex;
  padding: 1rem;
  transition: 0.2s all;
  width: 100%;

  svg {
    margin-left: 0.3rem;
  }

  :hover {
    background-color: ${(props) => props.theme.navTabs.hoverNavLinkDropdownBg};
    border-color: ${(props) => props.theme.navTabs.hoverNavLinkDropdownBorder};
    text-decoration: none;
  }

  &.disabled {
    color: ${(props) => props.theme.dropdown.textDisabled};
  }
`;
const DropdownText = styled.div`
  border-radius: 2px;
  color: ${(props) => props.theme.dropdown.text};
  cursor: pointer;
  display: flex;
  padding: 1rem;
  transition: 0.2s all;
  width: 100%;

  svg {
    margin-left: 0.3rem;
  }

  :hover {
    background-color: ${(props) => props.theme.navTabs.hoverNavLinkDropdownBg};
    border-color: ${(props) => props.theme.navTabs.hoverNavLinkDropdownBorder};
    text-decoration: none;
  }

  &.disabled {
    color: ${(props) => props.theme.dropdown.textDisabled};
  }
`;

const Dropdown = ({
  defaultOpen,
  open,
  onOpenChange,
  modal,
  dir,
  trigger,
  side,
  sideOffset,
  align = "start",
  alignOffset,
  avoidCollisions,
  className,
  menuMinWidth = "fit-content",
  menuBg,
  children
}) => {
  return /* @__PURE__ */ jsxs(DropdownMenu, {
    open,
    onOpenChange,
    defaultOpen,
    modal,
    dir,
    children: [/* @__PURE__ */ jsx(DropdownMenuTrigger, {
      asChild: true,
      children: trigger
    }), /* @__PURE__ */ jsx(DropdownMenuContent, {
      side,
      sideOffset,
      align,
      alignOffset,
      avoidCollisions,
      className,
      bgmenu: menuBg,
      minwidth: menuMinWidth,
      children
    })]
  });
};

const CheckGateBox = styled.div`
  margin-top: 3.6rem;
`;

const CheckGate = ({
  id,
  fields,
  gateLabel,
  onUnchecked,
  rules,
  ...props
}) => {
  const [gatedOn, toggleGate] = useState$1(false);
  const onCheckedChanged = (checked) => {
    toggleGate(checked.valueOf());
    if (!checked)
      onUnchecked?.();
  };
  return /* @__PURE__ */ jsxs(FieldWrapper, {
    ...props,
    id,
    rules,
    children: [/* @__PURE__ */ jsx(Checkbox, {
      id,
      title: gateLabel,
      onCheckedChange: onCheckedChanged
    }), gatedOn && /* @__PURE__ */ jsx(CheckGateBox, {
      children: fields
    })]
  });
};

const FieldAlertWrapper = styled.div`
  padding: 1.6rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: ${border.radius};
  max-width: 600px;
  background: ${({
  theme
}) => theme.fieldAlert.bg};
  border: 1px solid ${({
  theme
}) => theme.fieldAlert.border};

  &.full {
    max-width: ${field.size.full};
  }

  &.warning {
    background: ${({
  theme
}) => theme.fieldAlert.warningBg};
    border: 1px solid ${({
  theme
}) => theme.fieldAlert.warningBorder};
    p {
      color: ${({
  theme
}) => theme.fieldAlert.warningText};
    }
    button {
      background-color: ${({
  theme
}) => theme.fieldAlert.warningButtonBg};
      border: 1px solid ${({
  theme
}) => theme.fieldAlert.warningButtonBorder};
      :hover {
        background-color: ${({
  theme
}) => theme.fieldAlert.warningButtonBg};
        border: 1px solid ${({
  theme
}) => theme.fieldAlert.warningButtonBorder};
      }
      :active {
        background-color: ${({
  theme
}) => theme.fieldAlert.warningButtonBg};
        border: 1px solid ${({
  theme
}) => theme.fieldAlert.warningButtonBorder};
      }
    }
  }
`;

const FieldAlert = forwardRef(({
  className,
  message,
  children
}, ref) => {
  return /* @__PURE__ */ jsxs(FieldAlertWrapper, {
    className,
    children: [/* @__PURE__ */ jsx(ParXs, {
      children: message
    }), children]
  });
});

const HighlightInputText = ({
  color,
  description,
  highlightColor,
  highlightInputId
}) => {
  const {
    watch
  } = useFormContext();
  const highlightValue = highlightInputId ? watch(highlightInputId) : "";
  return /* @__PURE__ */ jsxs(ParSm, {
    color,
    children: [description, " ", highlightValue && /* @__PURE__ */ jsx(Bold, {
      color: highlightColor,
      children: highlightValue
    })]
  });
};

const InputSelectBox = styled.div`
  display: flex;
  width: 100%;
  max-width: ${field.size.md};

  .select {
    max-width: 100%;
    padding: 0 0.8rem;
    border-radius: 0 ${field.borderRadius} ${field.borderRadius} 0;
    border-left: none;
    color: white;
    font-weight: ${font.weight.bold};
    background-color: ${({ theme }) => theme.button.secondary.bg};
    color: ${({ theme }) => theme.button.secondary.text};

    :hover {
      background-color: ${({ theme }) => theme.button.secondary.hoverBg};
    }

    :focus {
      background-color: ${({ theme }) => theme.button.secondary.focusBg};
    }

    :disabled {
      background-color: ${({ theme }) => theme.button.secondary.disabledBg};
      cursor: not-allowed;
    }
  }

  .select-box {
    max-width: 10rem;
    svg {
      right: 0.6rem;
      color: ${({ theme }) => theme.button.secondary.disabledText};
    }
    &.match-long {
      max-width: 16rem;
    }
    &.match-full {
      max-width: 18rem;
    }
  }

  .input {
    border-right: none;
    border-radius: ${field.borderRadius} 0 0 ${field.borderRadius};
  }

  &.long {
    max-width: ${field.size.lg};
  }

  &.full {
    max-width: ${field.size.full};
  }
`;

const InputSelect = ({
  selectId,
  id,
  options,
  disabled,
  long,
  full,
  error,
  warning,
  placeholder,
  selectPlaceholder,
  registerSelect = {},
  registerInput = {},
  defaultValue,
  selectDefault
}) => {
  const classes = classNames({
    long,
    full
  });
  const selectClasses = classNames({
    "match-long": long,
    "match-full": full
  });
  return /* @__PURE__ */ jsxs(InputSelectBox, {
    className: classes,
    children: [/* @__PURE__ */ jsx(Input, {
      id,
      disabled,
      className: `input ${classes}`,
      placeholder,
      error,
      warning,
      full: true,
      defaultValue,
      ...registerInput
    }), /* @__PURE__ */ jsx(Select, {
      id: selectId,
      options,
      defaultValue: selectDefault,
      disabled,
      className: "select",
      containerClassName: `select-box ${selectClasses}`,
      placeholder: selectPlaceholder,
      error,
      warning,
      ...registerSelect
    })]
  });
};

var main = {exports: {}};

(function (module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(commonjsGlobal, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	const pnglib = __webpack_require__(1);
	const hsl2rgb = __webpack_require__(2);

	// The random number is a js implementation of the Xorshift PRNG
	const randseed = new Array(4); // Xorshift: [x, y, z, w] 32 bit values

	function seedrand(seed) {
	  for (let i = 0; i < randseed.length; i++) {
	    randseed[i] = 0;
	  }
	  for (let i = 0; i < seed.length; i++) {
	    randseed[i % 4] = (randseed[i % 4] << 5) - randseed[i % 4] + seed.charCodeAt(i);
	  }
	}

	function rand() {
	  // based on Java's String.hashCode(), expanded to 4 32bit values
	  const t = randseed[0] ^ (randseed[0] << 11);

	  randseed[0] = randseed[1];
	  randseed[1] = randseed[2];
	  randseed[2] = randseed[3];
	  randseed[3] = randseed[3] ^ (randseed[3] >> 19) ^ t ^ (t >> 8);

	  return (randseed[3] >>> 0) / (1 << 31 >>> 0);
	}

	function createColor() {
	  //saturation is the whole color spectrum
	  const h = Math.floor(rand() * 360);
	  //saturation goes from 40 to 100, it avoids greyish colors
	  const s = rand() * 60 + 40;
	  //lightness can be anything from 0 to 100, but probabilities are a bell curve around 50%
	  const l = (rand() + rand() + rand() + rand()) * 25 ;

	  return [h / 360, s / 100, l / 100];
	}

	function createImageData(size) {
	  const width = size; // Only support square icons for now
	  const height = size;

	  const dataWidth = Math.ceil(width / 2);
	  const mirrorWidth = width - dataWidth;

	  const data = [];
	  for (let y = 0; y < height; y++) {
	    let row = [];
	    for (let x = 0; x < dataWidth; x++) {
	      // this makes foreground and background color to have a 43% (1/2.3) probability
	      // spot color has 13% chance
	      row[x] = Math.floor(rand() * 2.3);
	    }
	    const r = row.slice(0, mirrorWidth).reverse();
	    row = row.concat(r);

	    for (let i = 0; i < row.length; i++) {
	      data.push(row[i]);
	    }
	  }

	  return data;
	}

	// Modifies the passed PNG to fill in a specified rectangle
	function fillRect(png, x, y, w, h, color) {
	  for(let i = 0; i < w; i++) {
	    for (let j = 0; j < h; j++) {
	      png.buffer[png.index(x + i, y + j)] = color;
	    }
	  }
	}

	function buildOpts(opts) {
	  if (!opts.seed) {
	    throw new Error('No seed provided');
	  }

	  seedrand(opts.seed);

	  return Object.assign({
	    size: 8,
	    scale: 16,
	    color: createColor(),
	    bgcolor: createColor(),
	    spotcolor: createColor(),
	  }, opts)
	}

	function makeBlockie(address) {
	  const opts = buildOpts({ seed: address.toLowerCase() });

	  const imageData = createImageData(opts.size);
	  const width = Math.sqrt(imageData.length);

	  const p = new pnglib(opts.size * opts.scale, opts.size * opts.scale, 3);
	  p.color(...hsl2rgb(...opts.bgcolor));
	  const color = p.color(...hsl2rgb(...opts.color));
	  const spotcolor = p.color(...hsl2rgb(...opts.spotcolor));

	  for (let i = 0; i < imageData.length; i++) {
	    const row = Math.floor(i / width);
	    const col = i % width;
	    // if data is 0, leave the background
	    if (imageData[i]) {
	      // if data is 2, choose spot color, if 1 choose foreground
	      const pngColor = imageData[i] == 1 ? color : spotcolor;
	      fillRect(p, col * opts.scale, row * opts.scale, opts.scale, opts.scale, pngColor);
	    }
	  }
	  return `data:image/png;base64,${p.getBase64()}`;
	}

	module.exports = makeBlockie;


/***/ },
/* 1 */
/***/ function(module, exports) {

	/**
	 * A handy class to calculate color values.
	 *
	 * @version 1.0
	 * @author Robert Eisele <robert@xarg.org>
	 * @copyright Copyright (c) 2010, Robert Eisele
	 * @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
	 * @license http://www.opensource.org/licenses/bsd-license.php BSD License
	 *
	 */

	// Modified by George Chan <gchan@21cn.com>

	// Further modified by Will O'B <@wbobeirne> to make it
	// UglifyJS and "use strict"; friendly

	module.exports = function(width,height,depth) {


	    // helper functions for that ctx
	    function write(buffer, offs) {
	        for (var i = 2; i < arguments.length; i++) {
	            for (var j = 0; j < arguments[i].length; j++) {
	                buffer[offs++] = arguments[i].charAt(j);
	            }
	        }
	    }

	    function byte2(w) {
	        return String.fromCharCode((w >> 8) & 255, w & 255);
	    }

	    function byte4(w) {
	        return String.fromCharCode((w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w & 255);
	    }

	    function byte2lsb(w) {
	        return String.fromCharCode(w & 255, (w >> 8) & 255);
	    }

	    this.width   = width;
	    this.height  = height;
	    this.depth   = depth;

	    // pixel data and row filter identifier size
	    this.pix_size = height * (width + 1);

	    // deflate header, pix_size, block headers, adler32 checksum
	    this.data_size = 2 + this.pix_size + 5 * Math.floor((0xfffe + this.pix_size) / 0xffff) + 4;

	    // offsets and sizes of Png chunks
	    this.ihdr_offs = 0; // IHDR offset and size
	    this.ihdr_size = 4 + 4 + 13 + 4;
	    this.plte_offs = this.ihdr_offs + this.ihdr_size; // PLTE offset and size
	    this.plte_size = 4 + 4 + 3 * depth + 4;
	    this.trns_offs = this.plte_offs + this.plte_size; // tRNS offset and size
	    this.trns_size = 4 + 4 + depth + 4;
	    this.idat_offs = this.trns_offs + this.trns_size; // IDAT offset and size
	    this.idat_size = 4 + 4 + this.data_size + 4;
	    this.iend_offs = this.idat_offs + this.idat_size; // IEND offset and size
	    this.iend_size = 4 + 4 + 4;
	    this.buffer_size  = this.iend_offs + this.iend_size; // total PNG size

	    this.buffer  = new Array();
	    this.palette = new Object();
	    this.pindex  = 0;

	    var _crc32 = new Array();

	    // initialize buffer with zero bytes
	    for (var i = 0; i < this.buffer_size; i++) {
	        this.buffer[i] = "\x00";
	    }

	    // initialize non-zero elements
	    write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), 'IHDR', byte4(width), byte4(height), "\x08\x03");
	    write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), 'PLTE');
	    write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), 'tRNS');
	    write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), 'IDAT');
	    write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), 'IEND');

	    // initialize deflate header
	    var header = ((8 + (7 << 4)) << 8) | (3 << 6);
	    header+= 31 - (header % 31);

	    write(this.buffer, this.idat_offs + 8, byte2(header));

	    // initialize deflate block headers
	    for (var i = 0; (i << 16) - 1 < this.pix_size; i++) {
	        var size, bits;
	        if (i + 0xffff < this.pix_size) {
	            size = 0xffff;
	            bits = "\x00";
	        } else {
	            size = this.pix_size - (i << 16) - i;
	            bits = "\x01";
	        }
	        write(this.buffer, this.idat_offs + 8 + 2 + (i << 16) + (i << 2), bits, byte2lsb(size), byte2lsb(~size));
	    }

	    /* Create crc32 lookup table */
	    for (var i = 0; i < 256; i++) {
	        var c = i;
	        for (var j = 0; j < 8; j++) {
	            if (c & 1) {
	                c = -306674912 ^ ((c >> 1) & 0x7fffffff);
	            } else {
	                c = (c >> 1) & 0x7fffffff;
	            }
	        }
	        _crc32[i] = c;
	    }

	    // compute the index into a png for a given pixel
	    this.index = function(x,y) {
	        var i = y * (this.width + 1) + x + 1;
	        var j = this.idat_offs + 8 + 2 + 5 * Math.floor((i / 0xffff) + 1) + i;
	        return j;
	    };

	    // convert a color and build up the palette
	    this.color = function(red, green, blue, alpha) {

	        alpha = alpha >= 0 ? alpha : 255;
	        var color = (((((alpha << 8) | red) << 8) | green) << 8) | blue;

	        if (typeof this.palette[color] == "undefined") {
	            if (this.pindex == this.depth) return "\x00";

	            var ndx = this.plte_offs + 8 + 3 * this.pindex;

	            this.buffer[ndx + 0] = String.fromCharCode(red);
	            this.buffer[ndx + 1] = String.fromCharCode(green);
	            this.buffer[ndx + 2] = String.fromCharCode(blue);
	            this.buffer[this.trns_offs+8+this.pindex] = String.fromCharCode(alpha);

	            this.palette[color] = String.fromCharCode(this.pindex++);
	        }
	        return this.palette[color];
	    };

	    // output a PNG string, Base64 encoded
	    this.getBase64 = function() {

	        var s = this.getDump();

	        var ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	        var c1, c2, c3, e1, e2, e3, e4;
	        var l = s.length;
	        var i = 0;
	        var r = "";

	        do {
	            c1 = s.charCodeAt(i);
	            e1 = c1 >> 2;
	            c2 = s.charCodeAt(i+1);
	            e2 = ((c1 & 3) << 4) | (c2 >> 4);
	            c3 = s.charCodeAt(i+2);
	            if (l < i+2) { e3 = 64; } else { e3 = ((c2 & 0xf) << 2) | (c3 >> 6); }
	            if (l < i+3) { e4 = 64; } else { e4 = c3 & 0x3f; }
	            r+= ch.charAt(e1) + ch.charAt(e2) + ch.charAt(e3) + ch.charAt(e4);
	        } while ((i+= 3) < l);
	        return r;
	    };

	    // output a PNG string
	    this.getDump = function() {
	        // compute adler32 of output pixels + row filter bytes
	        var BASE = 65521; /* largest prime smaller than 65536 */
	        var NMAX = 5552; /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
	        var s1 = 1;
	        var s2 = 0;
	        var n = NMAX;

	        for (var y = 0; y < this.height; y++) {
	            for (var x = -1; x < this.width; x++) {
	                s1+= this.buffer[this.index(x, y)].charCodeAt(0);
	                s2+= s1;
	                if ((n-= 1) == 0) {
	                    s1%= BASE;
	                    s2%= BASE;
	                    n = NMAX;
	                }
	            }
	        }
	        s1%= BASE;
	        s2%= BASE;
	        write(this.buffer, this.idat_offs + this.idat_size - 8, byte4((s2 << 16) | s1));

	        // compute crc32 of the PNG chunks
	        function crc32(png, offs, size) {
	            var crc = -1;
	            for (var i = 4; i < size-4; i += 1) {
	                crc = _crc32[(crc ^ png[offs+i].charCodeAt(0)) & 0xff] ^ ((crc >> 8) & 0x00ffffff);
	            }
	            write(png, offs+size-4, byte4(crc ^ -1));
	        }

	        crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
	        crc32(this.buffer, this.plte_offs, this.plte_size);
	        crc32(this.buffer, this.trns_offs, this.trns_size);
	        crc32(this.buffer, this.idat_offs, this.idat_size);
	        crc32(this.buffer, this.iend_offs, this.iend_size);

	        // convert PNG to string
	        return "\x89PNG\r\n\x1a\n" + this.buffer.join('');
	    };
	};


/***/ },
/* 2 */
/***/ function(module, exports) {

	// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
	/**
	 * Converts an HSL color value to RGB. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes h, s, and l are contained in the set [0, 1] and
	 * returns r, g, and b in the set [0, 255].
	 *
	 * @param   {number}  h       The hue
	 * @param   {number}  s       The saturation
	 * @param   {number}  l       The lightness
	 * @return  {Array}           The RGB representation
	 */

	 function hue2rgb(p, q, t) {
	   if(t < 0) t += 1;
	   if(t > 1) t -= 1;
	   if(t < 1/6) return p + (q - p) * 6 * t;
	   if(t < 1/2) return q;
	   if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	   return p;
	 }

	function hsl2rgb(h, s, l){
	  let r, g, b;

	  if (s == 0) {
	    r = g = b = l; // achromatic
	  } else {
	    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	    const p = 2 * l - q;
	    r = hue2rgb(p, q, h + 1/3);
	    g = hue2rgb(p, q, h);
	    b = hue2rgb(p, q, h - 1/3);
	  }

	  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), 255];
	}

	module.exports = hsl2rgb;


/***/ }
/******/ ])
});
}(main));

var makeBlockie = main.exports;

const ProfileAvatar = ({
  address,
  image,
  ...props
}) => {
  const blockie = useMemo(() => {
    if (address) {
      return /* @__PURE__ */ jsx(BlockieImg, {
        src: makeBlockie(address),
        alt: "user avatar"
      });
    }
    return "?";
  }, [address]);
  return /* @__PURE__ */ jsx(Avatar, {
    ...props,
    src: image,
    fallback: blockie
  });
};
const BlockieImg = styled.img`
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: inherit;
`;

const WrappedSelect = ({
  id,
  rules,
  ...props
}) => {
  const {
    register
  } = useFormContext();
  return /* @__PURE__ */ jsx(FieldWrapper, {
    ...props,
    id,
    rules,
    children: /* @__PURE__ */ jsx(Select, {
      ...register(id, rules),
      ...props,
      id
    })
  });
};

const ShamanPermission = (props) => {
  const {
    id = "shamanPermission"
  } = props;
  const options = SHAMAN_PERMISSIONS.map((permission) => ({
    name: permission.displayName,
    value: permission.id
  }));
  return /* @__PURE__ */ jsx(WrappedSelect, {
    ...props,
    id,
    options
  });
};

const Toast = (props) => {
  const {
    title,
    description,
    type,
    defaultOpen,
    open,
    onOpenChange,
    duration,
    label,
    hotkey,
    toastType = "default",
    ariaLabelClose = "Close",
    toastLinks
  } = props;
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsxs(ToastRoot, {
      type,
      open,
      duration,
      onOpenChange,
      defaultOpen,
      className: toastType,
      children: [/* @__PURE__ */ jsxs(ToastHeaderContainer, {
        children: [getEnumIcons(toastType), /* @__PURE__ */ jsxs(ToastCopyContainer, {
          children: [/* @__PURE__ */ jsx(ToastTitle, {
            asChild: true,
            children: /* @__PURE__ */ jsx(ParSm, {
              children: title
            })
          }), description && /* @__PURE__ */ jsx(ToastDescription, {
            asChild: true,
            children: /* @__PURE__ */ jsx(ParSm, {
              children: description
            })
          })]
        }), /* @__PURE__ */ jsx(ToastClose, {
          asChild: true,
          "aria-label": ariaLabelClose,
          children: /* @__PURE__ */ jsx(CloseIcon$1, {
            children: /* @__PURE__ */ jsx(RiCloseFill, {
              "aria-hidden": true
            })
          })
        })]
      }), toastLinks && /* @__PURE__ */ jsx(ToastLinks, {
        ...toastLinks
      })]
    }), /* @__PURE__ */ jsx(ToastViewport, {
      label,
      hotkey
    })]
  });
};
const ToastLinks = ({
  leftLink,
  rightLink,
  actionAltText
}) => {
  return /* @__PURE__ */ jsx(ToastAction, {
    asChild: true,
    altText: actionAltText || "Related Link(s)",
    children: /* @__PURE__ */ jsxs("div", {
      children: [leftLink && /* @__PURE__ */ jsx(Link, {
        href: leftLink.path,
        children: leftLink.text
      }), rightLink && /* @__PURE__ */ jsx(Link, {
        href: rightLink.path,
        children: rightLink.text
      })]
    })
  });
};
const EnumIconsObject = {
  default: /* @__PURE__ */ jsx(RiCheckboxCircleFill, {}),
  success: /* @__PURE__ */ jsx(RiCheckboxCircleFill, {}),
  warning: /* @__PURE__ */ jsx(RiErrorWarningFill, {}),
  error: /* @__PURE__ */ jsx(RiCloseCircleFill, {})
};
function getEnumIcons(toastType) {
  return /* @__PURE__ */ jsx(ToastIcon, {
    iconType: toastType,
    children: EnumIconsObject[toastType]
  });
}

const WrappedInputSelect = ({
  id,
  selectId,
  rules,
  ...props
}) => {
  const {
    register
  } = useFormContext();
  return /* @__PURE__ */ jsx(FieldWrapper, {
    ...props,
    id,
    rules,
    children: /* @__PURE__ */ jsx(InputSelect, {
      ...props,
      registerInput: register(id, rules),
      registerSelect: register(selectId),
      id,
      selectId
    })
  });
};

const defaultOptions = [{
  name: "Days",
  value: "days"
}, {
  name: "Hours",
  value: "hours"
}, {
  name: "Minutes",
  value: "minutes"
}, {
  name: "Seconds",
  value: "seconds"
}];
const TimePicker = ({
  id,
  options = defaultOptions,
  selectId,
  rules,
  ...props
}) => {
  const {
    setValue,
    watch
  } = useFormContext();
  const unitId = useMemo(() => selectId || `${id}Units`, [selectId, id]);
  const [amt, units] = watch([id, unitId]);
  useEffect$1(() => {
    if (isNumberString(amt) && units in conversionFns) {
      setValue(`${id}InSeconds`, toSeconds(amt, units));
    }
    if (amt === "") {
      setValue(`${id}InSeconds`, 0);
    }
  }, [amt, units, id, setValue]);
  return /* @__PURE__ */ jsx(WrappedInputSelect, {
    id,
    selectId: unitId,
    options,
    rules: {
      ...rules,
      validate: {
        isNumber: (value) => value === "" || isNumberString(value) ? true : "Must be a number",
        noZero: (value) => value !== "0" ? true : "Time units cannot be zero"
      }
    },
    ...props
  });
};

const handleFieldLabel = (fieldLabel, switchOn) => {
  if (typeof fieldLabel === "string") {
    return fieldLabel;
  }
  if (switchOn) {
    return fieldLabel.on;
  }
  return fieldLabel.off;
};
const WrappedSwitch = (props) => {
  const {
    id,
    helperText,
    info,
    label,
    error,
    success,
    warning,
    switches,
    disabled,
    rules
  } = props;
  const {
    control,
    watch
  } = useFormContext();
  return /* @__PURE__ */ jsx(FieldWrapper, {
    id,
    helperText,
    info,
    label,
    error,
    success,
    warning,
    children: switches.map((switchProps) => {
      const switchValue = watch(switchProps.id);
      return /* @__PURE__ */ jsx(Controller, {
        name: switchProps.id,
        rules,
        control,
        defaultValue: switchProps.defaultChecked || false,
        render: ({
          field
        }) => {
          return /* @__PURE__ */ jsx(Switch, {
            ...field,
            ...switchProps,
            switchOn: field.value,
            onCheckedChange: field.onChange,
            fieldLabel: handleFieldLabel(switchProps.fieldLabel, switchValue),
            disabled,
            ref: field.ref
          });
        }
      }, switchProps.id);
    })
  });
};

const WrappedTextArea = ({
  rules,
  ...props
}) => {
  const {
    register
  } = useFormContext();
  return /* @__PURE__ */ jsx(FieldWrapper, {
    ...props,
    rules,
    children: /* @__PURE__ */ jsx(TextArea, {
      ...register(props.id, rules),
      ...props
    })
  });
};

/* -------------------------------------------------------------------------------------------------
 * Radio
 * -----------------------------------------------------------------------------------------------*/ const $ce77a8961b41be9e$var$RADIO_NAME = 'Radio';
const [$ce77a8961b41be9e$var$createRadioContext, $ce77a8961b41be9e$export$67d2296460f1b002] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($ce77a8961b41be9e$var$RADIO_NAME);
const [$ce77a8961b41be9e$var$RadioProvider, $ce77a8961b41be9e$var$useRadioContext] = $ce77a8961b41be9e$var$createRadioContext($ce77a8961b41be9e$var$RADIO_NAME);
const $ce77a8961b41be9e$export$d7b12c4107be0d61 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeRadio: __scopeRadio , 'aria-labelledby': ariaLabelledby , name: name , checked: checked = false , required: required , disabled: disabled , value: value = 'on' , onCheck: onCheck , ...radioProps } = props;
    const [button, setButton] = useState$1(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, (node)=>setButton(node)
    );
    const labelId = $b73a6c6685e72184$export$feddbbf47baabdb9(button);
    const labelledBy = ariaLabelledby || labelId;
    const hasConsumerStoppedPropagationRef = useRef(false); // We set this to true by default so that events bubble to forms without JS (SSR)
    const isFormControl = button ? Boolean(button.closest('form')) : true;
    return /*#__PURE__*/ createElement($ce77a8961b41be9e$var$RadioProvider, {
        scope: __scopeRadio,
        checked: checked,
        disabled: disabled
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends$2({
        type: "button",
        role: "radio",
        "aria-checked": checked,
        "aria-labelledby": labelledBy,
        "data-state": $ce77a8961b41be9e$var$getState(checked),
        "data-disabled": disabled ? '' : undefined,
        disabled: disabled,
        value: value
    }, radioProps, {
        ref: composedRefs,
        onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, (event)=>{
            // radios cannot be unchecked so we only communicate a checked state
            if (!checked) onCheck === null || onCheck === void 0 || onCheck();
            if (isFormControl) {
                hasConsumerStoppedPropagationRef.current = event.isPropagationStopped(); // if radio is in a form, stop propagation from the button so that we only propagate
                // one click event (from the input). We propagate changes from an input so that native
                // form validation works and form events reflect radio updates.
                if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
        })
    })), isFormControl && /*#__PURE__*/ createElement($ce77a8961b41be9e$var$BubbleInput, {
        control: button,
        bubbles: !hasConsumerStoppedPropagationRef.current,
        name: name,
        value: value,
        checked: checked,
        required: required,
        disabled: disabled // We transform because the input is absolutely positioned but we have
        ,
        style: {
            transform: 'translateX(-100%)'
        }
    }));
});
/* -------------------------------------------------------------------------------------------------
 * RadioIndicator
 * -----------------------------------------------------------------------------------------------*/ const $ce77a8961b41be9e$var$INDICATOR_NAME = 'RadioIndicator';
const $ce77a8961b41be9e$export$d35a9ffa9a04f9e7 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeRadio: __scopeRadio , forceMount: forceMount , ...indicatorProps } = props;
    const context = $ce77a8961b41be9e$var$useRadioContext($ce77a8961b41be9e$var$INDICATOR_NAME, __scopeRadio);
    return /*#__PURE__*/ createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.checked
    }, /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends$2({
        "data-state": $ce77a8961b41be9e$var$getState(context.checked),
        "data-disabled": context.disabled ? '' : undefined
    }, indicatorProps, {
        ref: forwardedRef
    })));
});
/* ---------------------------------------------------------------------------------------------- */ const $ce77a8961b41be9e$var$BubbleInput = (props)=>{
    const { control: control , checked: checked , bubbles: bubbles = true , ...inputProps } = props;
    const ref = useRef(null);
    const prevChecked = $010c2913dbd2fe3d$export$5cae361ad82dce8b(checked);
    const controlSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(control); // Bubble checked change to parents (e.g form change event)
    useEffect$1(()=>{
        const input = ref.current;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked');
        const setChecked = descriptor.set;
        if (prevChecked !== checked && setChecked) {
            const event = new Event('click', {
                bubbles: bubbles
            });
            setChecked.call(input, checked);
            input.dispatchEvent(event);
        }
    }, [
        prevChecked,
        checked,
        bubbles
    ]);
    return /*#__PURE__*/ createElement("input", _extends$2({
        type: "radio",
        "aria-hidden": true,
        defaultChecked: checked
    }, inputProps, {
        tabIndex: -1,
        ref: ref,
        style: {
            ...props.style,
            ...controlSize,
            position: 'absolute',
            pointerEvents: 'none',
            opacity: 0,
            margin: 0
        }
    }));
};
function $ce77a8961b41be9e$var$getState(checked) {
    return checked ? 'checked' : 'unchecked';
}


const $f99a8c78507165f7$var$ARROW_KEYS = [
    'ArrowUp',
    'ArrowDown',
    'ArrowLeft',
    'ArrowRight'
];
/* -------------------------------------------------------------------------------------------------
 * RadioGroup
 * -----------------------------------------------------------------------------------------------*/ const $f99a8c78507165f7$var$RADIO_GROUP_NAME = 'RadioGroup';
const [$f99a8c78507165f7$var$createRadioGroupContet, $f99a8c78507165f7$export$c547093f11b76da2] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($f99a8c78507165f7$var$RADIO_GROUP_NAME, [
    $d7bdfb9eb0fdf311$export$c7109489551a4f4,
    $ce77a8961b41be9e$export$67d2296460f1b002
]);
const $f99a8c78507165f7$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
const $f99a8c78507165f7$var$useRadioScope = $ce77a8961b41be9e$export$67d2296460f1b002();
const [$f99a8c78507165f7$var$RadioGroupProvider, $f99a8c78507165f7$var$useRadioGroupContext] = $f99a8c78507165f7$var$createRadioGroupContet($f99a8c78507165f7$var$RADIO_GROUP_NAME);
const $f99a8c78507165f7$export$a98f0dcb43a68a25 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeRadioGroup: __scopeRadioGroup , name: name , 'aria-labelledby': ariaLabelledby , defaultValue: defaultValue , value: valueProp , required: required = false , orientation: orientation , dir: dir , loop: loop = true , onValueChange: onValueChange , ...groupProps } = props;
    const labelId = $b73a6c6685e72184$export$feddbbf47baabdb9();
    const labelledBy = ariaLabelledby || labelId;
    const rovingFocusGroupScope = $f99a8c78507165f7$var$useRovingFocusGroupScope(__scopeRadioGroup);
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c3({
        prop: valueProp,
        defaultProp: defaultValue,
        onChange: onValueChange
    });
    return /*#__PURE__*/ createElement($f99a8c78507165f7$var$RadioGroupProvider, {
        scope: __scopeRadioGroup,
        name: name,
        required: required,
        value: value,
        onValueChange: setValue
    }, /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends$2({
        asChild: true
    }, rovingFocusGroupScope, {
        orientation: orientation,
        dir: direction,
        loop: loop
    }), /*#__PURE__*/ createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends$2({
        role: "radiogroup",
        "aria-required": required,
        "aria-orientation": orientation,
        "aria-labelledby": labelledBy,
        dir: direction
    }, groupProps, {
        ref: forwardedRef
    }))));
});
/* -------------------------------------------------------------------------------------------------
 * RadioGroupItem
 * -----------------------------------------------------------------------------------------------*/ const $f99a8c78507165f7$var$ITEM_NAME = 'RadioGroupItem';
const $f99a8c78507165f7$export$9f866c100ef519e4 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeRadioGroup: __scopeRadioGroup , disabled: disabled , ...itemProps } = props;
    const context = $f99a8c78507165f7$var$useRadioGroupContext($f99a8c78507165f7$var$ITEM_NAME, __scopeRadioGroup);
    const rovingFocusGroupScope = $f99a8c78507165f7$var$useRovingFocusGroupScope(__scopeRadioGroup);
    const radioScope = $f99a8c78507165f7$var$useRadioScope(__scopeRadioGroup);
    const ref = useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = useRef(false);
    useEffect$1(()=>{
        const handleKeyDown = (event)=>{
            if ($f99a8c78507165f7$var$ARROW_KEYS.includes(event.key)) isArrowKeyPressedRef.current = true;
        };
        const handleKeyUp = ()=>isArrowKeyPressedRef.current = false
        ;
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        return ()=>{
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
        };
    }, []);
    return /*#__PURE__*/ createElement($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends$2({
        asChild: true
    }, rovingFocusGroupScope, {
        focusable: !disabled,
        active: checked
    }), /*#__PURE__*/ createElement($ce77a8961b41be9e$export$d7b12c4107be0d61, _extends$2({
        disabled: disabled,
        required: context.required,
        checked: checked
    }, radioScope, itemProps, {
        name: context.name,
        ref: composedRefs,
        onCheck: ()=>context.onValueChange(itemProps.value)
        ,
        onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10((event)=>{
            // According to WAI ARIA, radio groups don't activate items on enter keypress
            if (event.key === 'Enter') event.preventDefault();
        }),
        onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(itemProps.onFocus, ()=>{
            var _ref$current;
            /**
       * Our `RovingFocusGroup` will focus the radio when navigating with arrow keys
       * and we need to "check" it in that case. We click it to "check" it (instead
       * of updating `context.value`) so that the radio change event fires.
       */ if (isArrowKeyPressedRef.current) (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.click();
        })
    })));
});
const $f99a8c78507165f7$export$5fb54c671a65c88 = /*#__PURE__*/ forwardRef((props, forwardedRef)=>{
    const { __scopeRadioGroup: __scopeRadioGroup , ...indicatorProps } = props;
    const radioScope = $f99a8c78507165f7$var$useRadioScope(__scopeRadioGroup);
    return /*#__PURE__*/ createElement($ce77a8961b41be9e$export$d35a9ffa9a04f9e7, _extends$2({}, radioScope, indicatorProps, {
        ref: forwardedRef
    }));
});
/* ---------------------------------------------------------------------------------------------- */ const $f99a8c78507165f7$export$be92b6f5f03c0fe9 = $f99a8c78507165f7$export$a98f0dcb43a68a25;
const $f99a8c78507165f7$export$6d08773d2e66f8f2 = $f99a8c78507165f7$export$9f866c100ef519e4;
const $f99a8c78507165f7$export$adb584737d712b70 = $f99a8c78507165f7$export$5fb54c671a65c88;

const Container = styled.div`
  align-items: center;
  display: flex;
  padding-bottom: 1.4rem;
`;
const RadioGroup = $f99a8c78507165f7$export$be92b6f5f03c0fe9;
const RadioItem = styled($f99a8c78507165f7$export$6d08773d2e66f8f2)`
  all: unset;
  background-color: ${({ theme }) => theme.radio.item.bg};
  border: 2px solid ${({ theme }) => theme.radio.item.border};
  border-radius: 100%;
  cursor: pointer;
  height: 2rem;
  position: relative;
  width: 2rem;

  :hover {
    background-color: ${({ theme }) => theme.radio.item.hoverBg};
    border: 2px solid
      ${({ theme }) => theme.radio.item.hoverBorder};
  }

  :focus {
    background-color: ${({ theme }) => theme.radio.item.focusBg};
    border: 2px solid
      ${({ theme }) => theme.radio.item.focusBorder};
    outline: none;
  }

  :disabled {
    background-color: ${({ theme }) => theme.radio.item.disabledBg};
    border: 2px solid
      ${({ theme }) => theme.radio.item.disabledBorder};
    cursor: not-allowed;
  }

  &[data-state='checked'] {
    background-color: ${({ theme }) => theme.radio.item.activeBg};
    border: 2px solid
      ${({ theme }) => theme.radio.item.activeBg};

    :hover {
      background-color: ${({ theme }) => theme.radio.item.activeHoverBg};
      border: 2px solid
        ${({ theme }) => theme.radio.item.activeHoverBorder};
    }

    :focus {
      background-color: ${({ theme }) => theme.radio.item.activeFocusBg};
      border: 2px solid
        ${({ theme }) => theme.radio.item.activeFocusBorder};
      outline: none;
    }

    :disabled {
      background-color: ${({ theme }) => theme.radio.item.activeDisabledBg};
      border: 2px solid
        ${({ theme }) => theme.radio.item.activeDisabledBorder};
      cursor: not-allowed;
    }
  }
`;
const RadioIndicator = styled($f99a8c78507165f7$export$adb584737d712b70)`
  align-items: center;
  display: flex;
  height: 100%;
  justify-content: center;
  position: relative;
  width: 100%;

  &::after {
    background-color: ${({ theme }) => theme.radio.indicator.bg};
    border-radius: 50%;
    content: '';
    display: block;
    height: 1rem;
    width: 1rem;
  }

  &[data-disabled] {
    &::after {
      background-color: ${({ theme }) => theme.radio.indicator.disabledBg};
    }
  }
`;
const LabelContainer = styled.label`
  align-items: center;
  display: flex;
  margin-left: 1.2rem;

  label {
    margin-right: 0.1rem;
  }

  svg {
    transform: translateY(0.1rem);
  }
`;

const Radio = React__default.forwardRef((props, ref) => {
  const {
    className,
    radios,
    defaultValue
  } = props;
  return /* @__PURE__ */ jsx(RadioGroup, {
    ...props,
    defaultValue,
    className,
    children: radios.map((radio) => /* @__PURE__ */ jsxs(Container, {
      children: [/* @__PURE__ */ jsx(RadioItem, {
        ...radio,
        children: /* @__PURE__ */ jsx(RadioIndicator, {
          ref
        })
      }), /* @__PURE__ */ jsx(LabelContainer, {
        children: /* @__PURE__ */ jsx(Label$1, {
          id: radio.id,
          children: radio.label
        })
      })]
    }, radio.id))
  });
});

const WrappedRadio = (props) => {
  const {
    id,
    helperText,
    info,
    label,
    error,
    success,
    warning,
    radioGroup,
    disabled,
    rules
  } = props;
  const disableAll = disabled;
  const radios = useMemo(() => {
    return disableAll ? radioGroup?.radios.map((radio) => ({
      ...radio,
      disabled: true
    })) : radioGroup.radios;
  }, [radioGroup, disableAll]);
  return /* @__PURE__ */ jsx(FieldWrapper, {
    id,
    helperText,
    info,
    label,
    error,
    success,
    warning,
    children: /* @__PURE__ */ jsx(Controller, {
      name: radioGroup.name || id,
      defaultValue: radioGroup.defaultValue,
      rules,
      render: ({
        field
      }) => {
        return /* @__PURE__ */ jsx(Radio, {
          onValueChange: field.onChange,
          radios,
          defaultValue: radioGroup.defaultValue,
          ref: field.ref
        });
      }
    })
  });
};

const WrappedCheckbox = (props) => {
  const {
    id,
    helperText,
    info,
    label,
    error,
    success,
    warning,
    checkboxes
  } = props;
  const {
    control
  } = useFormContext();
  return /* @__PURE__ */ jsx(FieldWrapper, {
    id,
    helperText,
    info,
    label,
    error,
    success,
    warning,
    children: checkboxes.map((checkbox) => /* @__PURE__ */ jsx(Controller, {
      name: checkbox.name || id,
      control,
      defaultValue: checkbox.defaultChecked,
      render: ({
        field
      }) => {
        return /* @__PURE__ */ jsx(Checkbox, {
          ...field,
          ...checkbox,
          value: field.value,
          checked: field.value,
          onCheckedChange: checkbox.onCheckedChange || field.onChange,
          ref: field.ref
        });
      }
    }, checkbox.id))
  });
};

const NavigationTabsContainer = styled.div`
  width: '100%';
  height: 10rem;
  background-color: ${(props) => props.theme.navTabs.bg};

  .nav-link-list {
    padding: 3.2rem 3.5rem 2.2rem 3.5rem;
    a {
      margin-right: 4rem;
    }
  }
  .mobile-box {
    padding: 2.6rem;
  }
`;
const DropdownLinkTrigger = styled.button`
  background-color: transparent;
  border: none;
  border-bottom: 2px transparent solid;
  color: ${(props) => props.theme.navTabs.navLinkColor};
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  font-size: 2.2rem;
  letter-spacing: 1.5px;
  padding-bottom: 1rem;
  transition: 0.2s all;
  padding-left: 0;

  svg {
    margin-left: 0.3rem;
  }

  :hover {
    color: ${(props) => props.theme.navTabs.navLinkHoverColor};
    text-decoration: none;
  }
  &.selected {
    color: white;
    border-bottom: 2px ${(props) => props.theme.navTabs.navLinkColor} solid;
  }
  &.navTabs {
    padding-bottom: 1rem;
  }
`;
const NavLink = styled(Link)`
  border-bottom: 2px transparent solid;
  color: ${(props) => props.theme.navTabs.navLinkColor};
  cursor: pointer;
  font-size: 2.2rem;
  letter-spacing: 1.5px;
  padding-bottom: 1rem;
  transition: 0.2s all;

  svg {
    margin-left: 0.3rem;
  }

  :hover {
    color: ${(props) => props.theme.navTabs.navLinkHoverColor};
    text-decoration: none;
  }

  &.selected {
    color: white;
    border-bottom: 2px ${(props) => props.theme.navTabs.navLinkColor} solid;
  }

  &.nav-tabs {
    padding-bottom: 1rem;
  }
`;
const DropdownLink = styled(Link)`
  border-radius: 2px;
  color: ${(props) => props.theme.navTabs.navLinkColor};
  cursor: pointer;
  display: flex;
  font-size: 2.2rem;
  letter-spacing: 1.5px;
  padding: 1rem;
  transition: 0.2s all;
  width: 100%;

  svg {
    margin-left: 0.3rem;
  }

  :hover {
    background-color: ${(props) => props.theme.navTabs.hoverNavLinkDropdownBg};
    border-color: ${(props) => props.theme.navTabs.hoverNavLinkDropdownBorder};
    text-decoration: none;
  }

  &.selected {
    background-color: ${(props) => props.theme.navTabs.activeNavLinkDropdownBg};
    border-color: ${(props) => props.theme.navTabs.activeNavLinkDropdownBorder};
    color: ${(props) => props.theme.navTabs.navLinkSelected};
  }
`;

const isSelected = (pathname, href) => pathname === href;
const NavigationTabs = (props) => {
  const {
    className,
    navLinks = [],
    dropdownTriggerText = "More",
    dropdownMenuAlign = "end",
    dropdownMenuSpacing = "2rem",
    dropdownLinks = [],
    pathname
  } = props;
  const theme = useTheme();
  const isSm = useBreakpoint(widthQuery.sm);
  const mobileLinks = [...navLinks, ...dropdownLinks];
  const currentLabel = useMemo(() => {
    const currentLink = navLinks.find((link) => isSelected(pathname, link.href));
    return currentLink?.label;
  }, [navLinks, pathname]);
  return /* @__PURE__ */ jsx(NavigationTabsContainer, {
    className,
    children: isSm ? /* @__PURE__ */ jsx("div", {
      className: "mobile-box",
      children: /* @__PURE__ */ jsx(Dropdown, {
        menuBg: theme.navTabs.bg,
        align: dropdownMenuAlign,
        spacing: dropdownMenuSpacing,
        trigger: /* @__PURE__ */ jsx(Button, {
          tertiary: true,
          IconLeft: RiMenuLine,
          children: currentLabel
        }),
        children: mobileLinks.map((mobileLink) => {
          const selected = isSelected(pathname, mobileLink.href);
          return /* @__PURE__ */ jsx(DropdownLink, {
            href: mobileLink.href,
            selected,
            children: mobileLink.label
          }, mobileLink.label);
        })
      })
    }) : /* @__PURE__ */ jsxs("div", {
      className: "nav-link-list",
      children: [navLinks.map((link) => {
        const selected = isSelected(pathname, link.href);
        return /* @__PURE__ */ jsx(NavLink, {
          href: link.href,
          selected,
          children: link.label
        }, link.label);
      }), dropdownLinks.length > 0 && /* @__PURE__ */ jsx(Dropdown, {
        modal: false,
        menuBg: theme.navTabs.bg,
        align: dropdownMenuAlign,
        spacing: dropdownMenuSpacing,
        trigger: /* @__PURE__ */ jsxs(DropdownLinkTrigger, {
          children: [dropdownTriggerText, /* @__PURE__ */ jsx(RiArrowDropDownLine, {})]
        }),
        children: dropdownLinks.map((dropdownLink, index) => {
          const selected = isSelected(pathname, dropdownLink.href);
          return /* @__PURE__ */ jsx(DropdownLink, {
            href: dropdownLink.href,
            selected,
            children: dropdownLink.label
          }, `${dropdownLink.label}-${index}`);
        })
      })]
    })
  });
};

const MemberCardTrigger = styled(DropdownButton)`
  min-width: ${({ minWidth }) => minWidth};

  & > span {
    margin-right: 8px;
  }

  &[data-state='open'] {
    border-bottom-right-radius: 0;
  }

  svg.icon-right {
    color: ${({ theme }) => theme.primary};
    margin-left: auto;
  }

  svg.icon-left {
    // TODO Need to know if colors are already applied to App SVGs
    color: ${({ theme }) => theme.primary};
  }
`;

const MemberCard = ({
  className,
  profile,
  explorerNetworkId,
  minWidth = "17.8rem"
}) => {
  const copy = useCopyToClipboard();
  const explorerLink = useMemo(() => {
    if (explorerNetworkId) {
      return generateExplorerLink({
        chainId: explorerNetworkId,
        address: profile.address,
        type: "address"
      });
    }
  }, [profile, explorerNetworkId]);
  const handleCopy = () => {
    const shortAddress = truncateAddress(profile.address);
    copy(shortAddress, "Success!");
  };
  return /* @__PURE__ */ jsxs(Dropdown, {
    className,
    align: "end",
    trigger: /* @__PURE__ */ jsxs(MemberCardTrigger, {
      avatar: true,
      minWidth,
      IconRight: RiArrowDropDownLine,
      children: [/* @__PURE__ */ jsx(ProfileAvatar, {
        address: profile.address,
        image: profile.image
      }), (profile.name || profile.ens) && /* @__PURE__ */ jsx(ParMd, {
        children: profile.name ? profile.name : profile.ens
      }), !profile.name && !profile.ens && /* @__PURE__ */ jsx(ParMd, {
        children: truncateAddress(profile.address)
      })]
    }),
    children: [/* @__PURE__ */ jsx(DropdownMenuItem, {
      children: /* @__PURE__ */ jsx(DropdownLink$1, {
        href: `/profile/${profile.address}`,
        children: /* @__PURE__ */ jsx(ParMd, {
          children: "View Profile"
        })
      })
    }), /* @__PURE__ */ jsx(DropdownMenuItem, {
      children: /* @__PURE__ */ jsx(DropdownLink$1, {
        href: explorerLink,
        linkType: "external",
        children: /* @__PURE__ */ jsx(ParMd, {
          children: "Block Explorer"
        })
      })
    }), /* @__PURE__ */ jsx(DropdownMenuItem, {
      children: /* @__PURE__ */ jsx(DropdownText, {
        onClick: handleCopy,
        children: /* @__PURE__ */ jsx(ParMd, {
          children: "Copy Address"
        })
      })
    })]
  });
};

const AppSwitcherLink = styled(DropdownLink$1)`
  font-weight: ${font.weight.bold};
`;
const AppSwitcherTrigger = styled(DropdownButton)`
  width: ${({ width }) => width};
  padding: 0 4px 0 16px;

  &[data-state='open'] {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }

  svg.icon-right {
    color: ${({ theme }) => theme.primary};
    margin-left: auto;
  }

  svg.icon-left {
    // TODO Need to know if colors are already applied to App SVGs
    color: ${({ theme }) => theme.primary};
  }
`;

function getDropdownApps(apps) {
  return apps.map((app, index) => /* @__PURE__ */ jsx(DropdownMenuItem, {
    asChild: true,
    children: /* @__PURE__ */ jsx(AppSwitcherLink, {
      href: app.url,
      LeftIcon: app.icon,
      linkType: "no-icon-external",
      children: app.name
    })
  }, index));
}
const AppSwitcher = ({
  className,
  trigger,
  apps,
  width
}) => {
  const dropdownApps = getDropdownApps(apps);
  const isMobile = useBreakpoint(widthQuery.sm);
  const buttonWidth = width || isMobile ? "100%" : "17.4rem";
  return /* @__PURE__ */ jsx(Dropdown, {
    className,
    menuMinWidth: width,
    trigger: /* @__PURE__ */ jsx(AppSwitcherTrigger, {
      width: buttonWidth,
      sm: isMobile,
      IconLeft: trigger.icon,
      IconRight: RiArrowDropDownLine,
      children: trigger.name
    }),
    children: dropdownApps
  });
};

var hausCastle = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzMiIGhlaWdodD0iNjEiIHZpZXdCb3g9IjAgMCA3MyA2MSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CjxyZWN0IHdpZHRoPSI3MyIgaGVpZ2h0PSI2MSIgZmlsbD0idXJsKCNwYXR0ZXJuMCkiLz4KPGRlZnM+CjxwYXR0ZXJuIGlkPSJwYXR0ZXJuMCIgcGF0dGVybkNvbnRlbnRVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHdpZHRoPSIxIiBoZWlnaHQ9IjEiPgo8dXNlIHhsaW5rOmhyZWY9IiNpbWFnZTBfNDk2MF85ODc0NSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuMDAyNzI4NTkpIHNjYWxlKDAuMDAyMjY0NTQgMC4wMDI3MTAwMykiLz4KPC9wYXR0ZXJuPgo8aW1hZ2UgaWQ9ImltYWdlMF80OTYwXzk4NzQ1IiB3aWR0aD0iNDQ0IiBoZWlnaHQ9IjM2OSIgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFid0FBQUZ4Q0FZQUFBQUl4aDIxQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBRFo0U1VSQlZIZ0I3ZDE1a0J6WGZSL3czK3ZaZytJaERnblFOaTJKYUlxaXlNaTBNWkJFV3dSSVl0YUtYSmJ0R0FPNUxFdXBKSmd0bVlCVlBoWndVcGJzSklWQktvcUw5QjlZV0ZiSkJHbnZ3S2tVWGJMTHU2eGluQ29uOFE3RUVKTEtCNWEyWXBIV2dTWVZSUklCQWtzSmhIRHM5UFA3OWJ3QkJvdVpQbWE2ZTE1M2Z6L2w5b0E3dllkMnArZmI3L2k5SndnZ0FlVlBMOXNsYTZwcENkcDdjdmUyRlFJQUdET0xBR0syNGNsak5hczBkVndLc2IxTllyRzhzRndtQUlBeG15Q0FtSEN3V1d2VCs2VkxlNGxFOThQMmhQcVlldHhIQUFCakpBZ2dCdHlGYVZsVFN5VEU1cjRuU05wM2VzL1dlUUlBR0JNRUhveHN3NU5mMkNYZE5SVm13cS9yY3RXZHZMQmxkWGJHSVFDQU1VRGd3ZEM2WFppcTliWTM1S2VzcU5DYlVhRzNTZ0FBS2NPa0ZSaUsxNFY1Y2ZwNGhMQmpGVDJlQndDUU9nUWVSSGJyNGMvUDhTeE0xVDlnVTBTdUNraWV4VWtBQUNsRGx5YUV4bDJZcFV2WEhaUWs2elFhak9jQlFPclF3b05ReW9lWEs5eUZHVVBZZVYvT3VqUzlTQUFBS1VMZ1FTQ3ZDNU9tbG9mcHd2UlIyZmpFc1lNRUFKQVNkR25DUUY0WDV0cjBncFNVMkppYks5b3pxNDg4MUNJQWdJUWg4S0N2alU4OFczWGQwa0xNcmJwK01KNEhBS2xBbHlaY2c3c3dYVmxhVGlIc1dMbDBhWHFCQUFBU2hoWWVYS2E3TUJkVkYyYVZVbVlKbWovMXlGYXN0d2tBaVVIZ2dTZkZMc3lCTUo0SEFFbENseWJRclU5OGJuK0tYWmdEV2JLMG9GcVpOZ0VBSkFEYkF4V1l0MG5yQk0vQ2xGVXlnNjNIODJZSUFDQm1hT0VWRkhkaGVwdTBqbUc4em84a3F0NzYrTEVvNjNNQ0FJU0N3Q3VnVzU4NGR0RHJ3dlRmem1kOEJCMHNxMENtREZHdFpPenFEbUE0VEZvcGtDdGRtR2ExNmdad2RIMmU4VnNKcWJDYlV3OTFkY3dJSWJEMUVZQ2gwTUlyQ042aHdNUXVUQjkyNmFMNTlYa3E3SGk3STk3SnZhSU9yQThLWURDMDhISnVpRTFhelNKcDMrazlXK2ZKUUNyc09KRHI2ejdjVksyOFdRSUE0eUR3Y3N6YnBOV2FXaUloTmxPR2xVaHVPYmw3MndvWlFvL1hjV3V1T3VDVWhncTlBd1FBUmtHWFprNXRlUElMdXpxYnRHWTc3RmlieENLM1ZNa2NWU0xmcnVHR0NrWE1OQVV3REFJdlp6Z1llQmFtZE50TlkyZGhSbWZ6eHJOa0NOVjZXMUlQUVMyNGd5cjBkaEVBR0FOZG1qblM2Y0tjSHZ1S0tZa3hiRHhQQlZwRFBlejNPWVZuYlBMTVRXTzZZd0dLRElHWEU3ekRnZXI4YStTb1ZkZlBxaHJQbXpGc1BLK3BIdnhhY2h4NlcxVG9PUVFBWTRYQXl6aHZod1BWM1NkSjFxa1lqS3ZQVTZHM1RQNWplZzUxV25vT0FjRFlZQXd2dzhxSGx5dld4ZW5qQlFvN1prOXdtWVZaZGxJbjFBYXgxYkdJMVZnQXhndUJsMUhjaFduUlZIN0g2M3k0a3ZhYXRONm1YbDJGRjd4MmZFNURZVHJBbUtGTE0yUDBKcTI4UEZpTmltMVZkMjA2WkFqVmdyUFZ3M0YxK0xYa1VKZ09NQ1pvNFdXSXQ4TUJkMkVpN0ZqWnVqUnRWSDJlSHFQamxwN2YrR0pkTDBjR0FDbEQ0R1VFZDJHYXNFbXJZU3FtamVmcEVvUjlBYWMxRUhvQTZVT1hwdUYwRitaaWhoWjlUcDJ3YU9lcnY3aDFpUXdTb2thUDFWVkFIaUVBU0FVQ3oyRGNoZW02cFFXMDZnSVpONTdIVUpnT1lCWjBhUnJxMWljK3R4OWRtS0Y1NDNsa0dCVmtEZlhnMTRMajhjZGxQZGtGQUJLR0ZwNWhNclpKcTFFc1FmT25IdGthTkg2V09oU21BNWdCZ1djUXJ3dFRXb3M1WHg0c1VhNW96NncrOGxDTERLSUx6cmxjd2ZZNXphSE9FbVRZTVIwZ0llalNOQVR2Y09CMVlTTHNSbUxKRXBjcTJHU1FrSVhwTnFFd0hTQlJDTHd4NHk3TURVOGNXODdzanVUbUtaY3VUUytRWVVMVzZGWDFMdW9Ba0FBRTNoaHRlUEpZalRkcHhYaGR2S1FLam8ycXhVeUdRV0U2d0hoaERHOE11TGJPNG9KcHRPb1NaZUo0SGxPQlZsY1BRUzI1aGdySW9FMW1BU0FDQkY3S3ZMQzdPTlZTdC91YkNaTEdXd25ObUZhZngxQ1lEcEErZEdtbWpQZHhVMjlpWndqU1lKczRuc2QwalY1UUMyNWVCV09GQUNBV0NMd3hhTGZGck9yT2RBZ1N4K041Sm0wbDFBdUY2UURwUXBmbW1IUnE3cmdNQWRKZzZuZ2VRMkU2UURyUXdodVRVL3ptS3lVbUphVEVrcVVGazdZU1dvZDNUUGRiVDlPbVRrc1BOWm9BSTBEZ2pkSHBQZHNhcW9uZElrZ0RqK2NaV2RpdEM5T0Rsa1N6Q1lYcEFDTkI0STJaTjU3blg1Y0ZNVEYxUEUrMzNNSk1ya0ZoT3NBSU1JWm5BSXpucGF0RWNzdkozZHVNMlpKSGhSai9MRkhLVkZDakJ6QUV0UEFNNEkzbmtUeEVrSW8yaVVWVHh2TlUyUEdLTUZGck1yRmpPc0FRRUhpR09MMTdHM2UxWVNQUWRLanh2T3ZHdnZTWURxMWh1MWc1OUhZUkFJU0d3RE9JMnhZOFd3L2plU21RSk92akhNL1RZZGVnMGFBd0hTQUNCSjVCVmovNmdDTWt6UktrUTlEKzJ3NC9sM3BnNkpaWkkrQzBKZW9zTk8wSGhla0FFV0RTaW9GdVBmemN2UHJUekJHa2dkZmIzTUpMdmxFS2RJdnNlTUJwRHVuTllFTXVOTTNub3pBZElBQmFlQVp5Snk4MkNPTjVhYkVuZU9lS0ZPaVdXTkJzWEljNjRlVUZzSHBzVXZDYW16YWhNQjBnRUFMUFFOemF3SGhlZWx4SmU1TWV6K3NKTzc5UWNxaFBTeTNrUXRNMkJZY3BRS0VoOEF6RjQzbXF3eG0xVm1sUjQzbmxoV1diRXRBVGRyYlBhWHh6czNOUXQyU0loYVpaQllYcEFJTWg4QXgyK3BHdDg2alBTMDNadWpRZGUzMmU3bWJrQ1NoMndLbXpLdFNDdXJIRGxLNWd4M1NBQVJCNGh2UEc4N0NWVUZvcUNZem5oU2tzMzZmQ2JpbmduTzZhbXp4ejB3azRGWVhwQUgwZzhBem5qZWU1Z3Qva01KNlhBaDdQMi9EazUySXA2TmFoVXc4NDdZQUtzbmtLS1dMb29UQWRvQWZLRWpMaTFpZU83VlV0dmJHdkRsSVFxN3BVd2FFaGhTd3NQNkRINW9iNStqWjF5aHVDdW1DM2hPZ3FCU2dFdFBBeWdzZnpoQXljdEFEeDhNYnphRWdxakxpR3NoRncycEZodzQ3cHlTMWhXdjRvVEFmUUVIZ1owcDY2c0JmamVhbXBiSHppV09RV3RRcVhtbm9JNnFKOG5vWmZRL015M1hJTDJrY1BxN0VBYU9qU3pKank0ZWNxRm9tZ2xUb2dKcTVvejZ4NnUxa0UwNnVvREZWck53cjFmUnZxSVdpU2lrTjY5UllDS0NpMDhESm1sZmR4RTRGMzlSQVRTNVlXdzlUbjZSWVVkNE9tR25ZTWhla0E0U0R3TW9qSDg2U2t3R25zRUl0eTZkSzBiekYzaE1MeXhOYTdSR0U2UURBRVhrYkpxUXV6R005TGh5U3FEaHJQMDRYbFFXSEhFbC9jV1gzOXVucG9CWnlHd25Rb0xBUmVSbkY5bm1XMXNaVlFTcmcrci96RXM5VStUM0dMeVE3NDlEQ3JxTVNGMTJBTitsNG9USWRDUXVCbDJDbWVUSUh4dk5TbzhieUYzdkU4RlJyYzZxc0ZmTm9CdmVOQkt2U2tGQTQ5SitCVUZLWkQ0U0R3TXM2cnp3dnV4b0o0Mk4zeFBOMUNDaW90R0xxd2ZCUTlOWHBPd0tsTjdKZ09SWUxBeTRGMlcyQThMeVU4bnJmMHRWTThadGNJT1BYSU9NS3VTNGRlbUMybVVLTUhoWUU2dkp6WXFNYVhYRm5DdFBPRWZmanQzMGUvdC8ydW9OT2VWNEZqUk10SkY4SUhyUnJqRUhaTWh3SkFDeThudlBFOEtiRi9Yb0orZU1QMTlJbjNiQW82elZGSGxReWhkMkVJR3VlMUNUdW1Rd0dnaFpjekd3NGZXNVlHdmVIbXhSMDNUZFBUUC8xRDNxTVBod3h0S1lWY2pXVkYvZXhiQ0NDbjBNTExHVzg4RDFzSnhTcnJZY2YwZUdMUVpzSW9USWRjUStEbHpPcEhIM0FzMGQ1SkVJdWJweWZDaEoxWENtRDZHSmo2K1hoV2FkQnFMQ2hNaDl4QzRPV1FONTVITXVodUhrSUlFWGEwNzltdjBTM05sa1Bad0tHSHduUW9KQVJlVHAzZXZTM01HeHY0K05UMnQza1RWZnc4K3JkZnB6OTY0ZHZsMHFYck1yRTVMM1pNaHlKRDRPV1kyeFpoNnJDZ2o0Kzk4eTMwb2JmZjVuc09oOTFqZi9QL3ZIOUxrdlZiSHo4MjhoNTNhWWdRZWloTWgxeEI0T1VZaitjSlNWaHZNeUlPdTk5NDE1dDl6L245TDM3emN0aGRKbWovYlllZnkwUkFSQ2hNWDBSaE91UUZ5aElLNE5iRHo4MnJQL1VjUWFCZnV1OTIrc1FEdHU4NWYrNmNwbi85UDE4YzlMVGpUbDdZd290N1V3YW9NS3RTOEQ1NTNEVStrOFhOWTNWdDRhQ1dkMHY5YjJvUkZNWUVRZTY1a3hjYjFxWHA3ZXFmNko3eXNlMzJOd2FHM2QrZlBrZS84dG12K3AxaVQ2eE44NFNQVEN6cXpXLzRLaFM0RjhDdkhLR2luOC9pN0Y4T1BMOEpPQzJDd2tDWFpnRndhd1BqZWY1NEp1Wi9mZDg5dnVlOGZQWUMvWnUvZUlGZXU3RG1leDV2SlpTVjhUeW1kM01JV3FXbnBuZUhBTWdzQkY1QjhIaWU2c0RHMG1OOWRBdkx1ZVp1RUE2N0hjLzhYM3I1dXhjb0ZEV2UxN3VWa09sMFlYclE2Mk12eWhVZ3l4QjRCY0piQ2FFKzcycGhWbEY1N2VKYXRMRHJLS3R1NUVVVmVwbFpuMUtIWGxCaE9wY3JaS2IxQ3RBTGdWY3dQSjZIcllRNnVFWDNSKys3TjdDdy9GZU9malZxMkhWVjlIaGVacWpRcTFOdy9lWkIxT2hCRmlId0NzWWJ6M01GMTJBVmZqenY5eDYrSzdDdy9MYys1M2l6TW9mRjQzbFphdVZwWVdyMDVsR2pCMW1Ed0NzZ2pPZDFhdTEreXI3Vjl4d3VMSC84aTkra2thMU5aQ29ZUWhhbWM0aGo4MWpJRkFSZVFmRjRucENCNHpXNUZLYXd2SGNWbFpGSkszT3RhVjJZSHRRVGdOQ0RURUhnRlZoNzZzTGVvbzNuY1dGNVVOZzk5WSt2eEJaMlF0RFM2dTV0bVZ6VE5HVG8yWVROWXlFakVIZ0Y1bzNuQ1ZtWXJZUzRDek5VWWZsUjM4THkwS1FLdS9iRUd6Szl0SnNLUFE3ck1EdW1MeEtBNFJCNEJlZTFQa1EyVmdVWkJVOU80VWtxZnJxRjVURllWUzNuZldjZTJicHpkWFpMNWljSDZjTDBvTmRJRlp2SGd1a1FlT0NONTBsSlM1UlRYSGJBNVFleEZwWVBKQnlYNU16cFBWenptQjhxOVBoL1Q5QkVKMndlQzBaRDRJRkhUbDJZemVONFhvS0Y1ZGZnU1VEdTVIVmJzanBtRjBRWHBnY3RYSUROWThGWUNEenc4SGllWmJWenRaVVF0K2pDN0ZnZVE5aDVYWml2N3RsYXowTVhwaDhWZXJ6S1NpdmdOR3dlQzBaQzRNRmxweDU1cUpXbjhUeGVERG9vN0g3NTZGZnA3MTg5UjhOVFhaaVRZa3ZldWpBRDhFU25vRlpzVTI4OUJHQU1CQjVjeGF2UHk4R1dLZi9sQWR2YjdzY1AxOXI5OFQrK1FzTlN2NmREWGhmbTdBTU9GWWd1VE9mUWN3Sk94ZWF4WUJRRUhseWpQWGxoWjViSDg3aXdmTTk5dC91ZU0ySmgrYW9nTWZ2cTdxMTc4OTZGT1VoUGpaN2pjeG9LMDhFbzJQRThJOVNiUm8wNmJ5RHJPVW5zMnJ6eGlXZXJyaXdGN1lSdGpKdW5KdWdUVzIzMVdLS2YydVMvWk5ockY5djA1eThOdno3bWxsdXZQM3J2aGh0T0VEQmJIZFdBY3h6cTlCb2MxU1VPcWRGaE8raHZkVUJQeElHQ1FPQmxoTHB3K2FLMSt6elZWQmR0SXBOTmJuMzh1WWE2bGMvRWpEc2VxenYrb1hjU0dDMngxK29nQ0R6b05VRUFBNXplczYyeDRmQ3g3VEw0RGg0QVVuYTJYcS9JL3IwK21iT21oZ2x1YVRZVEwrZEI0SUd2ZGx2TVdpVjVuSEp5WVFIa1Jac0VMK2RtVXc1WUpIbFJnOFFERDVOV3dCZHZKV1NKZG1IVzJ3VElnak9xZFVjNUNUdm1waEIyRElFSGdiejZQSkpCSzJ3QVFFb3M4aFlBeUJPSFVvREFnMUJPNzk3R0YxZ3VsOHlDZExTLzhRMmJJQzdiS1VmU0dMOWpHTU9EME55MjJKbkY4VHd1UWZpdHp6bUI1MjI2Y2VyQTB6OXpYNU1NY3ZZM1BuYWNNclRYbkxWeEExMy9zWS8xZmM0OWNhS3F1dUtxNnMydFJUQzA3OVRyZFptajdreEs4VVlhZ1FlaDhYamVoc2VQelVxUnJiM1BYcnZRcHEvN3JwVXAxRGpsMnV6ekgzNVh5N1E2bmRmcXM0NTZxRkJPbE1pYW94eXM1RE5Pa3JKUktoU1dJSmxhNEtGTEV5SjVkYy9XcFR5TjV3bEJMVjRlckROT2FTSjVsSEpFa3F5cFZwNU5NQlJ1M1ZHK1duZnFOVUhQVTBvUWVCQ1pPM214UVhrWXorTWREaDdaT21QeThtQWloK09tcXBXSDdZT0dsTGZXSFhOVGJQRWo4Q0F5M2txSXgvUDRuNVJKM0lYWnpzUW1yZTBjZHYrcFZsNmR4L0lJSXNsajY0NVNLamp2UXVEQlVIZzhUL1c5WjI0cklUWCt1R1IyRitiVjFKdUJRNW05c1Jpc2xNT1dTcExVRFVJNWo2MjdOTWZ2R0FJUGh2YnE3bTNOREkzbmVadTBubmxrNjg3czdYQWduNmFjNGVYcVhxdlg4MVpMbHBpSlRqZXdUVG1qWGdlcHZyWVJlREFTYnp6UDhLMkVObDQzNmJna005R0YyVThlOWlmc1QrekhCSlpnL0R0U3I5OWMzaHk0S1k5UkkvQmdKTjU0bml0NFh6UmpXMDN2dTZQY1d0MjlMYk9UUDlRNDNoTGxVMWwxYlM0UURNUmRtUmFKekd6VEZaR1RkazBtQWc5R3h1TjVxaGx5Z0NBUjZrMkJieVp5dWNvTnVqYjk1YlVyazZueHV4YWxESUVIc1RqOXlOWjVJZWtJUVVMeU40NTNoVGlJV1p2WE9sdi95RnhldXpLWjZybEl2Y1lVZ1FleGFVOWQyR3Y2ZUY1V3VUbGZuVVIxMnkxZ1BPOEszZzJoVFc0bXg1d2pTTDJySG9FSHNmSEc4NFFjeTFaQzZnMHpkMVAzZStteGpqei9iN1I1ckFxaDE1bWtZblgydXNzeCtiVHVxazhWQWc5aTVVME9FWlJ1Zlo2VXovLzgyMjRyd0o1OU11OWR4dDRiUFUvVW9JTFNZY2VUVkd6S01YZE1FN0VRZUJBN0hzK1RNcDBYdENBNjVFNWRYLzM0dTkvc1VNNjUrWjJ0MmF1aVczcUZDNzJpaEoyR3dJUDhrRk1YWmhNZXoxc1ZGdTE4ZGZmV3Zka3JKQitPN3RZc3dwNkVISHJIaTlTOVdhU3dFeVNiNCtqT1pBZzhTQVNQNTFsV2U1WVMwTm5oUUd4NTlSZTNGcUhGczA2ZVoydGVwVEJqZXQrdDE2c2M4RlNNbGgzUHpoeGIxendDRHhManJWY1o4M2dlZDJGMmRqaDR3S0VDVXQyYWVaKzUxNnNiZWpYS3FVN3BnZGV5SzBvWHJqUE9EWUN4QVd6MlZhU1VEWXFCRUtJUjVYejFmYmxHS1BCQ1BiVHlqZFh6Ylhmb0MvcVB2M3lTWHY3dWhWVkx0SGRtWmRIbnBIQlgwSGZxc3kwdTJLYWNtbnJ3UVJJYk4zVC8wMWJIWXJ2UmFGcWJOcjFFMGNVV0pPcjFYcVVZZisvdGYvaUh6V3RmL25LdDkwMzQwdjk1anR4VHB5aS94anZ4Q29HWGZSV0tiMGZzQmtYRHUxZmJnU2RWM2tTamVISDFmTXM1ZjNIMjlPeEREb0hxRXBJSFZNdW5TamsxdVcwYmxlNjlaLzJINnpSK1ZYWEV0bU5CNlIzdjhJNWU3UmRleUhYZ3FSNktKbzBSdWpUQmVILzQzcnNQRkxVTHN4L3VFc3J2Z3RLUVYzcXlpa05qaE1BRHlDQlpuTWtya0JOdE5icEJZNGJBQThnZzNUVlVpSElNeUQ1ZUtEck5uYzBIUWVBQlpGQ25qaWt6bSs5Q3dZMnpGS0VYQWc4Z28zU0pBbHA1WURvdVJXaVNBVEJMTXg5bUlweDdrT0tiMVRrSXZ3a0hybTI1NzltdjFpKzA2ZVk3YnB4OC91UHZ2c05XSDlwRkVCcTM4bDZyMXcveHp1RlVFT2NlZlRUUytSUHZmcmN6OWQ3MzJwU3c4MDg5UmU3TEw0YzZkL0xCQjcyWnFFWGhralJtcjB3RVhnNElJVnBoejVWU3B0RWlXQTM1TTEwKzUrTXgxUklXRGJmeXJFNTVTQ0VLbDlkZWVESFMrZGJHMit4Qno3bW5UNGYrblgydlhyZmRsMTdhWkczYTFQOXJxYkFMKzdPVjdyMlhDc1NZMWgxRDRBRmtXQkZiZVhHNTlPeXpjNi9WWi9sbVliVjdDTjFGTEsvVWwzSW9saStxL3lkV1ZtaDZRT0JCZjZwMWw4anlnc05DNEFGa25HN2xjWGV3VFRDTXNqNDQ2Q0FtdXU2dVJRYkJwQlVBQTZtdVoxc2ZnZDF1M01wVGQ5THA3a0VJRUtCTlpNellYUmNDRDJETU9OUjRYVkoxTEtyamhEcTRvWEZDSDJmVWYvS3hySTU1dlo3ak5WVG9MV0gxRlRDRkNhdXE5Sk81THMxYWRjRlc5dzRWYXJkdElZUTY2R1k1b0N0SHZRRTRycFF2a1NVYzlWL3FtRmhaYXMxaUdqY1lRWWNYajcxVkEwNHQ2M1A0bUZPZjU2akhBK3IxMyt3OXFhMWFlWHFiR1lCeGNreHMzVEhqQTA4RlhKbmFGK3VXSlRhckM3MUc3c1ZPRjQvZy95ZEorblM2eSs1cHJ0VC9kWkYyYmorOG9qNjI0Z3JyYWFKU0N3RUlhZFBkbEJ4MGUyazR0am9XMU5maHIzRTUrSGdsQ3oyQlpZNEF4b1RMRUV4czNURWpBNjhiY3NJU08xVEFWVG0xcEl4cE9GbktpdnBLRlNIYmRiNG4vc0QyeDVkY1VUcXkxUHJGQW00bUNtbFRyMk91Z1Z5a2VDYVkyTlFKdmswcTlMdzdhcGVvb2NZcGRoQW1zTUFZNkNYRW1tUW9vd0t2Vm4yaUtseTNya0p1aC9yTmxTbXVrUE9odmtWTmhWOXQ1OE9QTzZvN2FMNXR0WjllYW4zVUlZQ1k2YkJMWXJQUEJrOXdVYUUzeXhOWXp0VHJzMVpuVTFHQVZLbXVUS1BLRU5Zell0SUtCNTNxYWx4V1ljY1hLVSt2SGtjUnJhMmE0dlBDdFpZLzhQQVQrMnZWVDlzRUVKTUV3NjZycnI3SEF2K2pNeFVjNjJ4Q3VrenV5dXdhYStCeDErVUhIbjc4b0JkMEEyYWZqWUV0eVcxdzhOVWVPbHduZ0JGeDY0czYzWmhodzQ1WGxXL3FvMFhoMTh1czYxM292YTVOOWVBUVFBcDBWMmFERERlMndQdTVody9QQ2ZmaUNUbjh3SDNTVkJlUlhGQmRuU2ZRMm9NUk5TaDRUTTFSQjlmUzNhSzZKcmR3OTZRK1p0UnhpL3I0RmdxMzR2eEJudjJwYS9PTTdsNkMzSEJNNzhyc1NqM3d2RmJkOXNjWHVmdVFzckgrbjYxYWV5ZTRtNU1BSWxMaFU2ZmdSYkVQcVZDN1V4M3o2dWpibWxNZlgxRkhYZjN6VGdwdXVYbXZWWFJ0UWhxeTBKWFpsZXFrbFZyMVV4VWhMeTVLbWIwWlpOek4rWUh0aDIxWFRPN0xheW1Eakw2QWMxbzNMTHRrY0plM3FUZFBRVGRLcyt2cjZmeW9jeDMxdStEZE1iaUxkTkN1RjFYK2ZmRUMzamMzbTN1L1U1L2RMSU5yL1JKWHVtTVRUZGQyQko1bmJkeEFhU2k5NVk1UVAwL1h4RDJGV3ZRNUZCVjJoMHllbGJsZWFvSDNjdzgvdWN0MTIxbHAxZlhGZCtzcXNLdXFpM01tcHpNNVRXM0YxaW1EZEVqYlBxY2NpQkoyWFRyMGVQc2xuZ1JqRHppTi81WXQva2RiZFczcVdadUR6azJGZGNkYmFGb2RwcGg0NXhidmdLSHhUZ2ltRGtuMWxVcVhKbmNIdXRSdVVqNjJNTEc5Q1MwWTE0TmdkWi9uSEJWY0RSb1NoeDc1ajV0VXUrdHdjbmNUeHZNZ1p2eWFpcklQcHhFU0R6d09PKzRPcEh4QjZFRVltMzJlR3ptQTlKNkRMWjlUYXQxLzhIZ2VGcGlHdVBCcktTdmpkcjBTRGJ5Y2hsMFhRZzhHMHEyclFXTnNUcFJOZXdNODdmUGNWZDlmdlVITll4SUxqRXBQVXNua3lsU0pCVjZ0K25ndHgySFhoZENEUVNvK3p6MVA4ZkY3NDdIWGY0QW5zV0JYQlJpV0Ryc0daVlFpZ2NjQklGeGFvR0t3aFN3dEVrQjRLeFFUUFpZM1NOL3R1ZHZrVFhoeENDQUNRWElweTJISFlwK2w2WVdkdEpKY1FzazhVbFo0eFpnLysreWVMSXlSOE0rWTlOOW1tTEtOSm8zVzh1RC9UU2JkZU5nK3p6bVVqcjUvWjczZTVremFNemZiTDc1SUY1YlM3UWxiZStFRk92Zm9vNVMwOXN0ZnB6eVRxbGZDelVoeHVaL1lBMDkxOFRXb2dDdTE4NG94cWh2MzZGSnJUK3hYdEJvUDRzSmwyK2Y1L2QzVjhvTndBVE1aU0xkVUhCcVNYcjRMUXVJSkIybUhubnZ5cEFxZ0Z5bE43cWxUM21FS2ErTkdtdHEyYmVEejEzMzRYOUxyS3FEbHVYTmtFRWVTclBHTkVtVmNyRjJhcW5WWHArQlZKWEtMdTNHOXJZMWlwTU91R1hCYVErK05CaENhTGxmZ3FlVzVYRWpCTkJ4Mk4zenNOMGlveDRIbjNQRVdkYzdIU0Z4L1BSbkNlNDFrY1VabVA3RUZudTdLTFBxYmJ0bVNsdzVTVEVLR1hSZENEeUpENktValROaGRQdGVjME10VjJMSFlBcy9yeXN6Z2ttRng0OVZZVlBoWGFVUVJ3NjRMb1FlUjhVN3BPdlFjZ3RoRkNidkxuelArME10ZDJMRllBazlQeXk5c1YrWjZRcFpHQ3AwaHc2NnIwZDBpQmlBc2hGNHloZ203eTU4N3Z0RExaZGl4V0FKUFQxU0JMaW1ydzdieVJneTdyb1A2NndDRTF0Tzk2UkNNaklQcStsLzkxYUhDcml2dDBPdk14cFJiOGhoMmJPVEFRK3V1djJGYWVSSENqbWRrQm8yNU5CRjZFQlZDTHg0Y1VCeFVWc0JpMlplZWU0N2NnSktHdEVKUC9kMlBTT3JzcFVnNU5YTGdvWFUzUU1SV1hvU3dtOVdMRG9lWmFJRFFnOGgwNkcwUkpESzVmTlM0UlFtNzd6MzVCMTRad3JoRFQyL3pVODl6MkxHUkFrOVB3USsvb1ZUQldOS2FDM05leExEenp0UDFkQWc5U0FTLzhiMngrWWM3ZVNrcGd0Q2loaDNqbXJ0eGhwNWVDTG9RNC80anR2RE84MnJzeFZsUkpTSXBxUnBVbHpkTTJIVWg5Q0JwdkpRVWRsa0laNWl3NnhwVDZLM3F5U256VkJBakJaNGFwOEticUw4eXRTL1dCejA1U3RoMUlmUWdhZnlHeUYyY2hIRzlnVVlKdTY0MFE2OW5ja3FMQ21Ub3dQTW1xM1IyZEFZZndoSjl1M3pqQ0x2TDN5TmE2RlVKSUtKdTJRTEc5Zm9iTmV5NjBnZzlIcS9UazFNY0twamhXM2h0cTBJUVRNcksrbTdOT01PdVM0ZmV6aENuTHFydmo3OGRSTVp2a0JqWHU5WWJQdktSd0xCYis5dmpnV0hYbFdEb2NSZm1MSS9YNVgxeXlpQkRCNTRRVjNaVEJsOHE3TTVmRHBna3dxNUxieW9hdEtJNWgrOHlRZytHcGNmMTdpUjBjWHBoTi9uZ050OXpPTGkrOXdmaHdxNHI3dEFUSkZ1NkM3TkpCVGJDR0o3WVRCQ09iZzJIRER1Kzg1cUpHblpkK3ZNUWVwQW9idTNkM0Z5NHM4aXR2YkJoTit6dUJ6R0ZIcmZxOXIyeDJjemx5aWxSRFJWNG5TNDZ2Rm1HSm1RMVl0aTFhSlJ2aDlDRGxCUzF0WmQwMkhXTkVubzlyYnJDek1JTU1tUUxidzF2a2hIODVNKytZenVGRDd0WTlxdEQ2RUZhaXRiYVN5dnN1aUtIM2cwM2VHTjFhTlZkYTdqQWE3dW92UXZweDk5L0QrMzV0dzhGL2I1aURic3VoQjZraVZ0NzB4LzgrUzJVWTJtSFhWYzM5SGltcHg4T3ZadCs3NU5PZVdFQnMybjdHQzd3Qk9ITk1ZUmZtSDBYL2NySHR3ZWRsa2pZZFVVTVBac0FSakI1Ly8yNW5mMTMzWWMvUEphdzYrS3Z5VE05ZzBKUDRmZG52cDdSTUZsbmdvWmpFL2ppc1B1RitydUNUa3MwN0xvNDlQU0wzMjl6Mm03bzhjL2pFQ1RwSVBZdHpKYnBIVHRvNmlmZTUzdE9rbUhYcTF2ZU1Mbk5OM3k3b2NmWGN5RkxFUG9aTnZEQWgwbGgxNlcrejd3T1BiODNXcHNRZW1rb0U1Ymt5d3dPdSttYS81TEI3cWxUZE82VG4wdzg3THJPUC9sa2EvSkhmbVNWYnJxcDVuTWFRbStkb2JvMDFTOXZFMEZmSm9aZGw5NWxJV2hpZ1UzbzNvUUVURDc0WUpNblUxQ0dablNHRHJ0SEgvTWVrNlpuWHM3d2hCVHh4amZ5UWhOSEFqNEYzWnM5WXRrQUZqcE1EcnN1aEI2TUV4Yys2eG1kTStyTjIraUpGUWFGM2FyNlhUVzdRZGU3L3FXNm51c1VMdlNPNDNwR2wyWnNzaEIyWFJ4NjZzWFAvMFQzSm95RmZ0TnVuYW5YYlhYWDNWQ3ZTcDdkWlpNaERBazdMaTg0cEI3bi9aWUM0OURUMTdQZjR2QTI0WG9lTXZBa3ZVWndXWmJDcmd1aEJ5YlFkV0oxL3JjS3YzcUphSWNrVWFNeEduUFljV3R1cWExYWJWRjJNa0RvaFROVWw2WWtpUUZRTFV6WW5UdDdnZjdpbVMvTm1oSjJYZWplQkpOd2Q2ZnFzdVBGcWJuTGM1YkhxeWhsWXdxN1ZUMDJOOHYvMjlYdllIYVliWHRDZG0vYVZPRHJlY2d1VFE0OFFVVVhOdXorNDl3ejlMV3ZuVFR5SmdFdHZXVG8rc2NtUVdTNjFkZmtnN3M4MVdOVnQveXFsT0RzMXBURFRyMGZ5Q011RVk5anJzUzFld0ZhZXY2RzdOSlV2NlNDNTEyVXNEdnhsVmRWVy9vNm8xcDN2UkI2WUtyZThPUC9WZ0ZZVlE4VkhZQThHU09XQUV3aDdMeFduT3FxUEtyKzNlTDlCU2toQ0wzQmhwMjA0bENCUlE0NzlXSmZhczBhM1EyTTBJTXM2RTUyVWNjOC83Y0tRQTY5cWhxYnFhaDc4RTI2RlJoSkFtSEg0YmJTMlZXY09OaGFhYTlwaWREcmI3akFLN2tyNUJhem9tR0lzT05YbjdHdHUxNElQY2dhM1ZLNjZ2clNJV2p6b2Q2bGJCV0VtNlhYRWhUOHNhdGFoQ09FSFhkSk91cHJPK3ByditSMkdnRjhySml5WUROQzcxcERCZDVTNjZQT3pvY2Y1eFpMb1lvWmh3bzc0bjN3NkhuS0NJUWVaRjIvRU95bHh3WExOLzc2djJ0TS9QQVA3UWo0Y3M3NVo1N1p0M2JLRzROMzlOZDNLQ01RZWxjYnZnNlBXeTFTVnFrZ2hnMDdqNlJNdFBDNkVIcVFaeHhZZWkzVHdMQlR4OHdOczdNT1pSaEM3NHFoK3lXbEs1K21naGdwN0ZpcDNhS01pVkN5c0lobGl5QkwxT3QxanJ4aWQxOE9kZXBtSGNvQmxDeDBERDhReCtONEJUQnkyS2tMaDd1QUtZTjA2QjBLT0ExcjlVRm1xTmNwdDNMbUEwNXpLRWRoMTRYUUd5SHcxSnQ0aXpxcmgrUldER0hITDdJV1paajYrZmNTRnFpRkhOQmgxd3c0amQvVGR1YTFXNi9vb1RmU1ZFdEpNdWdYbDFseGhCMXpSVHZ6djZNSUM5UWk5TUJJRWNMT21PWC9rbExrMEJ1dHRzQXllN1h6WWNVVmR0VHB6bXhSRGlEMElLc1FkdGNxYXVpTkZIamVtM25HdSt6V0N4TjJKNy8xWGZyMWoveFpVTmlwQzAwRVRmcklGSVFlWkEzQ2JyQWlodDdJMndOSjFXVW5wRldsQk54WCtVSDZvUzIzVTFxKzd3ZHVwSm1mdkNmd3ZHK3J3T05nOVBPS091ZityZmIyeGJjL1lsTThWaW5lTWROaHYxNlRPcUcyMmVjYzdMUU1ZeGN5N0JqZm1KYmxjR1ZXY2U5ZW44VFh1OW5uZWE1WENLcXB0cWx6UFdmOUJyNFZ5NHFZT3g5Ky9Bd2xVSVFlY3RzZE1OZVNDcnlkbEFKOUIzcGl3Tk5OOVhQTUVpVE9sTCtERHE5bEFyaGlOcGIxd2FTa1hIWGRRV3hxNm8xbmdRQlNwRjV6M01Pd1NBRHJ4Qko0UzgvdW1TZFI3QVdsWWFBNkFhU0xTMmt3aGd6WGlHMEZhQ2xjZEJrQkFJQ3hZZ3M4bnJFcEJPV3lUQUVBQUxJdjFqMStYREhGclR6TXlnTUFBT1BFTWt1elY2MzY2YXB3clV6TmpycHZ5KzMwbitiL1JkL25udm5UTDlJemYvTDNRVitDckpKdy90WHVkKzNjV3IwNzdyR0R1S2NwMnhTdlRmcXhSZ04rVHFGUXdqQkwwd3dtL0IzVXo5Q2t3VHNEY0M4VTM1Uy9SbWFVK2FUMTlhSWE5QjdPdFlyN0tKdFdScTdEVzQrN05tc1AvLzRoUVdLT2N1RDFzeGU4bXJvZzBuSm50czI4M2FHQzBtOTBWUUl3MjZHc3IyK2JCcjJkVUQrcldmNzlKYkp0K2RKbmYybHYzbFpnOGFOZUcvdXl1aU1DQUVCUkpCSjRUSXJKblZTQXBYb2t1UWU4c2d3QUFEQmFZb0czMUpwZGxhSzlNOC8xZVY3WWZmYWpEUUlBQU9NbEZuaU11L21rY0dmeUdIb0lPd0NBYkVrMDhOaVYwTXRQOXliQ0RnQWdleElQUE1haHQzaDA5eFpKOGhCbDI2bzNRUVZoQndDUU9ha0VYaGZQM3VUV0VXV1RJNjIxR1V4UUFRRElwbFFEajNIclNGcnVuVmthMStPV3FiU210aXkxZnJsUUcwUUNBT1JKN0lYblllaWF0VHRyRDMrNkljamFUd2I3OGZmZmUraERzKy9lU3dBQWtHbXB0L0I2ZFZ0N01uaWIrYkc1N2Z0dndOcWdrQ3BldFdiZGdhMXVBR0l3bGhaZUw5M2FxOWVxbjI2UWE2a1czOEExOEFCeXBXYzVOdDZ3ZER0MTFqa3REemlYSDdoTDNWSEg4K3BvWVlrc2dHakcyc0xyeGNHMzlOazk5Y3N0dmhUSCtLYW1KeHdDU0lGdXNlMVhCeSt3ekFmdkNNL3J6bkxvQmJYaytCeGVwSnVIQVpiVjF6aWpqa1YxMUFrQUFvMjloYmRldDhYSC8rYWRGMVNycnk2RXV2dVZNYS95cis2T3BXd2ZKYXUwOUI4ZWZUKy8wV1JxaHdmSUZoVktWZW9FVlpYaXc2OWJEc0FhaDZoNmJLcmppR3I1T1FRQTF6QXU4SHJ4emd2cWdROFZmcDlTZDdkV2hkeFNSUVhnWnZVT0V1YU91RU8xRmxWWDZZb3J4VXRrU2ZYMXBscTg5Tm1WRXg2cEVrQUNFZ3E2Zm14MU5OU3hWMzFQTHAzaFhRRXcvZ3pRdytqQTY2VkxBcTRxQzZoVkYxVGduYk5WRVBZSlBsZGQ3TllxZGpHQWNkQVRUVGg0MGg2VDV1L2JVRWRkL1F3SFZPZzFDUUE4bVFtOGZuUXJEYlZ4WUJUZHF1T3hPWnZHeCthZlFmMHNtOVhqQWJUMkFESWVlQUNtMFdOcERSb09oNUpEMTk3RTJkUnB1VlVvT3E0aDVURytHWXp0UWRFaDhBQmlva0tGVzNYMUNKL0NBY2MxcUJ4d3JUQ0JwRnVQSEh3N0tQeTRvRTJkV1owN1JRSDJxQVFZeEppeUJJQXNpeGgyTFhYTXFPTk9GVUI3ZVp3dGJPdUxhKy9VTWE4TzcvT3BFNWhoUHRlbVR1Z04wMG9FeUFVRUhzQ0lJb1FkRjR4ejErS01EcTZSeHRVNEpOVlJwMDU0aGxtdHlDdS9RZWhCVVNId0FFYWd4K3pxSVU3ZHA4S3Brc1RxS0QzQnh5MCtKK0IwRHIxRnZjb0xRS0VnOEFDR3BFS0RWMGhwQkp6bXFHTUxkME5Td25Ud2NlZ0ZiY0ZsVXlmMHNFWW5GQW9DRDJBSXVvWFVDRGl0MjRXWjZrUVI5ZjBhRkJ4NjNLMXA5RTRsQUhGRDRBRU1oNWVpODJzaGNkaFZ4MVVLb0VOdk51QzB2WHJXSjBBaElQQUFJdEtMTmRzK3B6anFxSTI3MkZ1dnNoTFUwbHRBMXlZVUJRSVBJQUxkbGVuWEZjZ2haMHlSdDI3cEhmSTV4YVpPY1RwQTdpSHdBS0xodFRGdG4rZjNHYmlpU1lQOFoyL09vWlVIUllEQUE0aW03dk5jMDhURm1uWFhxdDk0SG9jZFdubVFld2c4Z0pCQ2pOMEZqWmVOamE3Lzh5dE9UM3RYQjREVUlmQUF3dk1MaGFhQlhabnIrYlhpYk16WWhMeEQ0QUdFb0NlclZIMU9NYloxMTZXN052MWFlVFVDeURFRUhrQTRWWi9ubnM3UTFqdE5uK2ZRclFtNWhzQURDTWV2OWJORUdhSEg4cHdCVDVleHhpYmtHUUlQSUp6TlBzOWxKdkMwcDMyZXF4SkFUaUh3QUFMb0dqVjd3Tk1yNDE1UlpRZ3RuK2V3ZFJEa0ZnSVBJSmhmQ0J5bDdQRmJ6Tm9tZ0p4QzRBRUVzMzJlY3loajlBU2JRYTNTelFTUVV3ZzhnR0MyejNNT1pkT2d3TU1TWTVCYkNEeUEwV1J0L0s3TEdmQnhCQjdrRmdJUEFBQUtBWUVIQUFDRmdNQURBSUJDUU9BQkFFQWhJUEFBQUtBUUVIZ0FBRkFJQ0R3QUFDaUVDUUtqNlUwNXQxTm5lU3MreXZyZytpOUhIN3k4MVZLR3RxZ0JLQnk5Sml0Znc3enpCcTlvWTlPVjY5bWhxNi9uRnE3bitDSHdES1F2akRucTdGQTlxQkM0ZS9GMEw2Q0Q2dk40amNSRDZrSnBFZ0FZUVcrNXhOY3k3emM0NkhxMjZjcUtQblg5ZVUzcVhNOSthNTlDQk9qU05JeDZrWFBRblZCSGc2S3Zlc0hodDZDK3hnbnNhd1l3WG56anFvNzkxTG1lK2JxT2VqM1gxWEZjZlkwRlhNL3hRT0FaUWw4Y2krcWY4elQ2OGs2Mk9rN29pdzBBVXFZRDZqaDFibHhIVlZmSHN2cWFOWUtSSVBBTTBITnh4UDJDYnZEZElRRkFhdFExeHowdGZEM2JGQjliSFl1NGlSME5BbS9NZE5ndFUzTDdrTlVSZWdEcDBHSEgxM05TaTNEelRleGVncUZnMHNyNGNSalpJYzlkcFN1ek0rMEluOGVoNTZqQjd3TUVBSW5RTjY4OExCRTI3SHF2NTBxRXovTW1xS25ydVVVNVZsdGVzUFUvVjVkbVptUFpsUVNCTjBhNmU2SWFjQnIvb1k5UXAreWd0ZTd6eS9yemVmWlhVSGNvM3hrZXpmdEZBakJHQnluNEpwU3Y1MFBxYUs0dk85Q0JXVlhIL2hCZmh5ZXliRkZmSTVQYlUra3dVeUh2cWtkcnM3d3k2NXp4Y3lRdm4rMjlaODFRREJCNFk2SmYzSTJBMDFycW1CMVVqNk5mN0V0ODZIcTlvTmJpZnYwMUFTQkc2dnFyVS9CTkp3ZGRZMUJJNmV1OHlZZnV0anpvODdWczZwUTZOTWh3S3R5OE1IT0p0b3RPb0ZmazVkWnN1cU5xQ0x5VUxGUVh5dGVkUDFzcHRhbW0vdWlibldkZXFOby9jNi9mcDNEOVRlaStlbTY1cVl1RTc0SzRTNlV5NExRcVg1aW8wd09JWGRCa2t0a28xNTA2ZDE1ZHF5M3lIdytjVStmTW05aks2N1RnM0pva2E0ZlUzYldDeGcrQmw2Q24zdlBKNm9STDIxWGJ2RXF2bjYxMlAzN0Q3VGRSUU5ndFJRbTdMcjVEVkJmQVR2S2ZCTVBkbjAwQ2dGam9jZ0hiNTVRRHc5eGtjc0Y1ei9YY0R3ZWhNYTA4YnNtcFZ0d2N0K0trMTVJemIwNGtBaTlHbjduL1V4VWgyMVgxU3QyaFFxNUM3ZjUzWmh2ZjlXYS9MK09vWXg4TlNZZmVMQTIrU0xpVloyUFpJb0RZK0hWbDhzMXJnNGFrZTI1NHN0bWdGaVFYdERkb2pGVFFjY0R0NTVBem9SWG5CNEUzZ3FmZTgybDdZdTFTVFZwaXUzRDVqc1l0cTFkbzUwbWZ2L3lidHQvcDkyVVBqQnBHK2lKcDBlQUpNWHlCemhNQXhHR0h6M05EMzd6MjRHdDEwRW90dkdCRkplM2x4M3BhYzNXWlhFbFY3QkI0RVhEQVVmdFNkZEt5dHN1MjZzWm9yM2tCSjNnNlVZUmJtOXZlK1NhL3Axc1VENzRyckE1NGJqTUJ3TWgwM2QyZ01iYVZPSHBTZUl4T2ZSK2VxVDAzNEJUK0dWSUp2TzljdWxEKzJlVUZiczN0RmNuVkdpWUdnUmZnbFM5OGZmTm43ditrdXNPU08wUjd6ZVprazY2TUZIQzlKbSthOW80QjRsd2gzZThDcUJJQXhNSDJlZTRveGFkRi9vR1hpcGRmUDFNUktYNi91Q0h3QXB6NnUyL1dPdGtXVCsvMDFJMVRmazg3RkJOOVYraFFocm9iQURMSTlua3V6bGFYMzllNm1TQ1VRZ2RldDFUZzcrYWYzZkVqZXgraU5Gei9nMi8wZS9vMWl0ZWc2Y28yQVVBYy9McjFIRXJITFFTaEZDN3d2RktCTmRYdnpqTXB6NTVWajFRKzgrSXBNa1RjOVRTWlhJVUJBQ0pCQ3krazNBZGV0MVRnOGt4S0xoVUlNWk1TQUtCb2VQYWw3S3pZbEV1NUM3eHVxWUFvV1p1OW1aUzZWQ0RxVEVvQWdDTFI5WFJSRnJQUG5Nd0huamNPOS9wM2F5VVNsY3N6S2NWb015a0JBSXBFaGQyY0xFQnRidVlDandQdStuTm5xNEtYNitLQWUvMnNmU1haa0hBQUFGSDg3UExDUWRsWm9pejNqQSs4OVlzdTk2NUppWUFEQUJpT3QxcUtsQzFSb0lVb2pBeThxeFpkMWpNcENRQUFZc0c3R2FoVzNiSVF3cVlDTVNMd2ZCZGRSaU1PQUNBMjNiQ2pBdGJqamlYd0JzMms5Q0RnQUFBU1VlU3dZNmtIM3AvYy84bGxhcTlWTVpNU0FDQTlSUTg3bG5yZ3JaWFdaa3R1YVZsSVlSTkF4cDM5My8rNTl1MUgzMXJsZjZ2WGRObXlycXg2MFpieXBlNi9PL3NVdGxjdGwxYlBYcUNWT3hzT1ZzR0IxQ0RzT2xJUHZBOS9mcC96MUhzT3ppRDB3SFRmL0czYkxwVksxUXN2L28vdDAvZTh2Kzg1N1pOZm1yTjZ1dU5sejNPWFA2NEpVU0pTLzNmajlVUW5IN3RMZlVTdXFJODZycFRQVzY3YlFoQkNFdlJzektXaVRWRHBaeXhqZUFnOU1KRUt1R3BwWXFJaVhMbERXRlNSc2pONXFuM3F5MFFEQW04MHZGZ0NWVlF3MXFoVTJ0OEp3cmV1Q0JJckx0SFJkcnZkdXYwM0hZY0FScUJlUy90VjJHRVBUQnJqTEUyRUhvemJpWVpkdm02YUtpVlJxbGtsMnVVRm5PeU1LMHRKWXlJcTZsdnpubVAxaVZMSkMwQXByQ01YTDY2MTN2enZuVlIzdFlic3Erbk5XZ2s4WXkxTFFPakJPSGd0dWQ2UW8zRUdYQkJSRVZKV3BpZDErSkU0aEpZZmhLSENycVplMWcyQ3k4WmVoNGZRZ3pSd2ErN0dHNnc1TmNoVzAxMkpCb2ZjSUlKYmZndWRsdDlkUzlSdUg3cnRONTBXQWF5ako2a2NKTGlLUlFiZzBHdGI3UmtwdkIyNkFXSjE4V3RIcXpmZFVEcEJValM2WVpjRFBPNjNmT3F4dTA2ODh0aGRkUUxva2ZkZEQ0WmxST0F4aEI0a3hUMzNxdDN0dXN3YjljWm1jNnNQd1FkZFBHNm5IcW9FMXpBbThGZzM5Q2pITzNYZjhQMDNMUkZBekJCOHdIUlhab09ncndrcFpaVU04K1UvK2J2Ry8vL0xyNmEyTjFQNTdvMERuN3Z0blcraWR6enlveFNYdC96enUvMWFHalgxOTloRThiRUhQYUcrVDRQaVpWTjYzNnVmZ2IvWHllLzdaM1Q5MWwrallVM2U4V01Ebjd2dXZwK2p5YmY4R0JuRVZzZkM5LzdtNXYzWHZYUFhrWUR6K2hyeDcrWDMrcTZrOUZyd200Sy9LK2Izdk8wK3p6WFU5enBCOGZEN3ZkcmQzK3QvLzhhWGRuMzMwZ1ZLeWcwVFUzUmYrUWNvRGlmT25xYlgxeTVTbW9UNlJXVnU2QjRBQUxKdDkrZi9sRjQ1ZnpiRW1hTDE5RXg5aG1KZ1ZKY21BQUJBVWhCNEFBQlFDQWc4QUFBb0JBUWVBQUFVQWdJUEFBQUtnWmNXbTZVTStjN0xxK1d2L0xmais5dVgzRXdWRXQvK3dCMkgzdnkrdTlOZS9KY0xVTzArSCtjNngzMlVFZC83NnovWTBUNzVZaTNvdkJ2Zi8xamZqMS84OHYraWkxLzVDNEkrSnFaWHArNzU2VU5UZDd6SG9memcxWFRtQmp4M1FCME81Y1NSci8zMTNHc1h6OGUrZXRCSDN2YWpYZ25DZWw5Yy9SYjk1YmUrUW5GSXV5U0JUUWdobXBReG43bi9VeTFCTG05bW1KblFjNTU1c2ZuQm4zaDdxb0VucGR4RkF3SXZLMy8zVng5NzY1eExJakRzMktEQVczdmxIK2o4Ri8rTW9LL3loWlduZGwxcXQyZnlzaUMxcnJNYkZIZ3Q5ZHB2VVE0a3VWN21oK3hLMzhEak1vSzRBbThjTXRtbCtjRy8rdVVWU1ZabVZtVGg1ZEw0WnlhSTVOWGZlZXQrRlhhcExVQlFWTHhLeTJTcHRNd2IzaEprU1pVeWROTnZnc3lPNFdVcDlOUWJ5dk1Fa1hoaDV5MzJER25nMEpzb2xZNi84b203ODdLNGR1N0p6cEFGUkpEcFNTdFpDVDBoQ2V0blJvQ3dHNXV5bUhTWEVYcm1VOTJaVmNKdUNKRmxmcFptTmtLdmhPN01rQkIyWStlRkhybzN6ZVpLcWhORWxvdXlCSk5ERCtOMzRTSHNqRkhHbUo3WmhLQWRCSkhscGc3UDFOQ3pwTlVpQ1BUdFIrK3FJZXpNMFozSWNxWmhZMUtFWVZSM0pzOWF4dDlsQ0xrcVBEY3g5Rnh5anhMNDRwWkV5ZkoyYUFhRGNPaXR2YUcwU0dBVTFaMFpxa3dIcnBXN2xWWk1DNzEycWQwaUdJakRickprTGVkMVIvTE1FMVE5K1R0dlRhVFdDNGFqdWpPM0V3d2xsMHVMbVJKNlBIN0h1N2dURERSaGxSWWtDWnZBWEZMcy9kYWpiOTFMTUhhcU81Tm4wTm9FUThudFdwb21oQjdHNy96eEpCVnVRUkFZcnlURWZreGlNVUtWWUdpNVhqeDYzS0dIOGJ2QjFKdG5GWk5VTXFXTVNTeEd3T3pNRWVSK3Q0UnhoaDdHNy9yVDQzYVlwSkl4M2lTV0d5eXM3akZHc3JNd05neXBFTnNEalNQMDFBdHpCZU4zL1pXc1VnUGpkaG1seHZOTy92YmJxbVEycm51ZEdYQmt0aVpXajkraGhUMkN3dXlIbDNib1dTUlFiTjdISzQvZFZSZUNkaEZrbGlqSkJaTzdOb1VRdkJ0SWE4Q1JpUVhuQjdBSlJsS29EV0RUREwyMks1OG11SVpGRWwxaUdjZGRteGZmWUdIV1p2clFuVG1pd3UxNG5sYm91Wk5yYU9HdHc3TXkwWldaRDVZUWM1aTFtUzVYSXZCR1ZiakFZMG1ISHNidnJzVnZqcGlWbVN0bHJxRWtTSTBhQ3RoRU1KSkNCaDVMTXZRd2ZuY3RucWhDa0MrOENvdjVFMWp5eENZWVNXRURqeVVWZWhpL3V4cTM3akJSSmFjc2pNbW1vYmE4d0pPRU1FTnpSSVVPUEpaRTZKMXJyN1VJTGtQckxzZlF5a3NMd2k0R2hRODgxZ2s5dVk5aXdPTjNzeXY3c2p6MU9WWm8zUlVBV25scHNBbEdoc0RUUHZoWHY5WlVvVGRMbzhOeVlqM1F1aXNBdFBJZ0l4QjRQZUlJUGVsU2k4Q0QxbDJCb0pXWE5KdGdaQWk4ZFVZTlBZemZYVEUxTVRGSFVBeXFsWWVGcGNGMENMdytoZzg5MGNMNDNSVlN1dGladVVDdytncVlib0tnTHc2OXo5ei91K3JHVllRdXJsVWgrVHlCNTlTamQ5VWt1bUVLaFZkZlVROE5ndGd0emN3MjFVT1RVcklrNnllb3ovWDc0ei93dHVaN2I3ODdqcmtPWTRFV25vK29MVDFSb2lVQ1QxdFFuYUJveXBpOEFpWkRDeTlBbEpiZTJmTllQNVB4WkJWckRCdFZubnZ1ZC90Ky9OTFh2MENRRGxtU1BFbXBSUUFHUXVDRkVDNzBNSDdYVlNxVnFqUUc1NDc5THNGNENhTGFtWWE5NzVhR2cyc0JqSU11elpDQ3VqY3hmbmVGR3J2RFpKWGlLcTlOVDJCVmZ6QVNBaThDdjlERCtOMFY0K2pPQkhOSWdkbTVZQ1lFWGtTRFF1L25QLytyTFFJNitkdDJsYURRaENXdzJBQVlDWUUzaEd0RFQ3UUlQTEprNGU0ZXl0Z2NGa3lFd0J0U2IraTVRbUw5VEUyUXRaMmc4SVNGR3g4d0R3SnZCTjNRc3l4TXcyWm5EdkxTVWhJVEZvQ0wwRGNUZ0dGUWxqQWlEajBDejlwNXFsQ0pBUGhPdWtvQWhrRUxEMklqTFF1dE8vRHdzbkpZVEJwTWc4Q0QyRWdocWdTZ29SNFBUSVBBZzloWUpEWVJnTmEyWEFRZUdBV0JCekhDaEJXNEFoTlh3RFFJUElnRjZxNWdQVFdPZHdzQkdBU0JCN0dZd041M3NFNkpDQzA4TUFvQ0QySWhyQkptNU1GVnNBRXdtQWFCQjdGd1Nkb0VzQTVLRThBa0NEeUloYnFieHhzYlhPUDhORjRYWUE0RUhzUUVMVHk0VnR0RjRJRTVFSGdBa0pocGF3S0JCOFpBNEVFOGhJVTNOZ0F3R2dJUFlsR1NkRE1CckNOTDZPb0djMkMzQklpRmRNVUJVWkpIQ0tESFdydmRJZ0JESVBBZ0ZyZjk1bGRhQkFCZ01IUnBBZ0JBSWFDRkJ3QUFWeEZDM0VrNWhCWWVBQUFVQWdJUEFBQUtBWUVIQUFDRmdNQURBSUJDUU9BQkFFQWhJUEFBQUtBUUVIZ0FBRkFJQ0R3QUFDZ0VCQjRBQUJRQ0FnOEFBQW9CZ1FjQUFJV0F3QU1BZ0VKQTRBRUFRQ0VnOEFBQW9CQVFlQUFBVUFnSVBBQUFLQVFFSGdBQUZBSUNEd0FBQ2dHQkJ3QUFoWURBQXdDQVFrRGdBUUJBSVNEd0FBQ2dFQkI0QUFCUUNCTUVlWFpFSFVmN2ZIeVZBQUFLNXA4QWd3ZGgwWWJ6VmxRQUFBQUFTVVZPUks1Q1lJST0iLz4KPC9kZWZzPgo8L3N2Zz4K";

const StyledFooter = styled.footer`
  margin-top: 17rem;
  padding-bottom: 5rem;
  display: flex;
  justify-content: center;
  .logo-box {
    display: flex;
    align-items: center;
    img {
      margin-right: 1.8rem;
    }
  }
  @media ${widthQuery.md} {
    margin-top: 12rem;
  }
  @media ${widthQuery.sm} {
    margin-top: 6rem;
  }
  @media ${widthQuery.xs} {
    margin-top: 3rem;
  }
`;
const Footer = () => {
  return /* @__PURE__ */ jsx(StyledFooter, {
    children: /* @__PURE__ */ jsxs("div", {
      className: "logo-box",
      children: [/* @__PURE__ */ jsx("img", {
        src: hausCastle,
        alt: "daohaus castle logo"
      }), /* @__PURE__ */ jsxs(ParMd, {
        children: ["Built by", " ", /* @__PURE__ */ jsx(Link, {
          href: "https://daohaus.club",
          linkType: "external",
          children: "DAOhaus"
        })]
      })]
    })
  });
};

const OuterLayout = styled.div`
  width: 100%;
`;

const StyledFormSegment = styled.section`
  width: 100%;
  margin-bottom: 2.4rem;

  .segment-title {
    margin-bottom: 3.2rem;
  }

  .segment-description {
    margin-bottom: 3rem;
  }
`;

const FormSegment = ({
  title,
  description,
  formArea
}) => {
  return /* @__PURE__ */ jsxs(StyledFormSegment, {
    children: [/* @__PURE__ */ jsx(H5, {
      className: "segment-title",
      children: title
    }), /* @__PURE__ */ jsx(ParMd, {
      className: "segment-description",
      children: description
    }), /* @__PURE__ */ jsx("div", {
      children: formArea
    }), /* @__PURE__ */ jsx(Divider, {})]
  });
};

const StyledSplitColumn = styled.div`
  display: flex;
  width: 100%;
  justify-content: space-between;
  flex-direction: column;
`;
const StyledRow = styled.div`
  display: flex;
  width: 100%;
  justify-content: space-between;
  margin-bottom: 3.6rem;

  .left-section,
  .right-section {
    width: 24rem;
    @media ${widthQuery.sm} {
      width: 100%;
      margin-bottom: 1.6rem;
    }
  }
  @media ${widthQuery.sm} {
    flex-direction: column;
  }
`;

const SplitColumn = ({
  rows
}) => {
  return /* @__PURE__ */ jsx(StyledSplitColumn, {
    children: Array.isArray(rows) ? rows.map((row) => {
      return /* @__PURE__ */ jsx(Row, {
        ...row
      }, row.rowId);
    }) : /* @__PURE__ */ jsx(Row, {
      ...rows
    })
  });
};
const Row = ({
  left,
  right
}) => {
  return /* @__PURE__ */ jsxs(StyledRow, {
    children: [/* @__PURE__ */ jsx("div", {
      className: "left-section",
      children: left
    }), /* @__PURE__ */ jsx("div", {
      className: "right-section",
      children: right
    })]
  });
};

const MainLayout = styled.main`
  display: flex;
  width: 100%;
  justify-content: center;
  padding: 0 3.2rem 2.4rem 3.2rem;
  @media ${widthQuery.sm} {
    padding: 0 2.4rem 2.4rem 2.4rem;
  }
`;

const FormContainer = styled.div`
  width: 58rem;
  margin-top: 5rem;

  .subtitle {
    margin-bottom: 1.2rem;
    opacity: 0.6;
  }
  .title {
    margin-bottom: 3rem;
  }
  .description {
    margin-bottom: 5rem;
  }
`;

const FormLayout = ({
  title,
  subtitle,
  description,
  children
}) => {
  const formSubtitle = useMemo(() => {
    if (!subtitle)
      return null;
    if (typeof subtitle === "string")
      return /* @__PURE__ */ jsx(DataMd, {
        className: "subtitle",
        children: subtitle
      });
    return /* @__PURE__ */ jsx("div", {
      className: "subtitle",
      children: subtitle
    });
  }, [subtitle]);
  const formTitle = useMemo(() => {
    if (!title)
      return null;
    if (typeof title === "string")
      return /* @__PURE__ */ jsx(H2, {
        className: "title",
        children: title
      });
    return /* @__PURE__ */ jsx("div", {
      className: "title",
      children: title
    });
  }, [title]);
  const formDescription = useMemo(() => {
    if (!description)
      return null;
    if (typeof description === "string")
      return /* @__PURE__ */ jsx(DataMd, {
        className: "description",
        children: description
      });
    return /* @__PURE__ */ jsx("div", {
      className: "description",
      children: description
    });
  }, [description]);
  return /* @__PURE__ */ jsxs(FormContainer, {
    children: [formSubtitle, formTitle, formDescription, children]
  });
};

const BiColumnBox = styled.div`
  margin-top: 5rem;
  width: 100%;
  max-width: 110rem;
  .subtitle {
    margin-bottom: 1.2rem;
    opacity: 0.6;
  }
  .title {
    margin-bottom: 3rem;
  }
  .description {
    margin-bottom: 5rem;
  }
  .split {
    display: flex;
    flex-direction: row;
    gap: 3rem;
    @media ${widthQuery.md} {
      flex-direction: column;
    }
  }
  @media ${widthQuery.sm} {
    margin-top: 3rem;
  }
`;
const TitleContainerWithActions$1 = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  width: 100%;
`;
const ActionButtonContainer$1 = styled.div`
  display: flex;
  gap: 1rem;
  margin-bottom: 3rem;
`;

const BiColumnLayout = ({
  left,
  right,
  title,
  subtitle,
  description,
  actions
}) => {
  const sectionSubtitle = useMemo(() => {
    if (!subtitle)
      return null;
    if (typeof subtitle === "string")
      return /* @__PURE__ */ jsx(DataMd, {
        className: "subtitle",
        children: subtitle
      });
    return /* @__PURE__ */ jsx("div", {
      className: "subtitle",
      children: subtitle
    });
  }, [subtitle]);
  const sectionTitle = useMemo(() => {
    if (!title)
      return null;
    if (!actions)
      return typeof title === "string" ? /* @__PURE__ */ jsx(H2, {
        className: "title",
        children: title
      }) : /* @__PURE__ */ jsx("div", {
        className: "title",
        children: title
      });
    return /* @__PURE__ */ jsxs(TitleContainerWithActions$1, {
      children: [typeof title === "string" ? /* @__PURE__ */ jsx(H2, {
        className: "title",
        children: title
      }) : /* @__PURE__ */ jsx("div", {
        className: "title",
        children: title
      }), actions && /* @__PURE__ */ jsx(ActionButtonContainer$1, {
        children: actions
      })]
    });
  }, [title, actions]);
  const sectionDescription = useMemo(() => {
    if (!description)
      return null;
    if (typeof description === "string")
      return /* @__PURE__ */ jsx(DataMd, {
        className: "description",
        children: description
      });
    return /* @__PURE__ */ jsx("div", {
      className: "description",
      children: description
    });
  }, [description]);
  return /* @__PURE__ */ jsxs(BiColumnBox, {
    children: [sectionSubtitle, sectionTitle, sectionDescription, /* @__PURE__ */ jsxs("div", {
      className: "split",
      children: [left, right]
    })]
  });
};

const ColumnBox = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  width: 100%;
  max-width: 110rem;
`;
const ColumnHeader = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  margin-top: 5rem;
  width: 100%;
  .subtitle {
    margin-bottom: 1.2rem;
    opacity: 0.6;
  }
  .title {
    margin-bottom: 3rem;
  }
  .description {
    margin-bottom: 5rem;
  }
  @media ${widthQuery.sm} {
    margin-top: 3rem;
  }
`;
const ContentBox = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;
const TitleContainerWithActions = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  width: 100%;
  @media ${widthQuery.sm} {
    flex-direction: column;
    align-items: flex-start;
  }
`;
const ActionButtonContainer = styled.div`
  display: flex;
  gap: 1rem;
  margin-bottom: 3rem;
  @media ${widthQuery.sm} {
    width: 100%;
    flex-direction: column;
  }
`;

const SingleColumnLayout = ({
  title,
  subtitle,
  description,
  actions,
  children
}) => {
  const sectionSubtitle = useMemo(() => {
    if (!subtitle)
      return null;
    if (typeof subtitle === "string")
      return /* @__PURE__ */ jsx(DataMd, {
        className: "subtitle",
        children: subtitle
      });
    return /* @__PURE__ */ jsx("div", {
      className: "subtitle",
      children: subtitle
    });
  }, [subtitle]);
  const sectionTitle = useMemo(() => {
    if (!title)
      return null;
    if (!actions)
      return typeof title === "string" ? /* @__PURE__ */ jsx(H2, {
        className: "title",
        children: title
      }) : /* @__PURE__ */ jsx("div", {
        className: "title",
        children: title
      });
    return /* @__PURE__ */ jsxs(TitleContainerWithActions, {
      children: [typeof title === "string" ? /* @__PURE__ */ jsx(H2, {
        className: "title",
        children: title
      }) : /* @__PURE__ */ jsx("div", {
        className: "title",
        children: title
      }), actions && /* @__PURE__ */ jsx(ActionButtonContainer, {
        children: actions
      })]
    });
  }, [title, actions]);
  const sectionDescription = useMemo(() => {
    if (!description)
      return null;
    if (typeof description === "string")
      return /* @__PURE__ */ jsx(DataMd, {
        className: "description",
        children: description
      });
    return /* @__PURE__ */ jsx("div", {
      className: "description",
      children: description
    });
  }, [description]);
  return /* @__PURE__ */ jsxs(ColumnBox, {
    children: [/* @__PURE__ */ jsxs(ColumnHeader, {
      children: [sectionSubtitle, sectionTitle, sectionDescription]
    }), /* @__PURE__ */ jsx(ContentBox, {
      children
    })]
  });
};

export { AddressDisplay, AppSwitcher, AppSwitcherLink, AppSwitcherTrigger, Avatar, Badge, Banner, BiColumnLayout, BlockieImg, Bold, Button, CSInput, Card, CheckGate, Checkbox, DangerDarkButton, DangerLightButton, DataIndicator, DataLg, DataMd, DataSm, DataXl, DataXs, Dialog, DialogContent, DialogTrigger, Divider, Dropdown, DropdownButton, DropdownLink$1 as DropdownLink, DropdownMenuItem, DropdownMenuLabel, DropdownText, DropdownTriggerLink, ErrorText, ExtraBold, ExtraLight, FieldAlert, FieldWrapper, FileInput, Footer, FormLayout, FormProvider, FormSegment, GlobalStyles, H1, H2, H3, H4, H5, H6, HausThemeContext, HausThemeProvider, HelperText, HighlightInputText, Icon, Input, InputSelect, Italic, Label$1 as Label, LgTooltipIcon, Light, Link, MainLayout, MemberCard, MemberCardTrigger, NavigationTabs, OuterLayout, ParLg, ParMd, ParSm, ParXl, ParXs, PrimaryDarkButton, PrimaryLightButton, ProfileAvatar, Progress, SecondaryDarkButton, SecondaryLightButton, Select, ShamanPermission, SingleColumnLayout, SmTooltipIcon, Spinner, SplitColumn, StrikeThrough, SuccessDarkButton, SuccessLightButton, SuccessText, Switch, Tag, TertiaryDarkButton, TertiaryLightButton, TextArea, TimePicker, TintSecondary, Toast, Tooltip, Underline, WarningDarkButton, WarningLightButton, WarningText, WrappedCheckbox, WrappedInput, WrappedInputSelect, WrappedRadio, WrappedSelect, WrappedSwitch, WrappedTextArea, border, breakpoints, defaultDarkTheme, defaultLightTheme, field, font, useBreakpoint, useCopyToClipboard, useDebounce, useForm, useToast, widthQuery };
